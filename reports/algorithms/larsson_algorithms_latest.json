{
  "source": "docs/Larsson_Tesis_full.txt",
  "total_algorithms": 70,
  "algorithms": [
    {
      "title": "Rule 2.1: getLatestMove",
      "section": "Unknown",
      "page": 63,
      "category": "Other Algorithms",
      "rule_id": "2.1",
      "content": " (rule 2.1)   rule: getLatestMove\n              class:( grounding\n                       $latest moves=M oves\n              pre:\n                       $latest speaker=DP\n                   (\n                      /shared/lu/moves := M oves\n              eff:\n                      /shared/lu/speaker := DP\n\nThis rule copies the information about the latest utterance from the latest moves and\nlatest speaker to the /shared/lu field. The first condition picks out the (singleton)\nset of moves stored by the interpretation module, and the second condition gets the value\nof the latest speaker variable. The updates set the values of the two subfields of the\n/shared/lu record correspondingly.\n\n",
      "context_before": "2.8. IBIS1 UPDATE MODULE                                                               41\n\n",
      "context_after": "\n2.8.2    Raising issues: the ask move\n\nBefore we explain the rules used by IBiS1 for dealing with the ask move, we will review\nGinzburg’s protocols for querying and assertion on which the rules are based. We will also"
    },
    {
      "title": "Rule 2.2: integrateSysAsk",
      "section": "Unknown",
      "page": 65,
      "category": "Update Rules",
      "rule_id": "2.2",
      "content": " (rule 2.2)    rule: integrateSysAsk\n               class:( integrate\n                        $/shared/lu/speaker==sys\n               pre:\n                        in($/shared/lu/moves, ask(Q))\n                    n\n               eff: push(/shared/QUD, Q)\n\n\nThe conditions of the rule in (2.14) checks that the latest speaker is sys and that the latest\nmove was an ask move with content Q. The update pushes Q on /shared/QUD.\n",
      "context_before": "For integration of ask moves, different rules are used depending on who the speaker is: the\nsystem (rule 2.2) or the user (rule 2.3.)\n\n\n",
      "context_after": ""
    },
    {
      "title": "Rule 2.3: integrateUsrAsk",
      "section": "Unknown",
      "page": 66,
      "category": "Update Rules",
      "rule_id": "2.3",
      "content": " (rule 2.3)       rule: integrateUsrAsk\n                  class:( integrate\n                           $/shared/lu/speaker==usr\n                  pre:\n                           in($/shared/lu/moves, ask(Q))\n                       (\n                           push(/shared/QUD, Q)\n                  eff:\n                           push(/private/agenda, respond(Q))\n\nThe update rule in (rule 2.3) for integrating user queries is slightly different: if the user\nasks a question q, the system will also push respond(q) on the agenda. This does not\nhappen if the system asks the question, since it is the user who is expected to answer this\nquestion.\n\nEventually, the findPlan (see Section 2.8.6) rule will load the appropriate plan for dealing\nwith Q. This assumes that for any user question that the system is able to interpret, there\nis a plan for dealing with that question. If this were not the case, IBiS would somehow\nhave to reject Q; in Chapter 3 we will discuss this further.\n\n\nReasons for answering questions\n\n\nThe solution of pushing respond(Q) on the agenda when integrating a user ask(Q) move is\nnot the only possible option. It can be seen as a simple “intention-based” strategy involving\nminimal reasoning; “If the user asked q, I’m going to respond to q”. Alternatively, one\ncould opt for a more indirect link between the user asking a question and the system\nintending to respond to it.\n\nOne such indirect approach is to not push respond(Q) on the agenda when integrating a\nuser ask(Q) move, but only push Q on QUD7. A separate rule would then push respond(Q)\non the agenda given that Q is on QUD and the system has a plan for responding to Q.\nThis reasoning behind this rule could be paraphrased roughly as “If q is under discussion\nand I know a way of dealing with q, I should try to respond to q”. On this approach,\nit would be assumed that DPs do not care about who asked a question; they will simply\nattempt to answer any question that is under discussion, regardless of who raised it.\n\nA second indirect approach is to assume that asking a question introduces obligations on\nthe addressee. This “obligation-based approach” would require representing obligations as\npart of the shared information. For an obligation-based account of dialogue, see Traum\n(1996); for a comparison of QUD-based and obligation-based approaches, see Kreutel and\n     7\n    If the system can understand user questions which it cannot respond to (which IBiS1 does not), the\nintegration rule for user ask moves would still need to check that there is a plan for dealing with Q, or else\nreject Q; issue rejection is discussed further in Chapter 3.\n",
      "context_before": "44                     CHAPTER 2. BASIC ISSUE-BASED DIALOGUE MANAGEMENT\n\n",
      "context_after": ""
    },
    {
      "title": "Rule 2.4: integrateAnswer",
      "section": "Unknown",
      "page": 69,
      "category": "Update Rules",
      "rule_id": "2.4",
      "content": " (rule 2.4)   rule: integrateAnswer\n              class: integrate\n                    in($/shared/lu/moves, answer(A))\n                   \n              pre:  fst($/shared/QUD, Q)\n                   \n                   (\n                        $domain :: relevant(A, Q)\n                       ! $domain :: combine(Q, A, P )\n              eff:\n                       add(/shared/com, P )\n\nThe first condition checks that the latest move was an answer move with content A, and\nthe next two conditions check that A is relevant to some question Q topmost on QUD.\nThe first updates combines Q and A to form a proposition P according to the definition\nin Section 2.4.7. Finally, P is added to the shared commitments.\n\n",
      "context_before": "2.8. IBIS1 UPDATE MODULE                                                               47\n\n",
      "context_after": "\n2.8.4    Downdating QUD\n\nQUD downdating principle\n"
    },
    {
      "title": "Rule 2.5: downdateQUD",
      "section": "Unknown",
      "page": 70,
      "category": "Update Rules",
      "rule_id": "2.5",
      "content": " (rule 2.5)    rule: downdateQUD\n               class: downdate QUD\n                     fst($/shared/QUD, Q)\n                    \n               pre:  in($/shared/com, P )\n                    \n                    n\n                        $domain :: resolves(P, Q)\n               eff: pop(/shared/QUD)\n\nThe paraphrase of this rule is straightforward and is left as an exercise to the reader.\n\nThis rule is perhaps inefficient in the sense that it may require checking all propositions in\n/shared/com every time the update algorithm is executed. However, in the systems we\nare concerned with the number of propositions is not very high, and in addition we favour\nclarity and simplicity in the implementation over efficiency.\n\n",
      "context_before": "48                 CHAPTER 2. BASIC ISSUE-BASED DIALOGUE MANAGEMENT\n\n",
      "context_after": "\n2.8.5     Integrating greet and quit moves\n\nIn IBiS1 greetings have no effect on the information state. The rule for integrating greetings\nis shown in (rule 2.6)."
    },
    {
      "title": "Rule 2.6: integrateGreet",
      "section": "Unknown",
      "page": 70,
      "category": "Update Rules",
      "rule_id": "2.6",
      "content": " (rule 2.6)    rule: integrateGreet\n               class:n integrate\n               pre: in($/shared/lu/moves, greet)\n               eff: {\n\n\nThe update rules for integrating quit moves performed by the user or system are shown in",
      "context_before": "In IBiS1 greetings have no effect on the information state. The rule for integrating greetings\nis shown in (rule 2.6).\n\n\n",
      "context_after": "(rule 2.7) and (rule 2.8,) respectively.\n\n\n\n (rule 2.7)    rule: integrateUsrQuit"
    },
    {
      "title": "Rule 2.7: and (rule 2.8,) respectively.",
      "section": "Unknown",
      "page": 70,
      "category": "Other Algorithms",
      "rule_id": "2.7",
      "content": "(rule 2.7) and (rule 2.8,) respectively.\n\n",
      "context_before": "               pre: in($/shared/lu/moves, greet)\n               eff: {\n\n\nThe update rules for integrating quit moves performed by the user or system are shown in",
      "context_after": "\n (rule 2.7)    rule: integrateUsrQuit\n               class:( integrate\n                        $/shared/lu/speaker==usr\n               pre:"
    },
    {
      "title": "Rule 2.7: integrateUsrQuit",
      "section": "Unknown",
      "page": 70,
      "category": "Update Rules",
      "rule_id": "2.7",
      "content": " (rule 2.7)    rule: integrateUsrQuit\n               class:( integrate\n                        $/shared/lu/speaker==usr\n               pre:\n                        in($/shared/lu/moves, quit)\n                    n\n               eff: push(/private/agenda, quit)\n\nIf the quit move is performed by the user, the effect is that the system puts quit on the\nagenda so that it gets to say “Goodbye” to the user before the dialogue ends.\n",
      "context_before": "The update rules for integrating quit moves performed by the user or system are shown in\n(rule 2.7) and (rule 2.8,) respectively.\n\n\n",
      "context_after": ""
    },
    {
      "title": "Rule 2.8: integrateSysQuit",
      "section": "Unknown",
      "page": 71,
      "category": "Update Rules",
      "rule_id": "2.8",
      "content": " (rule 2.8)   rule: integrateSysQuit\n              class:( integrate\n                       $/shared/lu/speaker==sys\n              pre:\n                       in($/shared/lu/moves, quit)\n                   n\n              eff: program state := quit\n\n\nIntegrating a quit move performed by the system causes the program state variable to\nbe set to quit. This will eventually cause the program to halt.\n\nThe greet move does not have any effect on the information state, and thus no update rule\nis needed to integrate it.\n\n",
      "context_before": "2.8. IBIS1 UPDATE MODULE                                                              49\n\n",
      "context_after": "\n2.8.6    Managing the plan\n\nThe dialogue plans are interpreted by a class of update rules called exec plan. When a\nplan has been entered into the /private/plan field, it is processed incrementally by the"
    },
    {
      "title": "Rule 2.9: findPlan",
      "section": "Unknown",
      "page": 71,
      "category": "Other Algorithms",
      "rule_id": "2.9",
      "content": " (rule 2.9)   rule: findPlan\n                    find plan\n              class:\n                    fst($/private/agenda, respond(Q))\n                   \n              pre:  $domain :: plan(Q, P lan)\n                   \n                   (\n                      not in($/private/bel, P ) and $domain :: resolves(P, Q)\n                      pop(/private/agenda)\n              eff:\n                      set(/private/plan, P lan)\n\nThe first two conditions check that there is an action respond(Q) on the agenda and that\nthe system has a plan for dealing with Q. The third condition checks that the system does\nnot already know an answer to Q (if it does, the system should instead respond to Q). If\nthese conditions hold, the updates pop respond(Q) off the agenda and load the plan.\n",
      "context_before": "\nWhen integrating a user ask move with content Q, the action respond(Q) is pushed on the\nagenda, thus enabling (rule 2.9) to trigger and load a plan for dealing with Q.\n\n",
      "context_after": ""
    },
    {
      "title": "Rule 2.10: removeFindout",
      "section": "Unknown",
      "page": 72,
      "category": "Other Algorithms",
      "rule_id": "2.10",
      "content": "(rule 2.10) rule: removeFindout\n            class: exec plan\n                  fst($/private/plan, findout(Q))\n                 \n            pre:  in($/shared/com, P )\n                 \n                 n\n                     $domain :: resolves(P, Q)\n            eff: pop(/private/plan)\n\n\nThis rule removes a findout(Q) action from the plan in case there is a resolving proposition\nP in /shared/com.\n\nIf there is a consultDB action topmost on the plan, (rule 2.11) will trigger a database\nsearch.\n\n",
      "context_before": "shared. On an individual level, each DP should make sure to not ask such questions. In\nIBiS1, this will be guaranteed by the removeFindout (rule 2.10).\n\n\n",
      "context_after": "\n(rule 2.11) rule: exec consultDB\n            class:n exec plan\n            pre: fst($/private/plan, consultDB(Q))\n                     ! $/shared/com=B"
    },
    {
      "title": "Rule 2.11: exec consultDB",
      "section": "Unknown",
      "page": 72,
      "category": "Update Rules",
      "rule_id": "2.11",
      "content": "(rule 2.11) rule: exec consultDB\n            class:n exec plan\n            pre: fst($/private/plan, consultDB(Q))\n                     ! $/shared/com=B\n                 \n                 \n                 \n                  ! $database :: consultDB(Q, B, C)\n                 \n            eff: \n                 \n                    add(/private/bel, C)\n                     pop(/private/plan)\n                 \n\n",
      "context_before": "If there is a consultDB action topmost on the plan, (rule 2.11) will trigger a database\nsearch .\n\n\n",
      "context_after": "\nThis rule takes all the propositions in /shared/com and given this looks up the answer\nto q in the database. The resulting proposition is stored in /private/bel.\n"
    },
    {
      "title": "Rule 2.12: selectFromPlan",
      "section": "2.9 IBiS",
      "page": 73,
      "category": "Selection Rules",
      "rule_id": "2.12",
      "content": "(rule 2.12) rule: selectFromPlan\n            class:( select action\n                     is empty($/private/agenda)\n            pre:\n                     fst($/private/plan, Action)\n                 n\n            eff: push(/private/agenda, Action)\n",
      "context_before": "2.9.1     Selecting an action from the plan\n\nThe rule for selecting an action from the plan is shown in (rule 2.12).\n\n",
      "context_after": ""
    },
    {
      "title": "Rule 2.13: selectAsk",
      "section": "Unknown",
      "page": 74,
      "category": "Selection Rules",
      "rule_id": "2.13",
      "content": "(rule 2.13) rule: selectAsk\n            class:\n                 ( select move\n                    fst($/private/agenda, findout(Q)) or fst($/private/agenda,\n            pre:\n                        raise(Q))\n                 (\n                   add(next moves, ask(Q))\n            eff:\n                   if do(fst($/private/plan, raise(A)), pop(/private/plan))\n",
      "context_before": "plan in case there is a resolving proposition in /shared/com.\n\nThe rule for selecting an ask move is shown in (rule 2.13).\n\n",
      "context_after": ""
    },
    {
      "title": "Rule 2.14: selectRespond",
      "section": "Unknown",
      "page": 75,
      "category": "Selection Rules",
      "rule_id": "2.14",
      "content": "(rule 2.14) rule: selectRespond\n            class: select action\n                 \n                    is empty($/private/agenda)\n                     is empty($/private/plan)\n                 \n                 \n                 \n                 \n                 \n                  fst($/shared/QUD, Q)\n                 \n            pre: \n                 \n                    in($/private/bel, P )\n                     not in($/shared/com, P )\n                 \n                 \n                 \n                 \n                 \n                     $domain :: relevant(P, Q)\n                 \n                 n\n            eff: push(/private/agenda, respond(Q))\n\n\nThe first two conditions check that there is nothing else that currently needs to be done.\nThe remaining conditions check that some question Q is topmost on QUD, the system\nknows a relevant answer P to Q which is not yet shared.\n",
      "context_before": "action, in the case where the user asks a question which the system already knows the\nanswer to.\n\nThe rule for selecting to respond to a question is shown in (rule 2.14).\n",
      "context_after": ""
    },
    {
      "title": "Rule 2.15: selectAnswer",
      "section": "Unknown",
      "page": 76,
      "category": "Selection Rules",
      "rule_id": "2.15",
      "content": "(rule 2.15) rule: selectAnswer\n            class: select move\n                 \n                    fst($/private/agenda, respond(Q))\n                  in($/private/bel, P )\n                 \n            pre:\n                 \n                 \n                 \n                     not in($/shared/com, P )\n                     $domain :: relevant(Å, Q)\n                 \n                 n\n            eff: add(next moves, answer(P ))\n\n",
      "context_before": "be pushed on next moves.\n\n\n\n",
      "context_after": "\nAgain, it may be argued that it is inefficient to have to check the same conditions twice in\nthe case where selectAnswer is preceded by selectRespond. However, as we mentioned\nabove the respond action may also have been pushed on the agenda when integrating a\nuser ask move, and in this case the conditions need to be checked."
    },
    {
      "title": "Rule 2.16: downdateQUD2",
      "section": "Unknown",
      "page": 85,
      "category": "Update Rules",
      "rule_id": "2.16",
      "content": "(rule 2.16) rule: downdateQUD2\n            class: downdate QUD\n                  in($/shared/QUD, IssueQ)\n                 \n            pre:  fst($/shared/QUD, Q)\n                 \n                 n\n                     $domain :: resolves(Q, IssueQ)\n            eff: del(/shared/QUD, IssueQ)\n\n\nWe also need to define resolvedness conditions for issue-questions (for example, an issue-\nquestion cannot be resolved by an issue-question). In addition, rules for removing findout\nand raise actions from the plan based on the contents of QUD would need to be added.\n",
      "context_before": "QUD (rather than based only on the shared commitments, as has been done until now).\nFor example, for removing resolved issue-questions off QUD, (rule 2.16) would need to\nbe added (note that this rule requires QUD to be an open stack).\n\n",
      "context_after": ""
    },
    {
      "title": "Rule 2.17: recoverPlan",
      "section": "Unknown",
      "page": 86,
      "category": "Other Algorithms",
      "rule_id": "2.17",
      "content": "(rule 2.17) rule: recoverPlan\n            class: exec plan\n                 \n                    fst($/shared/QUD, Q)\n                  is empty($/private/agenda)\n                 \n            pre: \n                 \n                    is empty($/private/plan)\n                     $domain :: plan(Q, P lan)\n                 \n                 n\n            eff: set(/private/plan, P lan)\n\nHowever, this solution has a problem. If, when dealing with a question q, the system\nasks a question qu and the user does not answer this question but instead raises a new\nquestion q1, both q and qu will remain on QUD when q1 has been resolved. Now, if the\nuser simply answers qu immediately after q1 has been resolved, everything is fine and the\nsystem will reload the plan for dealing with q. However, if the user does not answer q u,\n",
      "context_before": "The recoverPlan rule (rule 2.17) will pick up any question Q lying around on QUD\nwhen the plan and agenda is empty, check if there is a plan for resolving it, and if so load\nthis plan.\n\n",
      "context_after": ""
    },
    {
      "title": "Rule 2.18: reraiseIssue",
      "section": "Unknown",
      "page": 87,
      "category": "Other Algorithms",
      "rule_id": "2.18",
      "content": "(rule 2.18) rule: reraiseIssue\n            class:( select action\n                     fst($/shared/QUD, Q)\n            pre:\n                     not $domain :: plan(Q, SomeP lan)\n                 n\n            eff: push(/private/agenda, raise(A))\n\n",
      "context_before": "previously by the system).\n\n\n\n",
      "context_after": "\n\nIssues are divided up between those for which the system has an associated plan in its\ndomain resource and those for which it does not. For example, the “price issue” is one for\nwhich there is a plan: the system has to ask where the user wants to go, where from, when"
    },
    {
      "title": "Rule 2.19: removeRaise",
      "section": "Unknown",
      "page": 88,
      "category": "Other Algorithms",
      "rule_id": "2.19",
      "content": "(rule 2.19) rule: removeRaise\n            class: exec plan\n                  fst($/private/plan, raise(A))\n                 \n            pre:  in($/shared/com, B)\n                 \n                 n\n                     $domain :: resolves(B, A)\n            eff: pop(/private/plan)\n\n\nThis rule is needed to avoid asking the same question twice in case it is first reraised and\nthen also included in a recovered plan.\n\nA sample dialogue involving the system reraising an issue and recovering a plan is shown\nin (dialogue 2.4). Incidentally, this dialogue also demonstrates information sharing be-\ntween dialogue plans; when the user asks about visa, the system already knows what the\ndestination city is and thus does not ask this again. By contrast, in VoiceXML (McGlashan\net al., 2001), user-initiated subdialogues will cause previous dialogue to be forgotten. Only\nif there is a pre-scripted, system-initiated transition from one form to another can the\nprevious dialogue be resumed after the subdialogue has been completed9.\n\n\n(dialogue 2.4)\n\nS> Welcome to the travel agency!\n\nU> price information please\n\nS> How do you want to travel?\n\nU> plane\n\nS> What city do you want to go to?\n\nU> paris\n\nS> What city do you want to go from?\n\nU> do i need a visa\n\ngetLatestMove\n     9\n    Information sharing in VoiceXML is only possible in the case where a form F 1 calls another form F2.\nWhen F2 is finished and control is passed back to F1, information may be sent from F2 to F1. Information\nsharing is not supported e.g. in cases where user initiative leads to the adoption of F 2 while F1 is being\nexecuted.\n",
      "context_before": "66                    CHAPTER 2. BASIC ISSUE-BASED DIALOGUE MANAGEMENT\n\n",
      "context_after": ""
    },
    {
      "title": "Rule 3.1: integrateUsrAsk",
      "section": "Unknown",
      "page": 132,
      "category": "Update Rules",
      "rule_id": "3.1",
      "content": " (rule 3.1)    rule: integrateUsrAsk\n               class: integrate\n                    \n                    \n                    \n                        $/shared/lu/speaker==usr\n                     fst($/private/nim, ask(Q))\n                    \n                    \n                    \n               pre:  $score=Score\n                    \n                    \n                    \n                       Score > 0.7\n                     $domain :: plan(Q, P lan)\n                    \n\n                        1 pop(/private/nim)\n                    \n                    \n                    \n                        2 push(/private/agenda, icm:acc*pos)\n                    \n                    \n                    \n                    \n                    \n                        3 add(/shared/lu/moves, ask(Q))\n                    \n                    \n                    \n                    \n                    \n                     4 if do(Score ≤ 0.9,\n                    \n                    \n                    \n               eff:        push(/private/agenda, icm:und*pos:usr*issue(Q)))\n                    \n                    \n                    \n                       5 if do(in($/shared/QUD, Q) and not fst($/shared/QUD, Q),\n                            push(/private/agenda, icm:reraise:Q))\n                    \n                    \n                    \n                    \n                    \n                        6 push(/shared/QUD, Q)\n                    \n                    \n                    \n                    \n                    \n                        7 push(/private/agenda, respond(Q))\n                    \n\n",
      "context_before": "\nIntegration of user ask move The integration rule for user ask move implementing the\noptimistic grounding strategy is shown in (rule 3.1).\n\n",
      "context_after": "\nThe first two conditions picks out a user ask move on nim. The third and fourth con-\nditions check the recognition score of the utterance and if it is higher than 0.7 (T 2 ), the\nrule proceeds to check for acceptability. If the score is too low, the move should not be\noptimistically integrated; instead, a pessimistic grounding strategy should be applied and"
    },
    {
      "title": "Rule 3.2: selectIcmOther",
      "section": "Unknown",
      "page": 133,
      "category": "Selection Rules",
      "rule_id": "3.2",
      "content": " (rule 3.2)     rule: selectIcmOther\n                class:( select icm\n                         in($/private/agenda, icm:A)\n                pre:\n                         not in($next moves, B) and B=ask(C)\n                     (\n                        push(next moves, icm:A)\n                eff:\n                        del(/private/agenda, icm:A)\n\n\nDialogue example: integrating user ask-move The dialogue below shows how a user\nask move with a score of 0.76 is successfully integrated, and positive understanding and\nacceptance feedback is produced.\n\n\n(dialogue 3.3)\n\nS> Welcome to the travel agency!\n\nU> price information please [0.76]\n\ngetLatestMoves\n\n\n  set(/private/nim, oqueue([ask(?A.price(A))]))\n   set(/shared/lu/speaker, usr)\n\n\n  clear(/shared/lu/moves)\n   set(/shared/pm, set([greet]))\n\nintegrateUsrAsk\n",
      "context_before": "add moves to be generated to the next moves TIS variable based on the contents of\nthe agenda. ICM which is added to the agenda by the update module will be moved to\nnext moves by the default ICM selection rule (rule 3.2).\n\n",
      "context_after": ""
    },
    {
      "title": "Rule 3.3: selectIcmUndIntAsk",
      "section": "Unknown",
      "page": 134,
      "category": "Selection Rules",
      "rule_id": "3.3",
      "content": "    (rule 3.3)     rule: selectIcmUndIntAsk\n                   class: select icm\n                         $/shared/lu/speaker==usr\n                        \n                   pre:  fst($/private/nim, ask(Q))\n                        \n                        (\n                            $score ≤ 0.7\n                           pop(/private/nim)\n                   eff:\n                           push(next moves, icm:und*int:usr*issue(Q))\n",
      "context_before": "Interrogative understanding feedback for user ask move If a user ask move cannot\nbe assumed to be understood because of a low recognition score, interrogative feedback on\nthe understanding level is selected by (rule 3.3).\n\n",
      "context_after": ""
    },
    {
      "title": "Rule 3.4: is similar to that for ask moves, except that answers are checked for relevance",
      "section": "Unknown",
      "page": 135,
      "category": "Other Algorithms",
      "rule_id": "3.4",
      "content": "(rule 3.4) is similar to that for ask moves, except that answers are checked for relevance\nas well as reliability and acceptability.\n\n",
      "context_before": "will be the same as if the ask move had been integrated immediately (see Section 3.6.6 for\nfurther explanation).\n\n\nIntegration of user answer move The integration rule for user answer moves, shown in",
      "context_after": " (rule 3.4)    rule: integrateUsrAnswer\n               class: integrate\n                    \n                    \n                    "
    },
    {
      "title": "Rule 3.4: integrateUsrAnswer",
      "section": "Unknown",
      "page": 135,
      "category": "Update Rules",
      "rule_id": "3.4",
      "content": " (rule 3.4)    rule: integrateUsrAnswer\n               class: integrate\n                    \n                    \n                    \n                        1 fst($/private/nim, answer(A))\n                    \n                    \n                    \n                       2 $/shared/lu/speaker==usr\n                        3 ! $score=Score\n                    \n                    \n                    \n                    \n                    \n                     4 Score > 0.7\n                    \n               pre:\n                    \n                    \n                       5 fst($/shared/QUD, Q)\n                        6 $domain :: relevant(A, Q)\n                    \n                    \n                    \n                    \n                    \n                        7 $domain :: combine(Q, A, P )\n                    \n                    \n                    \n                    \n                    \n                    \n                        8 $database :: validDBparameter(P ) or P =not(X)\n                    \n                    \n                       1 pop(/private/nim)\n                        2 add(/shared/lu/moves, answer(P ))\n                    \n                    \n                    \n                    \n                    \n                     3 push(/private/agenda, icm:acc*pos)\n                    \n               eff: \n                    \n                       4 if do(Score ≤ 0.9 and A 6= yes and A 6= no,\n                            push(/private/agenda, icm:und*pos:usr*P ))\n                    \n                    \n                    \n                    \n                    \n                        5 add(/shared/com, P )\n                    \n\n\nConditions 1-4 are similar to those for the integrateUsrAsk rule. The relevance of the\ncontent of the answer to a question on QUD is checked in condition 6.\n\nThe acceptability condition in the condition 8 makes sure that the propositional content\nresulting from combining the question topmost on QUD with the content of the answer-\nmove is either\n\n\n   • a valid database parameter, or\n   • a negated proposition\n",
      "context_before": "Integration of user answer move The integration rule for user answer moves, shown in\n(rule 3.4) is similar to that for ask moves, except that answers are checked for relevance\nas well as reliability and acceptability.\n\n",
      "context_after": ""
    },
    {
      "title": "Rule 3.5: selectIcmUndIntAnswer",
      "section": "Unknown",
      "page": 136,
      "category": "Selection Rules",
      "rule_id": "3.5",
      "content": " (rule 3.5)    rule: selectIcmUndIntAnswer\n               class: select icm\n                    \n                       fst($/private/nim, answer(A))\n                        $/shared/lu/speaker==usr\n                    \n                    \n                    \n                    \n                    \n                     $score ≤ 0.7\n                    \n               pre: \n                    \n                       fst($/shared/QUD, B)\n                        $domain :: relevant(A, B)\n                    \n                    \n                    \n                    \n                    \n                        $domain :: combine(B, A, C)\n                    \n                    (\n                       pop(/private/nim)\n               eff:\n                       push(next moves, icm:und*int:usr*C)\n\n\nThe conditions check that there is a user answer move on nim whose content is relevant\nto and combines with a question on QUD, and that the recognition score was less than or\nequal to 0.7. If these conditions are true, the move is popped off nim and interrogative\nunderstanding feedback is selected.\n\n",
      "context_before": "acceptable to the system, interrogative understanding feedback is selected by (rule 3.5).\n(If the question is not acceptable it will instead be rejected; see Section 3.6.6).\n\n\n",
      "context_after": "\nIntegrating and responding to interrogative feedback\n\n\nIntegrating interrogative understanding feedback As explained in Section 3.6.3,"
    },
    {
      "title": "Rule 3.6: integrateUndIntICM",
      "section": "Unknown",
      "page": 137,
      "category": "Update Rules",
      "rule_id": "3.6",
      "content": " (rule 3.6)    rule: integrateUndIntICM\n               class:n integrate\n               pre: fst($/private/nim, icm:und*int:DP *C)\n                    \n                     pop(/private/nim)\n                    \n               eff:  add(/shared/lu/moves, icm:und*int:DP *C)\n                    \n                        push(/shared/QUD, und(DP *C))\n\nThe condition simply checks that there is an icm:und*int:DP *C move on nim, which is\nthen popped off by the first update and added to /shared/lu/moves by the second\nupdate. The third update pushes the understanding question ?und(DP *C) on QUD.\n\n\nIntegrating positive answer to understanding-question When the system raises\nan understanding question (e.g. by saying “To Paris, is that correct?”), the user can either\nsay “yes” or “no”. (The case where the user does not give a relevant answer to the inter-\nrogative feedback is treated in Section 3.6.8). In IBiS2, we do not represent propositions\nrelated to the understanding of utterances in the same way as other propositions (which\nare stored in /shared/com). Therefore, special rules are needed for dealing with answers\nto understanding-questions.\n\nThe rule for integrating a negative answer to an understanding-question is shown in (rule\n3.7).\n\n",
      "context_before": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS                                         115\n\n",
      "context_after": " (rule 3.7)    rule: integrateNegIcmAnswer\n               class:( integrate\n                        fst($/private/nim, answer(no))\n               pre:\n                        fst($/shared/qud, und(DP *C))"
    },
    {
      "title": "Rule 3.7: integrateNegIcmAnswer",
      "section": "Unknown",
      "page": 137,
      "category": "Update Rules",
      "rule_id": "3.7",
      "content": " (rule 3.7)    rule: integrateNegIcmAnswer\n               class:( integrate\n                        fst($/private/nim, answer(no))\n               pre:\n                        fst($/shared/QUD, und(DP *C))\n                        pop(/private/nim)\n                    \n                    \n                    \n                     add(/shared/lu/moves, answer(und(DP *C)))\n                    \n               eff: \n                    \n                       pop(/shared/QUD)\n                        push(/private/agenda, icm:und*pos:DP *not(C))\n                    \n\n",
      "context_before": "\nThe rule for integrating a negative answer to an understanding-question is shown in (rule\n3.7).\n\n",
      "context_after": "\nThe conditions check that there’s an answer(yes) move on nim and an understanding-\nquestion on QUD. The first three updates establish the move as shared and pop the\nunderstanding-question off QUD. Finally, positive feedback is selected to indicate that\nthe system has understood that the assumed interpretation C was incorrect."
    },
    {
      "title": "Rule 3.8: integratePosIcmAnswer",
      "section": "Unknown",
      "page": 138,
      "category": "Update Rules",
      "rule_id": "3.8",
      "content": " (rule 3.8)     rule: integratePosIcmAnswer\n                class:( integrate\n                         fst($/private/nim, answer(yes))\n                pre:\n                     \n                         fst($/shared/QUD,  und(DP *Content))\n                     \n                     \n                        pop(/private/nim)\n                         add(/shared/lu/moves, answer(und(DP *Content)))\n                     \n                     \n                     \n                     \n                     \n                      pop(/shared/QUD)\n                     \n                     \n                     \n                eff:  if then else(Content=issue(Q), [\n                     \n                     \n                     \n                           push(/shared/QUD, Q)\n                            push(/private/agenda, respond(Q)) ],\n                     \n                     \n                     \n                     \n                     \n                      add(/shared/com, Content))\n                     \n\n",
      "context_before": "116                                                    CHAPTER 3. GROUNDING ISSUES\n\n",
      "context_after": "\nThe conditions and the first three updates are similar to those in the integrateNegIc-\nmAnswer rule. The final (conditionalized) update integrates the content C. If the “orig-\ninal” move (the move which caused the interrogative feedback to be produced in the first\nplace) was ask, C will be a proposition issue(Q). Consequently, integrating this propo-"
    },
    {
      "title": "Rule 3.9: selectIcmConNeg",
      "section": "Unknown",
      "page": 142,
      "category": "Selection Rules",
      "rule_id": "3.9",
      "content": " (rule 3.9)    rule: selectIcmConNeg\n               class: select icm\n                     $input= ‘TIMED OUT’\n                    \n               pre:  is empty($next moves)\n                    \n                    n\n                        is empty($/private/agenda)\n               eff: push(next moves, icm:con*neg)\n\n\nUnless the system has something else to do, this will trigger negative contact ICM by the\nsystem, realised e.g. as “I didn’t hear anything from you.”. The purpose of this is primarily\nto indicate to the user that nothing was heard, but perhaps also to elicit some response\nfrom the user to show that she is still there. Admittedly, this is a rather undeveloped\naspect of ICM in the current IBiS implementation, and alternative strategies could be\nexplored. For example, the system could increase the timeout span successively instead of\nrepeating negative contact ICM every five seconds. Other formulations with more focus on\nthe eliciting function could also be considered, e.g. “Are you there?” or simply “Hello?”.\n\nThe second and third condition check that nothing is on the agenda or in next moves.\nThe motivation for this is that there is no reason to address contact explicitly in this case,\nsince any utterance from the system implicitly tries to establish contact.\n\n\nDefault ICM integration rule Since contact is not explicitly represented in the infor-\nmation state proper, integration of negative system contact ICM moves have no specific\neffect on the information state, and are therefore integrated by the default ICM integration\nrule shown in (rule 3.10). Unless an ICM move has a specific integration rule defined for\nit, it will be integrated by this rule.\n",
      "context_before": "within a certain time frame (specified by the timeout TIS variable), the input variable\nwill be set to ‘TIMED OUT’ by the input module. The rule for selection of negative contact\nfeedback is shown in (rule 3.9).\n\n",
      "context_after": ""
    },
    {
      "title": "Rule 3.10: integrateOtherICM",
      "section": "Unknown",
      "page": 143,
      "category": "Update Rules",
      "rule_id": "3.10",
      "content": "(rule 3.10) rule: integrateOtherICM\n            class:n integrate\n            pre: fst($/private/nim, icm:A)\n                 (\n                     pop(/private/nim)\n            eff:\n                     add(/shared/lu/moves, icm:A)\n\n\nThe condition and updates in this rule are straightforward.\n\n",
      "context_before": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS                                        121\n\n",
      "context_after": "\nNegative system perception feedback If the speech recognizer gets some input from\nthe user but is not able to reliably figure out what was said (the recognition score may be\ntoo low), the input variable gets set to ‘FAIL’. This will trigger negative perception ICM,\ne.g. “I didn’t hear what you said”."
    },
    {
      "title": "Rule 3.11: selectIcmPerNeg",
      "section": "Unknown",
      "page": 143,
      "category": "Selection Rules",
      "rule_id": "3.11",
      "content": "(rule 3.11) rule: selectIcmPerNeg\n            class:( select icm\n                     $input=’FAIL’\n            pre:\n                     not in($next moves, icm:per*neg)\n                 n\n            eff: push(next moves, icm:per*neg)\n\n\nThe purpose of the second condition is to prevent selecting negative perception feedback\nmore than once in the selection phase. As with negative system contact feedback, negative\nsystem perception feedback is integrated by the integrateOtherICM rule.\n\n",
      "context_before": "the user but is not able to reliably figure out what was said (the recognition score may be\ntoo low), the input variable gets set to ‘FAIL’. This will trigger negative perception ICM,\ne.g. “I didn’t hear what you said”.\n\n",
      "context_after": "\nNegative understanding level feedback\n\n\nNegative feedback can concern either of the two sublevels of the understanding level: se-"
    },
    {
      "title": "Rule 3.12: selectIcmSemNeg",
      "section": "Unknown",
      "page": 144,
      "category": "Selection Rules",
      "rule_id": "3.12",
      "content": "(rule 3.12) rule: selectIcmSemNeg\n            class: select icm\n                  $latest moves=failed\n                 \n            pre:  $input=String\n                 \n                 (\n                     not in($next moves, icm:sem*neg)\n                    push(next moves, icm:per*pos:String)\n            eff:\n                    push(next moves, icm:sem*neg)\n\n\nThe purpose of the third condition is to prevent negative semantic understanding feedback\nfrom being selected more than one time. Since only one string is recognized per turn,\nthere is never any reason to apply the rule more than once; and if anything at all can be\ninterpreted, the rule will not trigger at all even if some material was not used in interpreta-\ntion. In a system with a wide-coverage recognizer and a more sophisticated interpretation\nmodule, one may consider producing negative semantic understanding feedback for any\nmaterial which cannot be interpreted (e.g. “I understand that you want to go to Paris,\nbut I don’t understand what you mean by ‘Londres’.”).\n\nThe first update in this rule selects positive perception ICM to show the user what the\nsystem heard. The second update selects negative semantic understanding ICM.\n\n",
      "context_before": "This will only occur if the recognition lexicon covers sentences not covered by the inter-\npretation lexicon.\n\n\n",
      "context_after": "\nNegative system pragmatic understanding feedback The system will try to inte-\ngrate the moves according to the rules above in Section 3.6.7. If this fails (if there are still\nmoves which have not been integrated), the rule in (rule 3.13) will be triggered and a\nicm:und*neg-move will be selected by the system. However, if the reason that the move was"
    },
    {
      "title": "Rule 3.13: selectIcmUndNeg",
      "section": "Unknown",
      "page": 145,
      "category": "Selection Rules",
      "rule_id": "3.13",
      "content": "(rule 3.13) rule: selectIcmUndNeg\n                  select icm\n            class:\n                 \n                   not in($next moves, icm:und*neg)\n                    in($latest moves, answer(A))\n                 \n                 \n                 \n                 \n                 \n                  forall($latest moves/elem=M ove,\n                 \n            pre: \n                      $/private/nim/elem=M ove)\n                    forall($latest moves/elem=answer(A0 ),\n                 \n                 \n                 \n                 \n                 \n                       not fst($/shared/QUD, D) and $domain :: relevant(A0, Q))\n                 \n                 \n                 \n                  forall do($latest moves/elem=M ove,\n                 \n            eff:      push(next moves, icm:sem*pos:M ove))\n                 \n                    push(next moves, icm:und*neg)\n\nThe first rule checks that negative pragmatic understanding feedback has not already been\nselected. The second condition checks that the latest utterance contained an answer move,\nand the third checks that none of the moves performed in the latest utterance has been\nintegrated; all moves in latest moves are still on nim. Finally, the fourth condition\nchecks that no answer is relevant to any question on QUD.\n\nThe first update selects positive feedback on the semantic understanding level for each move\nperformed in the latest utterance, to show that the utterance was at least understood to\nsome extent. The second update selects negative feedback and pushes it on next moves.\n\nThe system is thus able to make a distinction between utterances it cannot interpret (and\nthus not ground), and utterances that it can interpret and ground but not integrate. The\nrule in (3.15) triggers when integration fails because the system cannot see the relevance\nof the user utterance in the current dialogue context. Negative pragmatic understanding\nfeedback is currently realized as “I don’t quite understand”; the idea is to indicate that\nthe utterance was almost fully understood, but not quite. Again, it can be argued what\nthe best realization is.\n\n",
      "context_before": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS                                         123\n\n",
      "context_after": "\nDialogue example: negative system contact, perception, and understanding\nfeedback In this dialogue, we see examples of negative system feedback on the contact,\nperception, and understanding (both semantic and pragmatic) levels. (Since this dialogue\nuses the text-based input module, we have simulated timeout and recognition failure.)"
    },
    {
      "title": "Rule 3.14: rejectProp",
      "section": "Unknown",
      "page": 149,
      "category": "Other Algorithms",
      "rule_id": "3.14",
      "content": "(rule 3.14) rule: rejectProp\n            class: select action\n                 \n                    in($/private/nim, answer(A))\n                     $/shared/lu/speaker=usr\n                 \n                 \n                 \n                 \n                 \n                  fst($/shared/QUD, Q)\n                 \n            pre: \n                 \n                    $domain :: relevant(A, Q)\n                     $domain :: combine(Q, A, P )\n                 \n                 \n                 \n                 \n                 \n                     not $database :: validDBparameter(P )\n                 \n                 \n                  del(/private/nim, answer(A))\n                 \n            eff:  push(/private/agenda, icm:und*pos:usr*P )\n                 \n                     push(/private/agenda, icm:acc*neg:P )\n\nThe first five conditions are identical to those for the rule for integrating user answers,\nintegrateUsrAnswer (Section 3.6.6). The final condition checks that the proposition P,\nresulting from combining a question on QUD with the content of the answer move, is not\na valid database parameter. The updates remove the move from nim and selects positive\nunderstanding feedback to show what the system understood, and negative acceptance\nfeedback.\n\nOf course, it is not optimally efficient that the same sequence of conditions is checked by\nseveral different rules; an alternative approach would be to let one rule determine e.g. how\nan answer move is relevant, combine it with a question on QUD, and store the result in\na datastructure containing pragmatically interpreted material. This datastructure could\nthen be inspected by both integration and rejection rules. (See also Section 6.5.1.)\n\n",
      "context_before": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS                                         127\n\n",
      "context_after": "\nDialogue example: system proposition rejection In the following dialogue, we il-\nlustrate system rejection of the proposition that the means of transport to search for will\nbe train. A motivation is also given by the system, i.e. that “train” is not available as a\nmeans of transport in the database."
    },
    {
      "title": "Rule 3.15: rejectIssue",
      "section": "Unknown",
      "page": 151,
      "category": "Other Algorithms",
      "rule_id": "3.15",
      "content": "(rule 3.15) rule: rejectIssue\n            class: select action\n                  in($/private/nim, ask(Q))\n                 \n            pre:  $/shared/lu/speaker=usr\n                 \n                     not $domain :: plan(Q, P lan)\n                 \n                  del(/private/nim, ask(Q))\n                 \n            eff:  push(/private/agenda, icm:und*pos:usr*issue(Q))\n                 \n                     push(/private/agenda, icm:acc*neg:issue(Q))\n\nThe rule is similar to the rejectProp rule. The third condition checks that there is no\nplan for dealing with the question Q.\n\n\nDialogue example: system issue rejection In the following dialogue, the user’s re-\nquest for information about connecting flights is rejected on the grounds that the system\ndoes not know how to address that issue.\n\n\n(dialogue 3.9)\n\nS> Okay.       The price is      123    crowns.\n\nU> what about connecting flights\n\ngetLatestMoves\nbackupShared\nrejectIssue\n\n del(/private/nim, ask(?A.con flight(A)))\n   push(/private/agenda, )\n   push(/private/agenda, icm:acc*neg:issue(?A.con flight(A)))\n\nselectIcmOther\n½\n   push(next moves, icm:und*pos:usr*issue(?A.con flight(A)))\n   del(/private/agenda, icm:und*pos:usr*issue(?A.con flight(A)))\nselectIcmOther\n½\n   push(next moves, icm:acc*neg:issue(?A.con flight(A)))\n   del(/private/agenda, icm:acc*neg:issue(?A.con flight(A)))\n\nS> You asked about connecting flights.                Sorry, I cannot answer questions\n",
      "context_before": "to the user using appropriate feedback. This rule allows the system to respond intelligently\nto user questions even if it cannot answer them (given that they can be recognized and\ninterpreted).\n\n",
      "context_after": ""
    },
    {
      "title": "Rule 3.16: getLatestMoves",
      "section": "Unknown",
      "page": 152,
      "category": "Other Algorithms",
      "rule_id": "3.16",
      "content": "(rule 3.16) rule: getLatestMoves\n            class: grounding\n                  $latest moves=M oves\n                 \n            pre:  $latest speaker=DP\n                 \n                     $/shared/lu/moves=P revM oves\n                    set(/private/nim, M oves)\n                 \n                 \n                 \n                  set(/shared/lu/speaker, DP )\n                 \n            eff: \n                 \n                   clear(/shared/lu/moves)\n                    set(/shared/pm, P revM oves)\n                 \n\n",
      "context_before": "\nMoving latest moves to nim The IBiS2 version of the update rule getLatestMoves\nis shown in (rule 3.16).\n\n",
      "context_after": "\nThe rule loads information regarding the latest utterance performed into nim and copies\nthe previously grounded moves (in /shared/lu/moves) to the /shared/pm field. Note\nthat this rule has changed significantly compared to IBiS1; no optimistic assumption\nabout understanding of the latest utterance is made here. Instead of putting the latest"
    },
    {
      "title": "Rule 3.17: backupShared",
      "section": "Unknown",
      "page": 153,
      "category": "Other Algorithms",
      "rule_id": "3.17",
      "content": "(rule 3.17) rule: backupShared\n            class: none\n            pre: \n                 {\n                 \n                  /private/tmp/QUD := $/shared/QUD\n                  /private/tmp/com := $/shared/com\n                 \n            eff:\n                 \n                 \n                  /private/tmp/agenda := $/private/agenda\n                   /private/tmp/plan := $/private/plan\n                 \n\n",
      "context_before": "optimistic.\n\n\n\n",
      "context_after": "\nThere are no conditions on this rule. It is executed at the start of the selection algorithm\ndescribed in Section 3.7, and is thus only called before system utterances.\n\n"
    },
    {
      "title": "Rule 3.18: integrateSysAsk",
      "section": "Unknown",
      "page": 154,
      "category": "Update Rules",
      "rule_id": "3.18",
      "content": "(rule 3.18) rule: integrateSysAsk\n            class:( integrate\n                     $/shared/lu/speaker==sys\n            pre:\n                     fst($/private/nim, ask(A))\n                 \n                  pop(/private/nim)\n                 \n            eff:     add(/shared/lu/moves, ask(A))\n                     push(/shared/QUD, A)\n                 \n                 \n\n",
      "context_before": "132                                                 CHAPTER 3. GROUNDING ISSUES\n\n",
      "context_after": "(rule 3.19) rule: integrateSysAnswer\n            class: integrate\n                 \n                 \n                 "
    },
    {
      "title": "Rule 3.19: integrateSysAnswer",
      "section": "Unknown",
      "page": 154,
      "category": "Update Rules",
      "rule_id": "3.19",
      "content": "(rule 3.19) rule: integrateSysAnswer\n            class: integrate\n                 \n                 \n                 \n                     fst($/private/nim, answer(A))\n                  $/shared/lu/speaker==sys\n                 \n                 \n                 \n            pre:  $domain :: proposition(A)\n                 \n                 \n                 \n                    fst($/shared/QUD, B)\n                  $domain :: relevant(A, B)\n                 \n                 \n                  pop(/private/nim)\n                 \n            eff:  add(/shared/lu/moves, answer(A))\n                 \n                     add(/shared/com, A)\n\nOne complication is that in IBiS2, several moves may be performed in a single utter-\nance. To keep track of which utterances have been integrated, the /private/nim stack\nof non-integrated moves is popped for each move that gets integrated. Note also that\neach integrated (and thus understood) move is added to /shared/lu/moves (whereas in\nIBiS1 this was done at the start of the update cycle).\n\nThe cautiously optimistic acceptance assumptions built into these rules can be retracted\non integration of negative user perception feedback, as explained in Section 3.6.6, or on\nnegative user integration feedback, as show in Section 3.6.7. Dialogue examples involving\nthe rules shown above will be given in these sections.\n\n\nUser feedback to system utterances\n\n\nIn this section we review user feedback to system utterances and how these affect the\noptimistic grounding assumptions.\n\n\nNegative user perception feedback If the system makes an utterance, it will assume\nit is grounded and accepted. If the user indicates that she did not understand the utterance,\nthe rule in (rule 3.20) makes it possible to retract the effects of the system’s latest move,\nthus cancelling the assumptions of grounding and acceptance.\n",
      "context_before": "                     push(/shared/qud, A)\n                 \n                 \n\n",
      "context_after": ""
    },
    {
      "title": "Rule 3.20: integrateUsrPerNegICM",
      "section": "Unknown",
      "page": 155,
      "category": "Update Rules",
      "rule_id": "3.20",
      "content": "(rule 3.20) rule: integrateUsrPerNegICM\n            class:( integrate\n                     $/shared/lu/speaker==usr\n            pre:\n                     fst($/private/nim, icm:per*neg)\n                 \n                 \n                 \n                 \n                     pop(/private/nim)\n                  /shared/QUD := $/private/tmp/QUD\n                 \n                 \n                 \n            eff:     /shared/com := $/private/tmp/com\n                     /private/agenda := $/private/tmp/agenda\n                 \n                 \n                 \n                 \n                 \n                  /private/plan := $/private/tmp/plan\n                 \n\n",
      "context_before": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS                                      133\n\n",
      "context_after": "\n\nThe four last updates revert the com, qud, plan and agenda fields to the values stored\nin /private/tmp.\n"
    },
    {
      "title": "Rule 3.21: integrateUsrAccNegICM",
      "section": "Unknown",
      "page": 157,
      "category": "Update Rules",
      "rule_id": "3.21",
      "content": "(rule 3.21) rule: integrateUsrAccNegICM\n            class: integrate\n                  $/shared/lu/speaker==usr\n                 \n            pre:     fst($/private/nim, icm:acc*neg:issue)\n                     in($/shared/pm, ask(Q))\n                 \n                 \n\n                     pop(/private/nim)\n                 \n                 \n                 \n                  add(/shared/lu/moves, icm:acc*neg:issue)\n                 \n            eff: \n                 \n                    /shared/QUD := $/private/tmp/QUD\n                     /shared/com := $/private/tmp/com\n                 \n",
      "context_before": "this is done, the optimistic grounding update is retracted by restoring the shared parts\nstored in nim, i.e. qud and com, to their previous states.\n\n\n",
      "context_after": ""
    },
    {
      "title": "Rule 3.22: irrelevantFollowup",
      "section": "Unknown",
      "page": 163,
      "category": "Semantic Operations",
      "rule_id": "3.22",
      "content": "(rule 3.22) rule: irrelevantFollowup\n            class:\n                  none\n                 \n                 \n                 \n                    1 $/private/nim=M oves\n                 \n                 \n                 \n                   2 $/shared/lu/speaker==usr\n                    3 not A/elem=icm:\n                 \n                 \n                 \n                 \n                 \n                  4 in($/shared/pm, P revM ove)\n                 \n            pre:\n                 \n                 \n                   5 P revM ove=ask(Q) or\n                       ( P revM ove=icm:und*int:DP *C and Q=und(DP *C) )\n                 \n                 \n                 \n                 \n                    6 not M oves/elem=ask(Q0 ) and $domain :: depends(Q, Q0 )\n                 \n                 \n                 \n                 \n                 \n                 \n                 \n                 (\n                    7 not A/elem=answer(A) and $domain :: relevant(A, Q)\n                    /shared/QUD := $/private/tmp/QUD\n            eff:\n                    /shared/com := $/private/tmp/com\n\n\n(Since this rule is called “by name” from the update algorithm, there is no need for including\nit in a rule class.) Condition 3 checks that no ICM was included in the latest move.\nCondition 4 and 5 tries to find a question Q raised by the previous move, possibly an\nunderstanding-question. Note here that we do not check QUD; in IBiS2, questions remain\non QUD only for one turn but it may be the case that we want questions to remain on\nQUD over several turns. What we are interested here is thus not which questions are on\nQUD but which questions were raised by the previous utterance, and this is the reason\nfor looking in pm rather than QUD. Conditions 6 and 7 check that no move performed in\nthe latest utterance is relevant to Q, neither by answering it nor by asking a question on\nwhich Q depends. The updates are similar to those for integration of negative acceptance\nfeedback (Section 3.6.7).\n",
      "context_before": "assumed to be mistaken. Therefore, the optimistic assumption is retracted by reverting\nthe previous shared state for the relevant parts of shared.\n\n\n",
      "context_after": ""
    },
    {
      "title": "Rule 3.23: findPlan",
      "section": "Unknown",
      "page": 165,
      "category": "Other Algorithms",
      "rule_id": "3.23",
      "content": "(rule 3.23) rule: findPlan\n                  load plan\n            class:\n                  in($/private/agenda, respond(Q))\n                 \n            pre:  $domain :: plan(Q, P lan)\n                 \n                    not in($/private/bel, P ) and $domain :: resolves(P, Q)\n                 \n                  del(/private/agenda, respond(Q))\n                 \n            eff:  set(/private/plan, P lan)\n                 \n                    push(/private/agenda, icm:loadplan))\n\nThis rule is identical to that in IBiS1 (Section 2.8.6), expect for the final update which\npushes the icm:loadplan move on the agenda.\n\n\nReraising issues\n\n\nSystem reraising of issue associated with plan If the user raises a question Q and\nthen raises Q0 before Q has been resolved, the system should return to dealing with Q once\nQ0 is resolved; this was described in Section 3.6.9. The recoverPlan rule in IBiS2, shown\nin (3.20), is almost identical to the one in IBiS1, except that ICM is produced to indicate\nthat an issue (q1) is being reraised. This ICM is formalized as icm:reraise:q where q is the\nquestion being reraised, and expressed e.g. as “Returning to the issue of price”.\n\n",
      "context_before": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS                                         143\n\n",
      "context_after": "(rule 3.24) rule: recoverPlan\n            class:\n                  load plan\n                 \n                 "
    },
    {
      "title": "Rule 3.24: recoverPlan",
      "section": "Unknown",
      "page": 165,
      "category": "Other Algorithms",
      "rule_id": "3.24",
      "content": "(rule 3.24) rule: recoverPlan\n            class:\n                  load plan\n                 \n                 \n                 \n                    in($/shared/QUD, Q)\n                  is empty($/private/agenda)\n                 \n                 \n                 \n            pre:  is empty($/private/plan)\n                 \n                 \n                 \n                   $domain :: plan(Q, P lan)\n                  not in($/private/bel, P ) and $domain :: resolves(P, Q)\n                 \n                 \n                  set(/private/plan, P lan)\n                 \n            eff:  push(/private/agenda, icm:reraise:Q)\n                 \n                    push(/private/agenda, icm:loadplan))\n\n\nIssue reraising by user In the case where the user reraises an open issue, an icm:reraise:Q\nmove is selected by the integrateUsrAsk described in Section 3.6.6.\n\n\nSystem reraising of issue not associated with plan The IBiS1 reraiseIssue rule\ndescribed in Section 2.12.3 reraises any questions on QUD which are not associated with\n",
      "context_before": "in (3.20), is almost identical to the one in IBiS1, except that ICM is produced to indicate\nthat an issue (q1) is being reraised. This ICM is formalized as icm:reraise:q where q is the\nquestion being reraised, and expressed e.g. as “Returning to the issue of price”.\n\n",
      "context_after": ""
    },
    {
      "title": "Rule 3.25: reraiseIssue",
      "section": "Unknown",
      "page": 166,
      "category": "Other Algorithms",
      "rule_id": "3.25",
      "content": "(rule 3.25) rule: reraiseIssue\n            class:( select action\n                     fst($/shared/issues, Q)\n            pre:\n                     not $domain :: plan(Q, P )\n                 (\n                    push(/private/agenda, icm:reraise)\n            eff:\n                    push(/private/agenda, raise(Q))\n\nThe conditions of this rule checks that there is a question Q on issues for which the system\nhas no plan, i.e. one that the system needs to ask the user.\n\nThe first update adds an icm:reraise (without an argument) to signal that it is reraising\na question; this is currently generated as prefixing “so” to the next ask move, which is\nan ordinary raising of the question (placed on the agenda by the second update in the\nrule). In a more sophisticated implementation one could consider abbreviating the original\nraising of the question to make an appropriate reraising, e.g. “So, from what city?” But\nwe do not have a general method for doing that yet, even in these simple dialogues. To\ndo it properly would probably require more detailed syntactic and semantic analysis of\ncontributions than we currently have in IBiS.\n\n\nDialogue example: user and system reraising (dialogue 3.12) is an example of a\ndialogue where the user reraises an issue which was previously raised but not resolved.\n\nAlso subsequently the system reraises an issue which is relevant for addressing the issue\nthat the user reraised. In order to address the issue of price the system needs to get\ninformation from the user concerning where she wishes to travel from.\n\n\n(dialogue 3.12)\n\nS> Welcome to the travel agency!\nU> price information please\nS> Okay. Lets see. How do you want to travel?\nU> a flight\nS> Okay. What city do you want to go to?\nU> paris\nS> Okay. What city do you want to go from?\n",
      "context_before": "helpful to indicate that the system is aware that the issue is being reraised. However, since\nthe issue will be reraised, the sequencing ICM does not need to indicate which question is\nbeing reraised.\n\n",
      "context_after": ""
    },
    {
      "title": "Rule 3.26: selectRespond",
      "section": "Unknown",
      "page": 169,
      "category": "Selection Rules",
      "rule_id": "3.26",
      "content": "(rule 3.26) rule: selectRespond\n            class: select action\n                 \n                    is empty($/private/plan)\n                     fst($/shared/QUD, A)\n                 \n                 \n                 \n                 \n                 \n                  in($/private/bel, B)\n                 \n            pre: \n                 \n                    not in($/shared/com, B)\n                     $domain :: resolves(B, A)\n                 \n                 \n                 \n                 \n                 \n                     not  in($/private/agenda, respond(A))\n                 \n                 n\n            eff: push(/private/agenda, respond(A))\n\n\nSimilarly, the move selection rules in IBiS2 are repeatedly applied, popping actions off the\nagenda queue and pushing the corresponding moves on next moves. As an example,\nthe selectAnswer rule is shown in (rule 3.27).\n\n",
      "context_before": "3.7. FURTHER IMPLEMENTATION ISSUES                                                      147\n\n",
      "context_after": "(rule 3.27) rule: selectAnswer\n            class: select move\n                 \n                    fst($/private/agenda, respond(A))\n                  in($/private/bel, B)"
    },
    {
      "title": "Rule 3.27: selectAnswer",
      "section": "Unknown",
      "page": 169,
      "category": "Selection Rules",
      "rule_id": "3.27",
      "content": "(rule 3.27) rule: selectAnswer\n            class: select move\n                 \n                    fst($/private/agenda, respond(A))\n                  in($/private/bel, B)\n                 \n            pre: \n                 \n                    not in($/shared/com, B)\n                     $domain   :: resolves(B, A)\n                 \n                 (\n                    push(next moves, answer(B))\n            eff:\n                    pop(/private/agenda)\n\n\nThe selection algorithm for IBiS2 is shown in (3.21).\n\n\n     (3.21) h backupShared,\n              if not in($/private/agenda, A) and q raising action(A)\n              then try select action,\n              repeat ( select icm orelse select move ) i\n\nThe select action rule class selects actions and places them on the agenda, whereas\nthe select move and select icm rule classes selects agenda items and places them on\nnext moves. Before selection, the backupShared (Section 3.6.7) is applied to copy\nrelevant parts of the information state to /private/nim.\n\nThe basic strategy for selection in IBiS is that only one question should be raised by the\nsystem in each utterance. The IBiS2 selection algorithm first checks if some question-\nraising action is already on the agenda; if not, it tries to select a new action. Then, it\nselects moves and ICM repeatedly until nothing more can be selected.\n",
      "context_before": "Similarly, the move selection rules in IBiS2 are repeatedly applied, popping actions off the\nagenda queue and pushing the corresponding moves on next moves. As an example,\nthe selectAnswer rule is shown in (rule 3.27).\n\n",
      "context_after": ""
    },
    {
      "title": "Rule 4.1: accommodatePlan2Issues",
      "section": "Unknown",
      "page": 188,
      "category": "Other Algorithms",
      "rule_id": "4.1",
      "content": " (rule 4.1)      rule: accommodatePlan2Issues\n                 class: accommodate\n                      \n                      \n                      \n                          $/private/nim/elem/snd = answer(A)\n                      \n                      \n                      \n                         not $lexicon :: yn answer(A)\n                          in($/private/plan,   findout(Q))\n                      \n                      \n                      \n                      \n                      \n                       $domain :: relevant(A, Q)\n                      \n                 pre: \n                         $domain :: default question(Q) or\n                             not ( in($/private/plan, findout(Q0 ))\n                      \n                      \n                      \n                      \n                      \n                      \n                                    and Q 6= C\n                      \n                      \n                      \n                      \n                                    and $domain :: relevant(A, Q0 ) )\n                      \n                      \n                      n\n                 eff: push(/shared/issues, B)\n\nThe first condition picks out a non-integrated answer move with content A. The second\ncondition checks that A is not a y/n answer (e.g. yes, no, maybe etc.), and thus im-\nplements an assumption that such answers cannot trigger question accommodation, since\nthey are too ambiguous6. The third and fourth conditions check if there is a findout action\nwith content Q in the currently loaded plan, such that A is relevant to Q. The final con-\ndition checks that there is no other question in the plan that the answer is relevant to, or\nalternatively that Q has the status of a default question. If this condition does not hold, a\nclarification question should be raised by the system; this is described in Section 4.6.3. The\n“default question” option allows encoding of the fact that one issue may be significantly\nmore salient in a certain domain. For example, in a travel agency setting the destination\ncity may be regarded as more salient than the departure city question. If this is encoded\nas a default question, then if the user says simply “Paris” it is interpreted as answering\nthe destination city question; no clarification is triggered7\n\n",
      "context_before": "166                                         CHAPTER 4. ADDRESSING UNRAISED ISSUES\n\n",
      "context_after": "\nExample dialogue: issue accommodation The dialogue in (dialogue 4.1) illus-\ntrates accommodation of the question ?C.class(C) from the plan to the stack of open\nissues.\n"
    },
    {
      "title": "Rule 4.2: accommodateIssues2QUD",
      "section": "Unknown",
      "page": 191,
      "category": "Other Algorithms",
      "rule_id": "4.2",
      "content": " (rule 4.2)    rule: accommodateIssues2QUD\n               class: accommodate\n                    \n                       $/private/nim/elem=usr-answer(A)\n                        $domain :: short answer(A)\n                    \n                    \n                    \n                    \n                    \n                     not $lexicon :: yn answer(A)\n                    \n               pre: \n                    \n                       in($/shared/issues, Q)\n                        not in($/shared/QUD, Q)\n                    \n                    \n                    \n                    \n                    \n                        $domain   :: relevant(A, Q)\n                    \n                    (\n                       push(/shared/QUD, Q)\n               eff:\n                       raise(/shared/issues, Q)\n\n\nThe second condition in (rule 4.2) checks that the content of the answer move picked out\nby condition 1 is semantically underspecified. The third condition imposes a constraint\non local question accommodation, excluding short answers to y/n-questions (“yes”, “no”,\n“maybe” etc.). The remaining conditions check that the answer-content is relevant to an\nissue which is on issues but not on QUD. The first operation pushes the accommodated\nquestion on QUD, and the final update raises the question to the top of the stack of open\nissues.\n\n",
      "context_before": "\nsingle utterance; for example, if an issue that is in the plan but has not yet been raised is\nanswered elliptically.\n\n",
      "context_after": "\n4.6.3    Issue clarification\n\nIn IBiS2, user answers are either pragmatically relevant to the question topmost on QUD,\nor not relevant at all. When we add mechanisms of accommodation to allow for answers"
    },
    {
      "title": "Rule 4.3: clarifyIssue",
      "section": "Unknown",
      "page": 192,
      "category": "Other Algorithms",
      "rule_id": "4.3",
      "content": " (rule 4.3)      rule: clarifyIssue\n                 class: select action\n                      \n                         in($/private/nim, usr-answer(A))\n                       setof(C, in($/private/plan, findout(Q)) and\n                      \n                 pre:\n                      \n                      \n                            $domain :: relevant(A, Q), QSet)\n                          $$arity(QSet) > 1\n                      \n                      \n                       ! setof(?P, in(QSet, Q) and $domain :: combine(Q, A, P ), AltQ)\n                      \n                 eff:  push(/private/agenda, findout(AltQ))\n                      \n                         del(/private/nim, usr-answer(A))\n\nThe first condition picks out the answer-move from the nim queue. The second and third\nconditions check that there is more than one question in the plan to which the answer\nis relevant, by constructing the set of such questions. The first operation constructs the\nalternative-question by applying each question in the set constructed in condition 2 to the\nanswer to get a proposition and prefixing the question operator ’ ?’ to each proposition\nto get a y/n-question. The alternative question is this set of y/n-questions. The second\noperation pushes the action to raise the alternative question on the agenda, and the final\noperation removes the answer move from nim; this is motivated above.\n\nA sample dialogue with issue clarification is shown in (dialogue 4.2).\n\n\n(dialogue 4.2)\n\nS> Welcome to the travel agency!\nU> price information please\nS> Okay. I need some information. How do you want to travel?\nU> flight um paris\nS> OK, by flight. Do you mean from paris or to paris?\n   8\n    IBiS3 only handles full answers to clarification questions, i.e. “To Paris.” or “From Paris.”. A slightly\nmore advanced semantics would be required to handle cases where the user again gives an underspecified\nresponse which resolves the question, i.e. “To.” or “From.”.\n",
      "context_before": "grounding on the understanding level put forward in Chapter 3. The rule which selects\nthe issue clarification issue is shown in (rule 4.3).\n\n\n",
      "context_after": ""
    },
    {
      "title": "Rule 4.4: accommodateDependentIssue",
      "section": "Unknown",
      "page": 194,
      "category": "Other Algorithms",
      "rule_id": "4.4",
      "content": " (rule 4.4)    rule: accommodateDependentIssue\n               class:\n                     accommodate\n                    \n                    \n                    \n                       setof(A, $/private/nim/elem/snd=answer(A), AnsSet)\n                       $$arity(AnsSet) > 0\n                    \n                    \n                    \n                    \n                    \n                    \n                    \n                    \n                      is empty($/private/plan)\n                       $domain :: plan(DepQ, P lan)\n                    \n                    \n                    \n                    \n                    \n                     forall(in(AnsSet, A), in(P lan, findout(Q)) and\n                    \n               pre: \n                          $domain :: relevant(A, Q))\n                       not ( $domain :: plan(DepQ0, P lan0 ) and DepQ0 6= DepQ and\n                    \n                    \n                    \n                    \n                    \n                           forall(in(AnswerSet, A), in(P lan0, findout(Q)) and\n                    \n                    \n                    \n                    \n                    \n                    \n                    \n                    \n                    \n                             $domain :: relevant(A, Q)) )\n                       not  in($/private/agenda,    icm:und*int:usr*issue(DepQ))\n                    \n                    \n                    \n                    \n                    \n                    \n                      push(/shared/issues, DepQ)\n                     push(/private/agenda, icm:accommodate:DepQ)\n                    \n                    \n                    \n               eff:  push(/private/agenda, icm:und*pos:usr*issue(DepQ))\n                    \n                    \n                    \n                     set(/private/plan, P lan)\n                     push(/private/agenda, icm:loadplan)\n                    \n\n",
      "context_before": "\n\n                             Figure 4.4: Dependent issue accommodation\n\n",
      "context_after": "\nThe first two conditions construct a set of all non-integrated answers and check that the\narity of this set is larger than zero, i.e. that there is at least one non-integrated answer.\n"
    },
    {
      "title": "Rule 4.5: clarifyDependentIssue",
      "section": "Unknown",
      "page": 198,
      "category": "Other Algorithms",
      "rule_id": "4.5",
      "content": "    (rule 4.5)   rule: clarifyDependentIssue\n                 class: select action\n                      \n                      \n                         in($/private/nim, pair(usr, answer(A)))\n                          setof(Q0, $domain :: plan(Q0, P lan) and\n                      \n                      \n                      \n                      \n                      \n                             in(P lan, findout(SomeQ)) and\n                      \n                      \n                      \n                      \n                 pre:       $domain :: relevant(A, SomeQ),\n                      \n                      \n                      \n                         QSet0 )\n                          remove unifiables(QSet0, QSet)\n                      \n                      \n                      \n                      \n                      \n                       $$arity(QSet) > 1\n                      \n                      (\n                         ! setof(IssueQ, in(QSet, I) and IssueQ=?issue(I), AltQ)\n                 eff:\n                         push(/private/agenda, findout(AltQ))\n",
      "context_before": "a clarification question should be raised by the system to find out which issue the user\nwants the system to deal with. This is done by the selection rule in (rule 4.5).\n\n\n",
      "context_after": ""
    },
    {
      "title": "Rule 4.6: accommodateCom2Issues",
      "section": "Unknown",
      "page": 201,
      "category": "Other Algorithms",
      "rule_id": "4.6",
      "content": " (rule 4.6)     rule: accommodateCom2Issues\n                class: accommodate\n                     \n                     \n                     \n                         $/private/nim/elem/snd=answer(A)\n                         in($/shared/com,   P)\n                     \n                     \n                     \n                     \n                pre:  $domain :: question(Q)\n                     \n                     \n                     \n                        $domain :: relevant(A, Q)\n                      $domain :: relevant(P, Q)\n                     \n                     n\n                eff: push(/shared/issues, Q)\n\n\nThis accommodation rule looks for an answer A among the moves which have not yet been\nintegrated (first condition). It then looks for a proposition among the shared commitments\nestablished in the dialogue so far (second condition) which according to the system’s domain\nresource is an appropriate answer to some question for which A is also an answer (third to\nfifth conditions). Given that in this simple system answers can only be relevant to a single\nquestion10, this strategy will be successful in identifying cases where we have two answers\nto the same question. A system that deals with more complex dialogues where this is not\nthe case would need to keep track of closed issues in a separate list of closed issues. Thus\nthe conditions will succeed if there is a question such that both the user answer and a stored\nproposition are relevant answers to it; in the example dialogue above, “departure date is\nthe fourth” and “departure date is the fifth” are both relevant answers to the question\n“which day do you want to travel?”. If such a question is found it is accommodated to\nissues, that is, it becomes an open issue again.\n\nWhen accommodateCom2Issues has been successfully applied, the retract rule in (rule\n  10\n    That is, in the full form in which they appear in $/shared/com. “Chicago” can be an answer to\n“Which city do you want to go to?” and “Which city do you want to go from?” but when it has been\ncombined with the questions the result will be “destination(Chicago)” and “from(Chicago)” respectively\nand it is this which is entered into the commitments.\n",
      "context_before": "since there is no matching question on issues. The system will then try various accom-\nmodation strategies, including accommodation from /shared/com formulated in (rule\n4.6).\n\n",
      "context_after": ""
    },
    {
      "title": "Rule 4.7: retract",
      "section": "Unknown",
      "page": 202,
      "category": "Other Algorithms",
      "rule_id": "4.7",
      "content": " (rule 4.7)    rule: retract\n               class: integrate\n                    \n                    \n                       $/private/nim/elem/snd=answer(A)\n                        in($/shared/com,   P 0)\n                    \n                    \n                    \n                    \n                    \n                     fst($/shared/issues, Q)\n                    \n                    \n                    \n               pre:  $domain :: relevant(P, Q)\n                    \n                    \n                    \n                       $domain :: relevant(A, Q)\n                        $domain :: combine(Q, A, P )\n                    \n                    \n                    \n                    \n                    \n                     $domain :: incompatible(P, P 0 )\n                    \n                    n\n               eff: del(/shared/com, P 0 )\n\n\nThe conditions here are similar to those in (rule 4.6). We look for an unintegrated\nanswer (first condition) which is relevant to a question at the head of the list of open issues\n(third and fifth conditions) and for which there is already a relevant answer in the shared\ncommitments (second and fourth conditions). Finally, we determine that the result of\ncombining the answer with the question (sixth condition) is incompatible with the answer\nalready found (seventh condition). If all this is true we delete the answer which is currently\nin the shared commitments. This will finally allow the new answer to be integrated by a\nrule that integrates an answer from the user, and a further rule will remove the resolved\nissue from QUD. Note that this rule is of class integrate. As is indicated in Appendix B, it\nis tried before any other integration rule, to avoid integration of conflicting information.\n\nNote also that the “incompatible” relation is defined as a part of the domain resource, and\ncan thus be domain specific. The simple kind of revision that IBiS currently deals with\nis also handled by some form-based systems (although they usually do not give feedback\nindicating that information has been removed or replaced, as IBiS does). For example,\nChu-Carroll (2000) achieves a similar result by extracting parameter values from the latest\nuser utterance and subsequently (if possible) copying values from the previous form for\nany parameters not specified in the latest utterance. A similar mechanism is referred to\nas “overlay” by Alexandersson and Becker (2000). While we are dealing only with very\nsimple revision here, the rule in (rule 4.7) and the “incompatible” relation can be seen as\nplaceholders for a more sophisticated mechanism of belief revision.\n\nIt is also possible to remove the old answer by denying it (asserting its negation) as in\n(dialogue 4.7).\n\n\n(dialogue 4.7)\n",
      "context_before": "\n4.7) will remove the incompatible information from the system’s view of shared commit-\nments represented in /shared/com.\n\n",
      "context_after": ""
    },
    {
      "title": "Rule 4.8: accommodateCom2IssuesDependent",
      "section": "Unknown",
      "page": 204,
      "category": "Other Algorithms",
      "rule_id": "4.8",
      "content": " (rule 4.8)    rule: accommodateCom2IssuesDependent\n               class: accommodate\n                    \n                       $/private/nim/elem/snd=answer(A)\n                        in($/shared/com, P )\n                    \n                    \n                    \n                    \n                    \n                        $domain :: question(Q)\n                    \n                    \n                    \n                    \n                    \n                     $domain :: relevant(A, Q)\n                    \n                    \n                    \n               pre:  $domain :: relevant(P, Q)\n                    \n                    \n                    \n                       is empty($/shared/issues)\n                        $domain :: depends(Q0, Q)\n                    \n                    \n                    \n                    \n                    \n                        in($/shared/com, P 0 )\n                    \n                    \n                    \n                    \n                    \n                        $domain :: relevant(P 0, Q0 )\n                    \n                    \n                    \n                       del(/private/bel, P 0 )\n                                             0\n                    \n                     del(/shared/com, P )\n                    \n                    \n                    \n               eff:  push(/shared/issues, Q0 )\n                    \n                    \n                    \n                       push(/shared/issues, Q)\n                     push(/private/agenda, respond(Q0 ))\n                    \n\n",
      "context_before": "182                                   CHAPTER 4. ADDRESSING UNRAISED ISSUES\n\n",
      "context_after": "\nThis rule is similar to 6 except that is looks for a question which depends on the question\nit finds corresponding to the answer provided by the user. It puts both question onto the\nlist of open issues and plans to respond to the dependent question. This rule, as currently\nimplemented, is specific to the particular case treated in the system. There is, of course, a"
    },
    {
      "title": "Rule 4.9: accommodateQUD2Issues",
      "section": "Unknown",
      "page": 205,
      "category": "Other Algorithms",
      "rule_id": "4.9",
      "content": " (rule 4.9)    rule: accommodateQUD2Issues\n               class: accommodate\n                    \n                       $/private/nim/elem/snd=answer(A)\n                     in($/shared/QUD, Q)\n                    \n               pre: \n                    \n                       $domain :: relevant(A, Q)\n                        not in($/shared/issues, Q)\n                    \n                    n\n               eff: push(/shared/issues, Q)\n\n\nThe rule in (rule 4.9) picks out a non-integrated answer-move which is relevant to a\nquestion on QUD which is not currently an open issue, and pushes it on issues.\n\nTo handle integration responses to positive understanding feedback, we also need to mod-\nify the integrateNegIcmAnswer rule described in Section 3.6.6. A significant difference\nbetween positive and interrogative feedback in IBiS is that the former is associated with\ncautiously optimistic grounding, while the latter is used in the pessimistic grounding strat-\negy. This means that a negative response to feedback on the understanding level must be\nhandled differently depending on whether the content in question has been added to the\ndialogue gameboard or not. Specifically, if the positive feedback is rejected the optimistic\ngrounding assumption must be retracted.\n",
      "context_before": "than explicit, we push it onto the local QUD only. If the user addresses it (e.g. by saying\n“no”), the implicit issue is “opened up”, i.e. it becomes an open issue; it is pushed on\nISSUES.\n\n",
      "context_after": ""
    },
    {
      "title": "Rule 4.10: integrateNegIcmAnswer",
      "section": "Unknown",
      "page": 206,
      "category": "Update Rules",
      "rule_id": "4.10",
      "content": "(rule 4.10) rule: integrateNegIcmAnswer\n            class: integrate\n                 \n                     $/private/nim/fst/snd=answer(A)\n                      fst($/shared/issues,   Q)\n                 \n                 \n                 \n                 \n                 \n                  $domain :: resolves(A, Q)\n                 \n            pre:\n                 \n                 \n                     fst($/shared/QUD, Q)\n                      $domain :: combine(Q, A, P )\n                 \n                 \n                 \n                 \n                 \n                      P =not(und(DP *C))\n                 \n                 \n                 \n                 \n                    pop(/private/nim)\n                     pop(/shared/issues)\n                 \n                 \n                 \n                 \n                 \n                     if do(in($/shared/com, C) or\n                 \n                 \n                 \n                 \n                         C=issue(Q0 ) and in($/shared/issues, Q0 ), [\n                 \n                 \n                 \n                 \n                 \n                         /shared/QUD := $/private/tmp/DP /QUD\n                 \n                 \n                 \n                 \n                 \n                         /shared/issues := $/private/tmp/DP /issues\n                 \n                 \n            eff: \n                 \n                        /shared/com := $/private/tmp/DP /com\n                         /private/agenda := $/private/tmp/DP /agenda\n                 \n                 \n                 \n                 \n                 \n                         /private/plan   := $/private/tmp/DP /plan ])\n                 \n                 \n                 \n                 \n                 \n                 \n                 \n                 \n                    push(/private/agenda, icm:und*pos:DP *not(C))\n                     clear(/private/nim)\n                 \n                 \n                 \n                 \n                 \n                  init shift(/private/nim)\n                 \n\n",
      "context_before": "184                                   CHAPTER 4. ADDRESSING UNRAISED ISSUES\n\n",
      "context_after": "\n\nThe rule in (rule 4.10) is similar to those for integrating “normal” user answers (see Sec-\ntion 3.6.6), because of the special nature of grounding issues, we include issue downdating\nin the rule rather than adding a further rule for downdating issues for this special case."
    },
    {
      "title": "Rule 4.11: integratePosIcmAnswer",
      "section": "Unknown",
      "page": 211,
      "category": "Update Rules",
      "rule_id": "4.11",
      "content": "(rule 4.11) rule: integratePosIcmAnswer\n            class: integrate\n                 \n                     $/private/nim/fst/snd=answer(A)\n                      fst($/shared/issues,   Q)\n                 \n                 \n                 \n                 \n                 \n                  $domain :: resolves(A, Q)\n                 \n            pre:\n                 \n                 \n                     fst($/shared/QUD, Q)\n                      $domain :: combine(Q, A, P )\n                 \n                 \n                 \n                 \n                 \n                      P =und(DP *Content)\n                 \n\n                     pop(/private/nim)\n                 \n                 \n                 \n                     pop(/shared/issues)\n                 \n                 \n                 \n                 \n                     if then else(Content=issue(Q0 ), [\n                 \n                 \n                 \n                 \n                 \n                         push(/private/tmp/DP /QUD, Q0 )\n                 \n                 \n                 \n                 \n                 \n                         push(/private/tmp/DP /issues, Q0 )\n                 \n                 \n                 \n                 \n                 \n                         push(/private/tmp/DP /agenda, respond(Q0 )) ],\n                 \n                 \n                 \n                 \n                 \n                         add(/private/tmp/DP /com, Content))\n                 \n                 \n            eff: \n                    if do(not ( in($/shared/com, Content) or\n                         Content=issue(Q0 ) and in($/shared/issues, Q0 ) ),\n                 \n                 \n                 \n                 \n                 \n                         if then else(Content=issue(Q0 ), [\n                 \n                 \n                 \n                 \n                 \n                             push(/shared/QUD, Q0 )\n                 \n                 \n                 \n                 \n                 \n                             push(/shared/issues, Q0 )\n                 \n                 \n                 \n                 \n                 \n                             push(/private/agenda, respond(Q0 )) ],\n                 \n                 \n                 \n                 \n                 \n                         add(/shared/com, Content)))\n                 \n\n",
      "context_before": "4.6. VARIETIES OF QUESTION ACCOMMODATION AND REACCOMMODATION189\n\n",
      "context_after": "\nThe conditions are similar to those of the previous version of the rule, except for inspecting\nissues instead of qud. The first two updates are also the same. The third update adds the\ncontent Content which is being grounded to tmp/usr (in case DP is usr, which it always\nis in IBiS3). This means that if future feedback (concerning the same utterance) from the"
    },
    {
      "title": "Rule 4.12: noFollowup",
      "section": "Unknown",
      "page": 212,
      "category": "Other Algorithms",
      "rule_id": "4.12",
      "content": "(rule 4.12) rule: noFollowup\n            class:( (none)\n                     $input, ’TIMED OUT’\n            pre:\n                     in($/shared/pm, icm:und*pos:usr*Content)\n                 \n                 \n                 \n                 \n                    if then else(Content=issue(Q), [\n                        push(/private/tmp/usr/QUD, Q)\n                 \n                 \n                 \n                 \n            eff:       push(/private/tmp/usr/issues, Q)\n                 \n                 \n                 \n                       push(/private/tmp/usr/agenda, respond(Q)) ],\n                  add(/private/tmp/usr/com, Content))\n                 \n\n",
      "context_before": "190                                        CHAPTER 4. ADDRESSING UNRAISED ISSUES\n\n",
      "context_after": "\nThe first condition is true only if the user did not produce any utterance (that the system\nheard) during her latest turn11 . The second condition checks that the moves performed in\nthe previous utterance includes positive understanding feedback regarding Content. The\nfirst updates are identical to the third update in the integratePosIcmAnswer rule in"
    },
    {
      "title": "Rule 4.13: backupSharedUsr",
      "section": "Unknown",
      "page": 215,
      "category": "Other Algorithms",
      "rule_id": "4.13",
      "content": "(rule 4.13) rule: backupSharedUsr\n            class: (none)\n                 \n                 \n                    $latest speaker=usr\n                     $latest moves=M oves\n                 \n                 \n                 \n                 \n                 \n                  not in(M oves, icm:X)\n                 \n                 \n                 \n            pre:     not in(M oves, no move)\n                     not ( fst($/shared/QUD, und(usr*C)) and\n                 \n                 \n                 \n                 \n                 \n                        in(A, answer(D)) and\n                 \n                 \n                 \n                 \n                 \n                        $domain :: relevant(D, und(usr*C)))\n                 \n                 \n                 \n                 \n                 \n                 \n                    /private/tmp/usr/QUD     := $/shared/QUD\n                  /private/tmp/usr/issues := $/shared/issues\n                 \n                 \n                 \n            eff:    /private/tmp/usr/com := $/shared/com\n                    /private/tmp/usr/agenda := $/private/agenda\n                 \n                 \n                 \n                 \n                 \n                  /private/tmp/usr/plan := $/private/plan\n                 \n\n",
      "context_before": "4.7. FURTHER IMPLEMENTATION ISSUES                                                       193\n\n",
      "context_after": "\n\nThe first condition checks that the latest speaker was indeed the user; if not, the rule\nshould of course not trigger. The next four conditions are used to prevent triggering in\ncase of an ICM subdialog, i.e. if the user produced an ICM move or responded to one from"
    },
    {
      "title": "Rule 5.1: integrateUsrRequest",
      "section": "Unknown",
      "page": 238,
      "category": "Update Rules",
      "rule_id": "5.1",
      "content": " (rule 5.1)   rule: integrateUsrRequest\n              class: integrate\n                   \n                   \n                   \n                       $/private/nim/fst/snd=request(A)\n                    $/shared/lu/speaker==usr\n                   \n                   \n                   \n              pre:  $score=Score\n                   \n                   \n                   \n                      Score > 0.7\n                    $domain :: plan(A, P lan)\n                   \n                   \n                   \n                   \n                      pop(/private/nim)\n                       add(/shared/lu/moves,   request(A))\n                   \n                   \n                   \n                   \n                   \n                    push(/private/agenda, icm:acc*pos)\n                   \n                   \n                   \n              eff:  if do(Score ≤ 0.9,\n                   \n                   \n                   \n                         push(/private/agenda, icm:und*pos:usr*action(A)))\n                       push(/shared/actions, A)\n                   \n                   \n                   \n                   \n                   \n                    push(/private/agenda, A)\n                   \n\n",
      "context_before": "\nThe rule for integrating user requests is shown in (rule 5.1).\n\n\n",
      "context_after": "\nThis rule is similar to that for integrating user ask moves (see Section 3.6.6); instead of\npushing an issue Q on ISSUES and QUD, and pushing respond(Q) on the agenda, this rule\npushes the requested action A on /shared/actions and /private/agenda.\n"
    },
    {
      "title": "Rule 5.2: rejectAction",
      "section": "Unknown",
      "page": 238,
      "category": "Other Algorithms",
      "rule_id": "5.2",
      "content": " (rule 5.2)   rule: rejectAction\n              class: select action\n                    in($/private/nim, request(A))\n                   \n              pre:  $/shared/lu/speaker=usr\n                   \n                       not $domain :: plan(A, P lan)\n                   \n                    del(/private/nim, request(A))\n                   \n              eff:  push(/private/agenda, icm:und*pos:usr*action(A))\n                   \n                       push(/private/agenda, icm:acc*neg:action(A))\n\n",
      "context_before": "As for user ask moves we also need to deal with the case where the system must reject an\naction since it does not have a plan for dealing with it. This rule is shown in (rule 5.2).\n\n\n",
      "context_after": "\n5.6.2    Executing device actions\n\nThe update rule for executing the dev do device action is shown in (rule 5.3).\n"
    },
    {
      "title": "Rule 5.3: exec dev do",
      "section": "Unknown",
      "page": 239,
      "category": "Update Rules",
      "rule_id": "5.3",
      "content": " (rule 5.3)   rule: exec dev do\n              class:n exec plan\n              pre: fst($/private/plan, dev do(Dev, Adev ))\n                       pop(/private/plan)\n                   \n                   \n                   \n                    ! $/shared/com=P ropSet\n                   \n              eff: \n                   \n                      devices/Dev :: dev do(P ropSet, Adev )\n                       add(/private/bel, done(Adev ))\n                   \n\n\nThe condition looks for a dev do upnp action in the plan, with arguments Dev, the device\npath name, and Adev, the device action. The updates pop the action off the plan, and\napplies the corresponding update dev do(P ropSet, Adev ) to the device Dev. Finally, the\nproposition done(Adev ) is added the the private beliefs.\n\nIn addition, we have implemented rules for executing the dev get, dev set and dev query\nactions.\n\n",
      "context_before": "5.6. UPDATE RULES AND DIALOGUE EXAMPLES                                               217\n\n",
      "context_after": "\n5.6.3    Selecting and integrating confirm-moves\n\nThe selection rule for the confirm action is shown in (rule 5.4).\n"
    },
    {
      "title": "Rule 5.4: selectConfirmAction",
      "section": "Unknown",
      "page": 239,
      "category": "Selection Rules",
      "rule_id": "5.4",
      "content": " (rule 5.4)   rule: selectConfirmAction\n              class: select action\n                   \n                      fst($/shared/actions, A)\n                    $domain :: postcond(A, P C)\n                   \n              pre: \n                   \n                      in($/private/bel, P C)\n                       not in($/shared/com, P C)\n                   \n                   n\n              eff: push(/private/agenda, confirm(A))\n\n\nThe conditions in this rule check that the there is an action in /shared/actions whose\npostcondition is believed by the system to be true, however, this is not yet shared infor-\nmation. If this is true, a confirm action is pushed on the agenda. Eventually, this action\n(which also is a dialogue move) is moved to next moves by (rule 5.5).\n\n",
      "context_before": "5.6.3    Selecting and integrating confirm-moves\n\nThe selection rule for the confirm action is shown in (rule 5.4).\n\n",
      "context_after": " (rule 5.5)   rule: selectConfirm\n              class:n select move\n              pre: fst($/private/agenda, confirm(A))\n                   (\n                      push(next moves, confirm(A))"
    },
    {
      "title": "Rule 5.5: selectConfirm",
      "section": "Unknown",
      "page": 239,
      "category": "Selection Rules",
      "rule_id": "5.5",
      "content": " (rule 5.5)   rule: selectConfirm\n              class:n select move\n              pre: fst($/private/agenda, confirm(A))\n                   (\n                      push(next moves, confirm(A))\n              eff:\n                      pop(/private/agenda)\n",
      "context_before": "postcondition is believed by the system to be true, however, this is not yet shared infor-\nmation. If this is true, a confirm action is pushed on the agenda. Eventually, this action\n(which also is a dialogue move) is moved to next moves by (rule 5.5).\n\n",
      "context_after": ""
    },
    {
      "title": "Rule 5.6: integrateConfirm",
      "section": "Unknown",
      "page": 240,
      "category": "Update Rules",
      "rule_id": "5.6",
      "content": " (rule 5.6)        rule: integrateConfirm\n                   class:n integrate\n                   pre: $/private/nim/fst/snd=confirm(A)\n                        (\n                            pop(/private/nim)\n                   eff:\n                            add(/shared/com, done(A))\n\n\nThis rule adds the proposition done(A) to the shared commitments which enables the\ndowndateActions rule in (rule 5.7) to trigger.\n\n",
      "context_before": "218                CHAPTER 5. ACTION-ORIENTED AND NEGOTIATIVE DIALOGUE\n\nWhen the confirmation move has been made, it is integrated by the rule in (rule 5.6).\n\n",
      "context_after": " (rule 5.7)        rule: downdateActions\n                   class: downdate issues\n                         fst($/shared/actions, A)\n                        \n                   pre:  $domain :: postcond(A, P C)"
    },
    {
      "title": "Rule 5.7: downdateActions",
      "section": "Unknown",
      "page": 240,
      "category": "Update Rules",
      "rule_id": "5.7",
      "content": " (rule 5.7)        rule: downdateActions\n                   class: downdate issues\n                         fst($/shared/actions, A)\n                        \n                   pre:  $domain :: postcond(A, P C)\n                        \n                        n\n                            in($/shared/com, P C )\n                   eff: pop(/shared/actions)\n\n\nThis rule removes an action A whose postcondition is jointly believed to be true from\nactions2.\n\n",
      "context_before": "\nThis rule adds the proposition done(A) to the shared commitments which enables the\ndowndateActions rule in (rule 5.7) to trigger.\n\n",
      "context_after": "\n5.6.4        Dialogue example: menu traversal and multiple threads\n\nIn (dialogue 5.1) we show a sample dialogue interaction with the menu-based VCR\napplication. It shows both menu traversal and accommodation, as well as dealing with"
    },
    {
      "title": "Rule 5.8: accommodateAction",
      "section": "Unknown",
      "page": 243,
      "category": "Other Algorithms",
      "rule_id": "5.8",
      "content": " (rule 5.8)    rule: accommodateAction\n               class:\n                     accommodate\n                    \n                    \n                    \n                       setof(A, $/private/nim/elem/snd=answer(A), AnsSet)\n                       $$arity(AnsSet) > 0\n                    \n                    \n                    \n                    \n                    \n                    \n                    \n                    \n                      $domain    :: plan(Action, P lan)\n                       $domain :: action(Action)\n                    \n                    \n                    \n                    \n                    \n                     forall(in(AnsSet, A), in(P lan, findout(Q)) and\n                    \n               pre: \n                         $domain :: relevant(A, Q))\n                       not $domain :: plan(Action0, P lan0 ) and Action0 6=Action and\n                    \n                    \n                    \n                    \n                    \n                          forall(in(AnsSet, A), in(P lan0, findout(Q)) and\n                    \n                    \n                    \n                    \n                    \n                    \n                    \n                    \n                    \n                         $domain :: relevant(A, Q))\n                       not in($/private/agenda, icm:und*int:usr*action(Action))\n                    \n                    \n                    \n                    \n                    \n                    \n                      push(/shared/actions,       Action)\n                     push(/private/agenda, icm:accommodate:Action)\n                    \n                    \n                    \n               eff:  push(/private/agenda, icm:und*pos:usr*action(action))\n                    \n                    \n                    \n                     set(/private/plan, P lan)\n                     push(/private/agenda, icm:loadplan)\n                    \n\n",
      "context_before": "5.6. UPDATE RULES AND DIALOGUE EXAMPLES                                                    221\n\n",
      "context_after": "\nThis rule is very similar to the accommodateDependentIssue (see Section 4.6.4), except\nthat it accommodates a dependent action rather than a dependent issue.\n\nIf the system finds several actions matching the information given by the user, a clarification"
    },
    {
      "title": "Rule 5.9: clarifyIssueAction",
      "section": "Unknown",
      "page": 243,
      "category": "Other Algorithms",
      "rule_id": "5.9",
      "content": " (rule 5.9)    rule: clarifyIssueAction\n               class: select action\n                    \n                    \n                    \n                        in($/private/nim, pair(usr, answer(A)))\n                     setof(Action, $domain :: depends(α, Q) and\n                    \n                    \n                    \n               pre:        $domain :: relevant(A, Q), ActionSet)\n                    \n                    \n                    \n                       remove unifiables(Actions, Actions0 )\n                     $$arity(Actions0 ) > 1\n                    \n\n                        ! setof(?IssueP rop, in(Actions0, Issue0 ) and\n                    \n                    \n                    \n                           not $domain :: action(Issue0 ) and\n                    \n                    \n                    \n                    \n                    \n                           IssueP rop=issue(Issue0 ), IssueQuestions)\n                    \n                    \n                    \n                    \n                    \n                     ! setof(?ActionP rop, in(Actions0, Action0 ) and\n                    \n               eff: \n                    \n                          $domain :: action(Action0 ) and\n                           ActionP rop=action(Action), ActionQuestions)\n                    \n                    \n                    \n                    \n                    \n                        ! union(IssueQuestions, ActionQuestions, AltQ)\n                    \n                    \n                    \n                    \n                    \n                    \n                        push(/private/agenda, findout(AltQ))\n",
      "context_before": "question is raised. This is again similar to the behaviour for issues described in Section\n4.6.5; in fact, the rule below replaces the previous clarifyDependentIssue rule.\n\n\n",
      "context_after": ""
    }
  ]
}