{
  "source": "docs/Larsson_Tesis.pdf",
  "total_algorithms": 198,
  "algorithms": [
    {
      "title": "Procedure/Rule in 1.1 The aim of this study",
      "section": "1.1 The aim of this study",
      "page": 23,
      "content": "Chapter 1\nIntroduction\n1.1 The aim of this study\nThe primary aim of this study is to explore issue-based dialogue management, an ap-\nproach to dialogue management and dialogue modelling which regards issues, modelled\nsemantically as questions, as a primary organizing and motivating force in dialogue.\nThis exploration will proceed both on a theoretical and a practical implementation level.\nStarting from a basic account of issue-based dialogue management, we gradually extend\nthe coverage of the theory and the implementation to more complex types of dialogue. A\nsecondary aim is to exploit the difierences between the successive versions of the theory\n(and implementation) to provide a formal characterization of difierent types of dialogue.\nWe will only be concerned with what Allen et al. (2001) refer to as practical dialogue, i.e.\ndialogue focused on accomplishing a concrete task.\nOur general strategy for reaching these goals will be to try as far as possible to \\keep things\nsimple\"; that is, for each type of dialogue we try to give an account that handles exactly\nthose phenomena appearing in that type of dialogue. However, we also want to keep things\nfairly general, to enable reuse of components of a simple version in a more complex version\nof the theory and implementation.\nIn this chapter, we will flrst motivate exploring the issue-based approach to dialogue man-\nagement. We will then give an outline of this thesis and give brief descriptions of the\nimplementations. Finally, we will introduce the TrindiKit, a toolkit for building and\nexperimenting with dialogue systems, which has been used for the implementations.\n1",
      "context_before": "",
      "context_after": ""
    },
    {
      "title": "Procedure/Rule in 2.1. INTRODUCTION 17",
      "section": "2.1. INTRODUCTION 17",
      "page": 39,
      "content": "2.1. INTRODUCTION 17\nIt is useful, however, to have a concept of inquiry-oriented dialogue which does not include\ngiving orders or instructions to perform actions changing the state of the world (rather\nthan just changing the information states of DPs), or indeed any utterance resulting in a\nDP having an obligation or commitment to perform some action. However, it must also\nbe remembered that utterances are also actions, and DPs can be obliged to perform them;\nfor example, a question can be said to introduce an obligation on the hearer to respond to\nthat question. So we still want to allow utterances which result in obligations to perform\ncommunicative actions that are part of the dialogue2. Of course, the same applies to these\nobliged actions themselves. In efiect, this deflnitions serves to exclude orders, instructions\netc. from information-oriented dialogue.\nWiththismotivation, thetermInquiryOrientedDialogue, orIOD,willhenceforthbetaken\nto refer to any dialogue whose sole purpose is the transference of information, and which\ndoes not involve any DP assuming (or trying to make another DP assume) commitments\nor obligations concerning any non-communicative actions outside the dialogue.\nHulstijn (2000) deflnes the dialogue game of inquiry in the following way:\nThe dialogue game of inquiry is deflned as the exchange of information between\ntwo participants: an inquirer and an expert (...). The inquirer has a certain\ninformation need. Her goal in the game is to ask questions in the domain in\norder to satisfy her information need. The expert has access to a database\nabout the domain. His goal is to answer questions. (...) [T]he expert may ask\nquestions too. (Hulstijn, 2000 p. 66)\nHere, tworolesareintroduced: inquirerandexpert. Thisconceptisparticularlywellsuited\nfor dialogue systems for database search, which happens to be the type of dialogue we will\ninitially be exploring. In a dialogue system setting, the system is typically the expert and\nthe user is the inquirer.\nInitially, we will be dealing only with a subtype of inquiry-oriented dialogue, namely non-\nnegotiative IOD. Negotiative dialogue here refers to, roughly, dialogue where DPs can\ndiscuss and compare several difierent alternative solutions to a problem. Non-negotiative\ndialogue is su–cient when database searches can be expected to return only a single result\n(rather than e.g. a table). Obviously this is insu–cient for dealing with many information-\nseeking domains and applications. In Chapter 4 we will be able to handle semi-negotiative\ndialogue, where several alternatives can be introduced in the dialogue; however, the intro-\nduction of a new alternative will always remove the previous alternative which thus cannot\nbe returned to unless reintroduced \\from scratch\".\n2The reservation that the obliged actions are part of the dialogue is meant to exclude utterances which\nimpose an obligation to perform a communicative action directed at some agent who is not a DP, e.g.\n\\Tell Martha to go home\".",
      "context_before": "",
      "context_after": ""
    },
    {
      "title": "Procedure/Rule in 2.3.2 Simplifying assumptions",
      "section": "2.3.2 Simplifying assumptions",
      "page": 44,
      "content": "22 CHAPTER 2. BASIC ISSUE-BASED DIALOGUE MANAGEMENT\n(2.2) repeat h select\nif not is empty($next moves)\nthen h generate\noutput\nupdate i\ntest( $program state == run )\ninput\ninterpret\nupdate i\nThe IBiS system uses modules included in the TrindiKit package for input, interpre-\ntation, generation and output. The interpretation and generation modules are described\nin Section A.7. The update and selection modules are described in Sections 2.8 and 2.9,\nrespectively.\nTurntaking is regulated by the following principle: if select flnds a move to perform, the\nsystem will generate a string and output it to the user. The TIS is then updated, and\nprovided the program state variable is still set to run, the system reads input from the\nuser, interprets it, and again updates the TIS. This means that if select flnds no move to\nperform, the turn will be handed over to the user.\n2.3.2 Simplifying assumptions\nFor our initial system, we will make some simplifying assumptions, which in efiect will pro-\nvide us with a system that only handles a limited range of dialogue phenomena. Later, we\nwill remove some of these limitations and extend the implementation correspondingly. The\nsimplifying assumptions will make it easier to formulate a simple basic set of information\nstate update rules.\n† All utterances are understood and accepted. This assumption will be removed in\nSection 3.\n† Utterance interpretation does not involve the identiflcation of referents, and referents\nare not represented in the information state. This assumption will be removed in\nChapter 5.\n† Complex semantic representation is not needed for simple kinds of dialogue. This\nassumption will not be removed; however, it is clear that a more complex semantic\nanalysis involving e.g. quantiflcation, temporality, and modality would be required",
      "context_before": "",
      "context_after": ""
    },
    {
      "title": "Procedure/Rule in 2.4.3 Questions",
      "section": "2.4.3 Questions",
      "page": 48,
      "content": "26 CHAPTER 2. BASIC ISSUE-BASED DIALOGUE MANAGEMENT\nwant to go to Paris\" could normally be represented semantically as e.g. want(user, go-\nto(user, paris) ) or want(u, go-to(u,p)) & city(p) & name(p, paris) & user(u).\nWe will be using a reduced semantic representation with a coarser, domain-dependent\nlevel of granularity; for example, the above example will be rendered as dest-city(paris).\nThis reduced representation is in part a consequence of the use of keyword-spotting in\ninterpreting utterances, but can arguably also be regarded as a re(cid:176)ection of the level of\nsemantic granularity inherent in the underlying domain task. As an example of the latter,\nin a travel agency domain there is no point in representing the fact that it is the user (or\ncustomer) rather than the system (or clerk) who is going to Paris; it is implicitly assumed\nthat this is always the case.\nAs a consequence of using reduced semantics, it will be useful to allow 0-ary predicates,\ne.g. return, meaning \\the user wants a return ticket\". 0-ary predicates can of course\nappear in non-reduced semantics as well, e.g. in the representation of \\It’s raining\" in a\nnon-temporal logic as e.g. rain. (Of course, non-temporal logic can also be argued to be\na kind of reduced semantic representation.)\nThe advantage of this semantic representation is that the speciflcation of domain-speciflc\nsemantics becomes simpler, and that unnecessary \\semantic clutter\" is avoided. On the\nother hand, it severely restricts the possibility of providing generic semantic analyses that\ncan be extended to other domains.\nIf the database search for an answer to a question q fails the resulting proposition is fail(q).\nWe have chosen this representation because it provides a concise way of encoding a failure\nto flnd an answer to q in the database.\n2.4.3 Questions\nThreetypesofquestionsarehandledby IBiS:y/n-questions, wh-questions, andalternative\nquestions. Here we describe how these are represented on a semantic level; the syntactic\nrealization is deflned in the lexicon.\n† y/n-questionsarepropositionsprecededbyaquestionmark,e.g. ?dest-city(london)\n(\\Do you want to go to London?\")\n† wh-questions are lambda-abstracts of propositions, with the lambda replaced by a\nquestion mark, e.g. ?x.dest-city(x) (\\Where do you want to go?\")\n† alternative questions are sets of y/n-questions, e.g. f?dest-city(london), ?dest-\ncity(paris)g (\\Do you want to go to London or do you want to go to Paris?\")",
      "context_before": "",
      "context_after": ""
    },
    {
      "title": "Procedure/Rule in 2.6.1 Domain plans and dialogue plans",
      "section": "2.6.1 Domain plans and dialogue plans",
      "page": 55,
      "content": "2.6. REPRESENTING DIALOGUE PLANS IN IBIS1 33\n\\Give me price information!\", \\I want to know about price.\", \\I want price information.\"\nand \\price information\" are all interpreted ask ask(?x.price(x)). For a description of how\nthis interpretation works, see Section A.7.3.\nOfcourse, partofthereasonthatthisapproachworksisthatweareoperatinginsimpledo-\nmains and activities which can be fairly well covered by a keyword-spotting interpretation\nmodule. However, the approach could well be improved by adding a more complex kind of\ngrammar (e.g. HPSG), thus enabling the system to take syntactic features of utterances\ninto account, while still using an activity-based classiflcation. Whether activity-dependent\nclassiflcation of moves is a viable alternative to intention- and structure-based classiflcation\nin general is an issue we will return to in Chapter 6. One hypothesis worth exploring is to\nwhat extent traditional speech acts can be replaced by a combination of activity-related\ndialogue moves (to update IS and decide on future moves) and syntactic sentence modes\n(to decide on the surface form of future moves).\n2.6 Representing dialogue plans in IBiS1\nIn this section we introduce the concept of dialogue plans, and show how these are rep-\nresented in IBiS1. In later chapters, the plan formalism will be extended to handle more\npowerful constructions.\n2.6.1 Domain plans and dialogue plans\nIn our implementation, the domain knowledge resource contains, among other things, a set\nof dialogue plans which contain information about what the system should do in order to\nachieve its goals.\nIn plan-based dialogue management (e.g. Allen and Perrault, 1980), it has been assumed\nthatgeneralplannersandplanrecognizersshouldbeusedtoproducecooperativebehaviour\nfrom dialogue systems. On this account, the system is assumed to have access to a library\nof domain plans, and by recognizing the domain plan of the user, the system can produce\ncooperative behaviour such as supplying information which the user might need to execute\nher plan. On this approach, plans for carrying out dialogues are not represented explicitly;\ninstead, the system is continually inspecting (and perhaps modifying) domain plans to\ndetermine what dialogue moves need to be performed.\nOur approach is instead to directly represent ready-made plans for engaging in coopera-\ntive dialogue and producing cooperative behaviour (such as answering questions) which",
      "context_before": "",
      "context_after": ""
    },
    {
      "title": "rule 2 .1) rule: getLatestMove",
      "section": "3. B provides a response u that addresses q",
      "page": 63,
      "content": "rule 2.1) rule: getLatestMove\nclass: grounding\n$latest moves=Moves\npre:\n$latest speaker=DP\n(\n/shared/lu/moves := Moves\neff:\n/shared/lu/speaker := DP\n(\nThis rule copies the information about the latest utterance from the latest moves and\nlatest speaker to the /shared/lu fleld. The flrst condition picks out the (singleton)\nset of moves stored by the interpretation module, and the second condition gets the value\nof the latest speaker variable. The updates set the values of the two subflelds of the\n/shared/lu record correspondingly.",
      "context_before": "2.8. IBIS1 UPDATE MODULE 41\n(",
      "context_after": "2.8.2 Raising issues: the ask move\nBefore we explain the rules used by IBiS1 for dealing with the ask move, we will review\nGinzburg’s protocols for querying and assertion on which the rules are based. We will also\nargue for some modiflcations of Ginzburg’s protocols, most of which are motivated by the\nfact that we are dealing with a simple dialogue system rather than a human DP. However,\nsome modiflcations have a more general motivation. For instance, whereas Ginzburg’s\nprotocols often describe"
    },
    {
      "title": "rule 2 .2) or the user (rule 2.3.)",
      "section": "2. Conveys a question on which q depends",
      "page": 65,
      "content": "rule 2.2) or the user (rule 2.3.)\n(rule 2.2) rule: integrateSysAsk\nclass: integrate\n$/shared/lu/speaker==sys\npre:\nin($/shared/lu/moves, ask(Q))\n(\neff: push(/shared/qud, Q)\nn\nThe conditions of the rule in (2.14) checks that the latest speaker is sys and that the latest\nmove was an ask move with content Q. The update pushes Q on /shared/qud.",
      "context_before": "c utterance is one that either\n1. Conveys information ABOUT q or\n2. Conveys a question on which q depends\nWehavenotimplementedthisrelationdirectlyinIBiS,howeverbothrelevance(ourversion\nof ’ABOUT’) and dependence are deflned.\nIntegrating ask moves\nThe basic rule expressed by the integration rule for ask moves is shown in (2.14).\n(2.14) To integrate an ask move with content q, make q topmost on\nQUD\nFor integration of ask moves, difierent rules are used depending on who the speaker is: the\nsystem (",
      "context_after": ""
    },
    {
      "title": "rule 2 .3.)",
      "section": "2. Conveys a question on which q depends",
      "page": 65,
      "content": "rule 2.3.)\n(rule 2.2) rule: integrateSysAsk\nclass: integrate\n$/shared/lu/speaker==sys\npre:\nin($/shared/lu/moves, ask(Q))\n(\neff: push(/shared/qud, Q)\nn\nThe conditions of the rule in (2.14) checks that the latest speaker is sys and that the latest\nmove was an ask move with content Q. The update pushes Q on /shared/qud.",
      "context_before": "either\n1. Conveys information ABOUT q or\n2. Conveys a question on which q depends\nWehavenotimplementedthisrelationdirectlyinIBiS,howeverbothrelevance(ourversion\nof ’ABOUT’) and dependence are deflned.\nIntegrating ask moves\nThe basic rule expressed by the integration rule for ask moves is shown in (2.14).\n(2.14) To integrate an ask move with content q, make q topmost on\nQUD\nFor integration of ask moves, difierent rules are used depending on who the speaker is: the\nsystem (rule 2.2) or the user (",
      "context_after": ""
    },
    {
      "title": "rule 2 .2) rule: integrateSysAsk",
      "section": "2. Conveys a question on which q depends",
      "page": 65,
      "content": "rule 2.2) rule: integrateSysAsk\nclass: integrate\n$/shared/lu/speaker==sys\npre:\nin($/shared/lu/moves, ask(Q))\n(\neff: push(/shared/qud, Q)\nn\nThe conditions of the rule in (2.14) checks that the latest speaker is sys and that the latest\nmove was an ask move with content Q. The update pushes Q on /shared/qud.",
      "context_before": "onveys information ABOUT q or\n2. Conveys a question on which q depends\nWehavenotimplementedthisrelationdirectlyinIBiS,howeverbothrelevance(ourversion\nof ’ABOUT’) and dependence are deflned.\nIntegrating ask moves\nThe basic rule expressed by the integration rule for ask moves is shown in (2.14).\n(2.14) To integrate an ask move with content q, make q topmost on\nQUD\nFor integration of ask moves, difierent rules are used depending on who the speaker is: the\nsystem (rule 2.2) or the user (rule 2.3.)\n(",
      "context_after": ""
    },
    {
      "title": "rule 2 .3) rule: integrateUsrAsk",
      "section": "2. Conveys a question on which q depends",
      "page": 66,
      "content": "rule 2.3) rule: integrateUsrAsk\nclass: integrate\n$/shared/lu/speaker==usr\npre:\nin($/shared/lu/moves, ask(Q))\n(\npush(/shared/qud, Q)\neff:\npush(/private/agenda, respond(Q))\n(\nThe update rule in (rule 2.3) for integrating user queries is slightly difierent: if the user",
      "context_before": "44 CHAPTER 2. BASIC ISSUE-BASED DIALOGUE MANAGEMENT\n(",
      "context_after": "asks a question q, the system will also push respond(q) on the agenda. This does not\nhappen if the system asks the question, since it is the user who is expected to answer this\nquestion.\nEventually, the flndPlan (see Section 2.8.6) rule will load the appropriate plan for dealing\nwith Q. This assumes that for any user question that the system is able to interpret, there\nis a plan for dealing with that question. If this were not the case, IBiS would somehow\nhave to reject Q; in Chapter 3 we will"
    },
    {
      "title": "rule 2 .3) for integrating user queries is slightly difierent: if the user",
      "section": "2. Conveys a question on which q depends",
      "page": 66,
      "content": "rule 2.3) for integrating user queries is slightly difierent: if the user\nasks a question q, the system will also push respond(q) on the agenda. This does not\nhappen if the system asks the question, since it is the user who is expected to answer this\nquestion.\nEventually, the flndPlan (see Section 2.8.6) rule will load the appropriate plan for dealing\nwith Q. This assumes that for any user question that the system is able to interpret, there\nis a plan for dealing with that question. If this were not the case, IBiS would somehow\nhave to reject Q; in Chapter 3 we will discuss this further.\nReasons for answering questions\nThe solution of pushing respond(Q) on the agenda when integrating a user ask(Q) move is\nnottheonlypossibleoption. Itcanbeseenasasimple\\intention-based\"strategyinvolving\nminimal reasoning; \\If the user asked q, I’m going to respond to q\". Alternatively, one\ncould opt for a more indirect link between the user asking a question and the system\nintending to respond to it.\nOne such indirect approach is to not push respond(Q) on the agenda when integrating a\nuser ask(Q) move, but only push Q on QUD7. A separate rule would then push respond(Q)\non the agenda given that Q is on QUD and the system has a plan for responding to Q.\nThis reasoning behind this rule could be paraphrased roughly as \\If q is under discussion\nand I know a way of dealing with q, I should try to respond to q\". On this approach,\nit would be assumed that DPs do not care about who asked a question; they will simply\nattempt to answer any question that is under discussion, regardless of who raised it.\nA second indirect approach is to assume that asking a question introduces obligations on\nthe addressee. This \\obligation-based approach\" would require representing obligations as\npart of the shared information. For an obligation-based account of dialogue, see Traum\n(1996); for a comparison of QUD-based and obligation-based approaches, see Kreutel and\n7If the system can understand user questions which it cannot respond to (which IBiS1 does not), the\nintegration rulefor userask moves would still needto checkthat thereisa plan fordealing with Q, orelse\nreject Q; issue rejection is discussed further in Chapter 3.",
      "context_before": "44 CHAPTER 2. BASIC ISSUE-BASED DIALOGUE MANAGEMENT\n(rule 2.3) rule: integrateUsrAsk\nclass: integrate\n$/shared/lu/speaker==usr\npre:\nin($/shared/lu/moves, ask(Q))\n(\npush(/shared/qud, Q)\neff:\npush(/private/agenda, respond(Q))\n(\nThe update rule in (",
      "context_after": ""
    },
    {
      "title": "rule 2 .4) rule: integrateAnswer",
      "section": "2.8.4 Downdating QUD",
      "page": 69,
      "content": "rule 2.4) rule: integrateAnswer\nclass: integrate\nin($/shared/lu/moves, answer(A))\npre: fst($/shared/qud, Q)\n8\n>< $domain :: relevant(A, Q)\n! $domain :: combine(Q, A, P)\neff:\n>:\nadd(/shared/com, P)\n(\nThe flrst condition checks that the latest move was an answer move with content A, and\nthe next two conditions check that A is relevant to some question Q topmost on QUD.\nThe flrst updates combines Q and A to form a proposition P according to the deflnition\nin Section 2.4.7. Finally, P is added to the shared commitments.",
      "context_before": "2.8. IBIS1 UPDATE MODULE 47\n(",
      "context_after": "2.8.4 Downdating QUD\nQUD downdating principle\nGinzburg’s \\QUD downdating principle\" goes as follows:\nAssume q is currently maximal in A’s QUD, and that there exists a p in A’s\nFACTS such that p is goal-fulfllling information for A with respect to q. Then,\nand only then, permit A to remove q from QUD.\nAs mentioned in Section 2.4.6, we make no distinction between an answer being goal-\nfulfllling for a DP with respect to Q and the answer resolving a question Q.\nUpdate rule for QUD downdate\nIn our"
    },
    {
      "title": "rule 2 .5) rule: downdateQUD",
      "section": "2.8.5 Integrating greet and quit moves",
      "page": 70,
      "content": "rule 2.5) rule: downdateQUD\nclass: downdate qud\nfst($/shared/qud, Q)\npre: in($/shared/com, P)\n8\n>< $domain :: resolves(P, Q)\neff: >: pop(/shared/qud)\nn\nThe paraphrase of this rule is straightforward and is left as an exercise to the reader.\nThis rule is perhaps ine–cient in the sense that it may require checking all propositions in\n/shared/com every time the update algorithm is executed. However, in the systems we\nare concerned with the number of propositions is not very high, and in addition we favour\nclarity and simplicity in the implementation over e–ciency.",
      "context_before": "48 CHAPTER 2. BASIC ISSUE-BASED DIALOGUE MANAGEMENT\n(",
      "context_after": "2.8.5 Integrating greet and quit moves\nInIBiS1greetingshavenoefiectontheinformationstate. Theruleforintegratinggreetings\nis shown in (rule 2.6).\n(rule 2.6) rule: integrateGreet\nclass: integrate\npre: in($/shared/lu/moves, greet)\neff: fn\nThe update rules for integrating quit moves performed by the user or system are shown in\n(rule 2.7) and (rule 2.8,) respectively.\n(rule 2.7) rule: integrateUsrQuit\nclass: integrate\n$/shared/lu/speaker==usr\npre:\nin($/shared/lu/moves, quit)\n(\neff: push(/private/age"
    },
    {
      "title": "rule 2 .6).",
      "section": "2.8.5 Integrating greet and quit moves",
      "page": 70,
      "content": "rule 2.6).\n(rule 2.6) rule: integrateGreet\nclass: integrate\npre: in($/shared/lu/moves, greet)\neff: fn\nThe update rules for integrating quit moves performed by the user or system are shown in\n(rule 2.7) and (rule 2.8,) respectively.\n(rule 2.7) rule: integrateUsrQuit\nclass: integrate\n$/shared/lu/speaker==usr\npre:\nin($/shared/lu/moves, quit)\n(\neff: push(/private/agenda, quit)\nn\nIf the quit move is performed by the user, the efiect is that the system puts quit on the\nagenda so that it gets to say \\Goodbye\" to the user before the dialogue ends.",
      "context_before": "is left as an exercise to the reader.\nThis rule is perhaps ine–cient in the sense that it may require checking all propositions in\n/shared/com every time the update algorithm is executed. However, in the systems we\nare concerned with the number of propositions is not very high, and in addition we favour\nclarity and simplicity in the implementation over e–ciency.\n2.8.5 Integrating greet and quit moves\nInIBiS1greetingshavenoefiectontheinformationstate. Theruleforintegratinggreetings\nis shown in (",
      "context_after": ""
    },
    {
      "title": "rule 2 .6) rule: integrateGreet",
      "section": "2.8.5 Integrating greet and quit moves",
      "page": 70,
      "content": "rule 2.6) rule: integrateGreet\nclass: integrate\npre: in($/shared/lu/moves, greet)\neff: fn\nThe update rules for integrating quit moves performed by the user or system are shown in\n(rule 2.7) and (rule 2.8,) respectively.\n(rule 2.7) rule: integrateUsrQuit\nclass: integrate\n$/shared/lu/speaker==usr\npre:\nin($/shared/lu/moves, quit)\n(\neff: push(/private/agenda, quit)\nn\nIf the quit move is performed by the user, the efiect is that the system puts quit on the\nagenda so that it gets to say \\Goodbye\" to the user before the dialogue ends.",
      "context_before": "an exercise to the reader.\nThis rule is perhaps ine–cient in the sense that it may require checking all propositions in\n/shared/com every time the update algorithm is executed. However, in the systems we\nare concerned with the number of propositions is not very high, and in addition we favour\nclarity and simplicity in the implementation over e–ciency.\n2.8.5 Integrating greet and quit moves\nInIBiS1greetingshavenoefiectontheinformationstate. Theruleforintegratinggreetings\nis shown in (rule 2.6).\n(",
      "context_after": ""
    },
    {
      "title": "rule 2 .7) and (rule 2.8,) respectively.",
      "section": "2.8.5 Integrating greet and quit moves",
      "page": 70,
      "content": "rule 2.7) and (rule 2.8,) respectively.\n(rule 2.7) rule: integrateUsrQuit\nclass: integrate\n$/shared/lu/speaker==usr\npre:\nin($/shared/lu/moves, quit)\n(\neff: push(/private/agenda, quit)\nn\nIf the quit move is performed by the user, the efiect is that the system puts quit on the\nagenda so that it gets to say \\Goodbye\" to the user before the dialogue ends.",
      "context_before": "ever, in the systems we\nare concerned with the number of propositions is not very high, and in addition we favour\nclarity and simplicity in the implementation over e–ciency.\n2.8.5 Integrating greet and quit moves\nInIBiS1greetingshavenoefiectontheinformationstate. Theruleforintegratinggreetings\nis shown in (rule 2.6).\n(rule 2.6) rule: integrateGreet\nclass: integrate\npre: in($/shared/lu/moves, greet)\neff: fn\nThe update rules for integrating quit moves performed by the user or system are shown in\n(",
      "context_after": ""
    },
    {
      "title": "rule 2 .8,) respectively.",
      "section": "2.8.5 Integrating greet and quit moves",
      "page": 70,
      "content": "rule 2.8,) respectively.\n(rule 2.7) rule: integrateUsrQuit\nclass: integrate\n$/shared/lu/speaker==usr\npre:\nin($/shared/lu/moves, quit)\n(\neff: push(/private/agenda, quit)\nn\nIf the quit move is performed by the user, the efiect is that the system puts quit on the\nagenda so that it gets to say \\Goodbye\" to the user before the dialogue ends.",
      "context_before": "stems we\nare concerned with the number of propositions is not very high, and in addition we favour\nclarity and simplicity in the implementation over e–ciency.\n2.8.5 Integrating greet and quit moves\nInIBiS1greetingshavenoefiectontheinformationstate. Theruleforintegratinggreetings\nis shown in (rule 2.6).\n(rule 2.6) rule: integrateGreet\nclass: integrate\npre: in($/shared/lu/moves, greet)\neff: fn\nThe update rules for integrating quit moves performed by the user or system are shown in\n(rule 2.7) and (",
      "context_after": ""
    },
    {
      "title": "rule 2 .7) rule: integrateUsrQuit",
      "section": "2.8.5 Integrating greet and quit moves",
      "page": 70,
      "content": "rule 2.7) rule: integrateUsrQuit\nclass: integrate\n$/shared/lu/speaker==usr\npre:\nin($/shared/lu/moves, quit)\n(\neff: push(/private/agenda, quit)\nn\nIf the quit move is performed by the user, the efiect is that the system puts quit on the\nagenda so that it gets to say \\Goodbye\" to the user before the dialogue ends.",
      "context_before": "h the number of propositions is not very high, and in addition we favour\nclarity and simplicity in the implementation over e–ciency.\n2.8.5 Integrating greet and quit moves\nInIBiS1greetingshavenoefiectontheinformationstate. Theruleforintegratinggreetings\nis shown in (rule 2.6).\n(rule 2.6) rule: integrateGreet\nclass: integrate\npre: in($/shared/lu/moves, greet)\neff: fn\nThe update rules for integrating quit moves performed by the user or system are shown in\n(rule 2.7) and (rule 2.8,) respectively.\n(",
      "context_after": ""
    },
    {
      "title": "rule 2 .8) rule: integrateSysQuit",
      "section": "2.8.6 Managing the plan",
      "page": 71,
      "content": "rule 2.8) rule: integrateSysQuit\nclass: integrate\n$/shared/lu/speaker==sys\npre:\nin($/shared/lu/moves, quit)\n(\neff: program state := quit\nn\nIntegrating a quit move performed by the system causes the program state variable to\nbe set to quit. This will eventually cause the program to halt.\nThe greet move does not have any efiect on the information state, and thus no update rule\nis needed to integrate it.",
      "context_before": "2.8. IBIS1 UPDATE MODULE 49\n(",
      "context_after": "2.8.6 Managing the plan\nThe dialogue plans are interpreted by a class of update rules called exec plan. When a\nplan has been entered into the /private/plan fleld, it is processed incrementally by the\nplan management rules. These rules determine which actions end up on the agenda.\nFinding and loading a plan\nWhen integrating a user ask move with content Q, the action respond(Q) is pushed on the\nagenda, thus enabling (rule 2.9) to trigger and load a plan for dealing with Q.\n(rule 2.9) rule: flndPl"
    },
    {
      "title": "rule 2 .9) to trigger and load a plan for dealing with Q.",
      "section": "2.8.6 Managing the plan",
      "page": 71,
      "content": "rule 2.9) to trigger and load a plan for dealing with Q.\n(rule 2.9) rule: flndPlan\nclass: flnd plan\nfst($/private/agenda, respond(Q))\npre: $domain :: plan(Q, Plan)\n8\n>< not in($/private/bel, P) and $domain :: resolves(P, Q)\npop(/private/agenda)\neff:\n>:\nset(/private/plan, Plan)\n(\nThe flrst two conditions check that there is an action respond(Q) on the agenda and that\nthe system has a plan for dealing with Q. The third condition checks that the system does\nnot already know an answer to Q (if it does, the system should instead respond to Q). If\nthese conditions hold, the updates pop respond(Q) ofi the agenda and load the plan.",
      "context_before": "ect on the information state, and thus no update rule\nis needed to integrate it.\n2.8.6 Managing the plan\nThe dialogue plans are interpreted by a class of update rules called exec plan. When a\nplan has been entered into the /private/plan fleld, it is processed incrementally by the\nplan management rules. These rules determine which actions end up on the agenda.\nFinding and loading a plan\nWhen integrating a user ask move with content Q, the action respond(Q) is pushed on the\nagenda, thus enabling (",
      "context_after": ""
    },
    {
      "title": "rule 2 .9) rule: flndPlan",
      "section": "2.8.6 Managing the plan",
      "page": 71,
      "content": "rule 2.9) rule: flndPlan\nclass: flnd plan\nfst($/private/agenda, respond(Q))\npre: $domain :: plan(Q, Plan)\n8\n>< not in($/private/bel, P) and $domain :: resolves(P, Q)\npop(/private/agenda)\neff:\n>:\nset(/private/plan, Plan)\n(\nThe flrst two conditions check that there is an action respond(Q) on the agenda and that\nthe system has a plan for dealing with Q. The third condition checks that the system does\nnot already know an answer to Q (if it does, the system should instead respond to Q). If\nthese conditions hold, the updates pop respond(Q) ofi the agenda and load the plan.",
      "context_before": "eeded to integrate it.\n2.8.6 Managing the plan\nThe dialogue plans are interpreted by a class of update rules called exec plan. When a\nplan has been entered into the /private/plan fleld, it is processed incrementally by the\nplan management rules. These rules determine which actions end up on the agenda.\nFinding and loading a plan\nWhen integrating a user ask move with content Q, the action respond(Q) is pushed on the\nagenda, thus enabling (rule 2.9) to trigger and load a plan for dealing with Q.\n(",
      "context_after": ""
    },
    {
      "title": "rule 2 .10).",
      "section": "2.8.6 Managing the plan",
      "page": 72,
      "content": "rule 2.10).\n(rule 2.10) rule: removeFindout\nclass: exec plan\nfst($/private/plan, flndout(Q))\npre: in($/shared/com, P)\n8\n>< $domain :: resolves(P, Q)\neff: >: pop(/private/plan)\nn\nThis rule removes a flndout(Q) action from the plan in case there is a resolving proposition\nP in /shared/com.\nIf there is a consultDB action topmost on the plan, (rule 2.11) will trigger a database",
      "context_before": "BASED DIALOGUE MANAGEMENT\nExecuting the plan\nGinzburg provides a dialogue-level appropriateness condition for querying:\nA question q can be successfully posed by A only if there does not exist a fact ¿\nsuch that ¿ 2 DGB(A) j FACTS and ¿ resolves q relative to UNPUB-MS(A).\nWhat this basically says is that one should not ask a question whose answer is already\nshared. On an individual level, each DP should make sure to not ask such questions. In\nIBiS1, this will be guaranteed by the removeFindout (",
      "context_after": "search .\n(rule 2.11) rule: exec consultDB\nclass: exec plan\npre: fst($/private/plan, consultDB(Q))\nn ! $/shared/com=B\n! $database :: consultDB(Q, B, C)\neff: 8\n>>>< add(/private/bel, C)\npop(/private/plan)\n>>>:\nThis rule takes all the propositions in /shared/com and given this looks up the answer\nto q in the database. The resulting proposition is stored in /private/bel."
    },
    {
      "title": "rule 2 .10) rule: removeFindout",
      "section": "2.8.6 Managing the plan",
      "page": 72,
      "content": "rule 2.10) rule: removeFindout\nclass: exec plan\nfst($/private/plan, flndout(Q))\npre: in($/shared/com, P)\n8\n>< $domain :: resolves(P, Q)\neff: >: pop(/private/plan)\nn\nThis rule removes a flndout(Q) action from the plan in case there is a resolving proposition\nP in /shared/com.\nIf there is a consultDB action topmost on the plan, (rule 2.11) will trigger a database",
      "context_before": "E MANAGEMENT\nExecuting the plan\nGinzburg provides a dialogue-level appropriateness condition for querying:\nA question q can be successfully posed by A only if there does not exist a fact ¿\nsuch that ¿ 2 DGB(A) j FACTS and ¿ resolves q relative to UNPUB-MS(A).\nWhat this basically says is that one should not ask a question whose answer is already\nshared. On an individual level, each DP should make sure to not ask such questions. In\nIBiS1, this will be guaranteed by the removeFindout (rule 2.10).\n(",
      "context_after": "search .\n(rule 2.11) rule: exec consultDB\nclass: exec plan\npre: fst($/private/plan, consultDB(Q))\nn ! $/shared/com=B\n! $database :: consultDB(Q, B, C)\neff: 8\n>>>< add(/private/bel, C)\npop(/private/plan)\n>>>:\nThis rule takes all the propositions in /shared/com and given this looks up the answer\nto q in the database. The resulting proposition is stored in /private/bel."
    },
    {
      "title": "rule 2 .11) will trigger a database",
      "section": "2.8.6 Managing the plan",
      "page": 72,
      "content": "rule 2.11) will trigger a database\nsearch .\n(rule 2.11) rule: exec consultDB\nclass: exec plan\npre: fst($/private/plan, consultDB(Q))\nn ! $/shared/com=B\n! $database :: consultDB(Q, B, C)\neff: 8\n>>>< add(/private/bel, C)\npop(/private/plan)\n>>>:\nThis rule takes all the propositions in /shared/com and given this looks up the answer\nto q in the database. The resulting proposition is stored in /private/bel.",
      "context_before": "answer is already\nshared. On an individual level, each DP should make sure to not ask such questions. In\nIBiS1, this will be guaranteed by the removeFindout (rule 2.10).\n(rule 2.10) rule: removeFindout\nclass: exec plan\nfst($/private/plan, flndout(Q))\npre: in($/shared/com, P)\n8\n>< $domain :: resolves(P, Q)\neff: >: pop(/private/plan)\nn\nThis rule removes a flndout(Q) action from the plan in case there is a resolving proposition\nP in /shared/com.\nIf there is a consultDB action topmost on the plan, (",
      "context_after": ""
    },
    {
      "title": "rule 2 .11) rule: exec consultDB",
      "section": "2.8.6 Managing the plan",
      "page": 72,
      "content": "rule 2.11) rule: exec consultDB\nclass: exec plan\npre: fst($/private/plan, consultDB(Q))\nn ! $/shared/com=B\n! $database :: consultDB(Q, B, C)\neff: 8\n>>>< add(/private/bel, C)\npop(/private/plan)\n>>>:\nThis rule takes all the propositions in /shared/com and given this looks up the answer\nto q in the database. The resulting proposition is stored in /private/bel.",
      "context_before": "vel, each DP should make sure to not ask such questions. In\nIBiS1, this will be guaranteed by the removeFindout (rule 2.10).\n(rule 2.10) rule: removeFindout\nclass: exec plan\nfst($/private/plan, flndout(Q))\npre: in($/shared/com, P)\n8\n>< $domain :: resolves(P, Q)\neff: >: pop(/private/plan)\nn\nThis rule removes a flndout(Q) action from the plan in case there is a resolving proposition\nP in /shared/com.\nIf there is a consultDB action topmost on the plan, (rule 2.11) will trigger a database\nsearch .\n(",
      "context_after": ""
    },
    {
      "title": "rule 2 .12).",
      "section": "2.9.1 Selecting an action from the plan",
      "page": 73,
      "content": "rule 2.12).\n(rule 2.12) rule: selectFromPlan\nclass: select action\nis empty($/private/agenda)\npre:\nfst($/private/plan, Action)\n(\neff: push(/private/agenda, Action)\nn",
      "context_before": "an be executed.\n2.9 IBiS1 selection module\nThe task of the selection module in IBiS1 is to determine the next move to be performed\nby the system. In IBiS1, this is a fairly trivial task, involving two parts: flrst, select an\nagenda item by either selecting to respond to an issue or taking the topmost action from\nthe plan and move it to the agenda; second, select a move which realizes this action.\n2.9.1 Selecting an action from the plan\nThe rule for selecting an action from the plan is shown in (",
      "context_after": ""
    },
    {
      "title": "rule 2 .12) rule: selectFromPlan",
      "section": "2.9.1 Selecting an action from the plan",
      "page": 73,
      "content": "rule 2.12) rule: selectFromPlan\nclass: select action\nis empty($/private/agenda)\npre:\nfst($/private/plan, Action)\n(\neff: push(/private/agenda, Action)\nn",
      "context_before": "d.\n2.9 IBiS1 selection module\nThe task of the selection module in IBiS1 is to determine the next move to be performed\nby the system. In IBiS1, this is a fairly trivial task, involving two parts: flrst, select an\nagenda item by either selecting to respond to an issue or taking the topmost action from\nthe plan and move it to the agenda; second, select a move which realizes this action.\n2.9.1 Selecting an action from the plan\nThe rule for selecting an action from the plan is shown in (rule 2.12).\n(",
      "context_after": ""
    },
    {
      "title": "rule 2 .13).",
      "section": "2.9.2 Selecting the ask move",
      "page": 74,
      "content": "rule 2.13).\n(rule 2.13) rule: selectAsk\nclass: select move\nfst($/private/agenda, flndout(Q)) or fst($/private/agenda,\npre:\nraise(Q))\n(\nadd(next moves, ask(Q))\neff:\nif do(fst($/private/plan, raise(A)), pop(/private/plan))\n(",
      "context_before": "ny question q which is part of the plan\n1\n(by virtue of a flndout action) will be such that it in(cid:176)uences q ; indeed, this is exactly the\n1\ndeflnition of in(cid:176)uences that we assume (see Section 2.8.2).\nAlso, the second part of the condition is guaranteed to hold by virtue of the rule re-\nmoveFindout described in Section 2.8.6. This rule removes an action flndout(q) from the\nplan in case there is a resolving proposition in /shared/com.\nThe rule for selecting an ask move is shown in (",
      "context_after": ""
    },
    {
      "title": "rule 2 .13) rule: selectAsk",
      "section": "2.9.2 Selecting the ask move",
      "page": 74,
      "content": "rule 2.13) rule: selectAsk\nclass: select move\nfst($/private/agenda, flndout(Q)) or fst($/private/agenda,\npre:\nraise(Q))\n(\nadd(next moves, ask(Q))\neff:\nif do(fst($/private/plan, raise(A)), pop(/private/plan))\n(",
      "context_before": "which is part of the plan\n1\n(by virtue of a flndout action) will be such that it in(cid:176)uences q ; indeed, this is exactly the\n1\ndeflnition of in(cid:176)uences that we assume (see Section 2.8.2).\nAlso, the second part of the condition is guaranteed to hold by virtue of the rule re-\nmoveFindout described in Section 2.8.6. This rule removes an action flndout(q) from the\nplan in case there is a resolving proposition in /shared/com.\nThe rule for selecting an ask move is shown in (rule 2.13).\n(",
      "context_after": ""
    },
    {
      "title": "rule 2 .14).",
      "section": "2.9.3 Selecting to respond to a question",
      "page": 75,
      "content": "rule 2.14).\n(rule 2.14) rule: selectRespond\nclass: select action\nis empty($/private/agenda)\nis empty($/private/plan)\n8\npre:\n>>>>>>>>< f\nin\nst\n(\n(\n$\n$\n/\n/\np\ns\nr\nh\ni\na\nv\nr\nat\ned\ne/\n/\nb\nq\ne\nu\nl\nd\n,\n,\nP\nQ\n)\n)\nnot in($/shared/com, P)\neff:\n>>>>>>>>:\np\n$\nu\nd\ns\no\nh(\nm\n/\na\np\ni\nr\nn\niv\n:\na\n:\nt\nre\ne\nl\n/\ne\na\nva\ng\nn\ne\nt\nn\n(P\nda\n,\n,\nQ\nr\n)\nespond(Q))\nn\nThe flrst two conditions check that there is nothing else that currently needs to be done.\nThe remaining conditions check that some question Q is topmost on QUD, the system\nknows a relevant answer P to Q which is not yet shared.",
      "context_before": "ed in Section 2.8.4\nguarantees that resolved issues are removed from QUD.\nWe divide the selection of an answer move into two steps: flrst, the selection of a respond\naction and second, the selection of an answer move. The motivation for this is that the\nanswer move could also be selected without being preceded by the selection of a respond\naction, in the case where the user asks a question which the system already knows the\nanswer to.\nThe rule for selecting to respond to a question is shown in (",
      "context_after": ""
    },
    {
      "title": "rule 2 .14) rule: selectRespond",
      "section": "2.9.3 Selecting to respond to a question",
      "page": 75,
      "content": "rule 2.14) rule: selectRespond\nclass: select action\nis empty($/private/agenda)\nis empty($/private/plan)\n8\npre:\n>>>>>>>>< f\nin\nst\n(\n(\n$\n$\n/\n/\np\ns\nr\nh\ni\na\nv\nr\nat\ned\ne/\n/\nb\nq\ne\nu\nl\nd\n,\n,\nP\nQ\n)\n)\nnot in($/shared/com, P)\neff:\n>>>>>>>>:\np\n$\nu\nd\ns\no\nh(\nm\n/\na\np\ni\nr\nn\niv\n:\na\n:\nt\nre\ne\nl\n/\ne\na\nva\ng\nn\ne\nt\nn\n(P\nda\n,\n,\nQ\nr\n)\nespond(Q))\nn\nThe flrst two conditions check that there is nothing else that currently needs to be done.\nThe remaining conditions check that some question Q is topmost on QUD, the system\nknows a relevant answer P to Q which is not yet shared.",
      "context_before": "2.8.4\nguarantees that resolved issues are removed from QUD.\nWe divide the selection of an answer move into two steps: flrst, the selection of a respond\naction and second, the selection of an answer move. The motivation for this is that the\nanswer move could also be selected without being preceded by the selection of a respond\naction, in the case where the user asks a question which the system already knows the\nanswer to.\nThe rule for selecting to respond to a question is shown in (rule 2.14).\n(",
      "context_after": ""
    },
    {
      "title": "rule 2 .15) rule: selectAnswer",
      "section": "2.9.4 Selecting the answer move",
      "page": 76,
      "content": "rule 2.15) rule: selectAnswer\nclass: select move\nfst($/private/agenda, respond(Q))\nin($/private/bel, P)\npre: 8\n>>>< not in($/shared/com, P)\n$domain :: relevant(”A, Q)\neff:\n>>>:\nadd(next moves, answer(P))\nn\nAgain, it may be argued that it is ine–cient to have to check the same conditions twice in\nthe case where selectAnswer is preceded by selectRespond. However, as we mentioned\nabove the respond action may also have been pushed on the agenda when integrating a\nuser ask move, and in this case the conditions need to be checked.",
      "context_before": "from his QUD as well. This rule\nalso has the nice (but perhaps not extremely useful) feature that it would cover rhetorical\nquestions as well as ordinary ones (however, this would require selection rules for asking\nquestions to which one already knows the answer).\n2.9.4 Selecting the answer move\nGiven that a respond(Q) action is on the agenda, and the system knows a relevant answer\nP to Q which is not yet shared, the rule in (2.18) selects an ask move with content P to\nbe pushed on next moves.\n(",
      "context_after": ""
    },
    {
      "title": "Procedure/Rule in 2.11 Sample dialogue with IBiS1",
      "section": "2.11 Sample dialogue with IBiS1",
      "page": 80,
      "content": "58 CHAPTER 2. BASIC ISSUE-BASED DIALOGUE MANAGEMENT\n2.10.3 Database resource\nThe database for the travel agency domain contains information about the price of trips,\nand information about visa regulations. If there is no database entry matching the infor-\nmation specifled in the query q, the database will return a fail(q) message.\n2.11 Sample dialogue with IBiS1\nIn this section we show a sample interaction with IBiS1. For the examples we have used\ntext-based input and output, but the system can also use speech. In this flrst dialogue we\nshow some update rules including their efiects, information states, and utterances.\n(dialogue 2.2)\nselectOther\nadd(next moves, greet)\n'\nS> Welcome to the travel agency!\ngetLatestMove\nset(/shared/lu/moves, set([greet]))\nset(/shared/lu/speaker, sys)\n‰\nintegrateGreet\nagenda = hi\nprivate = plan = hi\n2 2 3 3\nbel = fg\n6 4 com = fg 5 7\n6 7\n6 qud = hi 7\n6 shared = 2 3 7\n6 speaker = sys 7\n6 lu = 7\n6 6 moves = greet 7 7\n6 6 • ‚ 7 7\n4 4 5 5\n' “\nlatest speaker = sys\nlatest moves = greet\n2 3\nnext moves = fg\n' “\n6 program state = run 7\n6 7\n6 lexicon = lexicon travel english 7\n6 7\n6 domain = domain travel 7\n6 7\n6 database = database travel 7\n6 7\n4 5\nU> price information please",
      "context_before": "",
      "context_after": ""
    },
    {
      "title": "rule 2 .16) would need to",
      "section": "2.12. DISCUSSION 63",
      "page": 85,
      "content": "rule 2.16) would need to\nbe added (note that this rule requires QUD to be an open stack).\n(rule 2.16) rule: downdateQUD2\nclass: downdate qud\nin($/shared/qud, IssueQ)\npre: fst($/shared/qud, Q)\n8\n>< $domain :: resolves(Q, IssueQ)\neff: >: del(/shared/qud, IssueQ)\nn\nWe also need to deflne resolvedness conditions for issue-questions (for example, an issue-\nquestion cannot be resolved by an issue-question). In addition, rules for removing flndout\nand raise actions from the plan based on the contents of QUD would need to be added.",
      "context_before": "), the system will proceed to ask the alt-question. However, if the user addresses the\nwh-questiontheflndoutactionwillbepoppedofitheplansincethealt-questionhasalready\nbeen resolved.\nOne way of implementing this is to have rules which remove actions and questions which\nconcern what issue to address from the plan, agenda, and QUD based on the contents of\nQUD (rather than based only on the shared commitments, as has been done until now).\nFor example, for removing resolved issue-questions ofi QUD, (",
      "context_after": ""
    },
    {
      "title": "rule 2 .16) rule: downdateQUD2",
      "section": "2.12. DISCUSSION 63",
      "page": 85,
      "content": "rule 2.16) rule: downdateQUD2\nclass: downdate qud\nin($/shared/qud, IssueQ)\npre: fst($/shared/qud, Q)\n8\n>< $domain :: resolves(Q, IssueQ)\neff: >: del(/shared/qud, IssueQ)\nn\nWe also need to deflne resolvedness conditions for issue-questions (for example, an issue-\nquestion cannot be resolved by an issue-question). In addition, rules for removing flndout\nand raise actions from the plan based on the contents of QUD would need to be added.",
      "context_before": "uestiontheflndoutactionwillbepoppedofitheplansincethealt-questionhasalready\nbeen resolved.\nOne way of implementing this is to have rules which remove actions and questions which\nconcern what issue to address from the plan, agenda, and QUD based on the contents of\nQUD (rather than based only on the shared commitments, as has been done until now).\nFor example, for removing resolved issue-questions ofi QUD, (rule 2.16) would need to\nbe added (note that this rule requires QUD to be an open stack).\n(",
      "context_after": ""
    },
    {
      "title": "rule 2 .17) will pick up any question Q lying around on QUD",
      "section": "2.12.3 Reraising issues and sharing information",
      "page": 86,
      "content": "rule 2.17) will pick up any question Q lying around on QUD\nwhen the plan and agenda is empty, check if there is a plan for resolving it, and if so load\nthis plan.\n(rule 2.17) rule: recoverPlan\nclass: exec plan\nfst($/shared/qud, Q)\nis empty($/private/agenda)\npre: 8\n>>>< is empty($/private/plan)\n$domain :: plan(Q, Plan)\neff:\n>>>:\nset(/private/plan, Plan)\nn\nHowever, this solution has a problem. If, when dealing with a question q, the system\nasks a question q and the user does not answer this question but instead raises a new\nu\nquestion q , both q and q will remain on QUD when q has been resolved. Now, if the\n1 u 1\nuser simply answers q immediately after q has been resolved, everything is flne and the\nu 1\nsystem will reload the plan for dealing with q. However, if the user does not answer q ,\nu",
      "context_before": "the resources are set up to handle,\nas long as each issue is resolved before moving on to the next one. If the user asks q and\nthen asks q0 before q has been resolved, IBiS1 will forget its plan for dealing with q and\ninstead load the plan for dealing with q0. When q0 has been resolved, IBiS1 will wait for\na new question from the user. However, q is still on QUD, and by adding a simple rule we\ncould make IBiS1 reload the plan for dealing with q and get back to work on it.\nThe recoverPlan rule (",
      "context_after": ""
    },
    {
      "title": "rule 2 .17) rule: recoverPlan",
      "section": "2.12.3 Reraising issues and sharing information",
      "page": 86,
      "content": "rule 2.17) rule: recoverPlan\nclass: exec plan\nfst($/shared/qud, Q)\nis empty($/private/agenda)\npre: 8\n>>>< is empty($/private/plan)\n$domain :: plan(Q, Plan)\neff:\n>>>:\nset(/private/plan, Plan)\nn\nHowever, this solution has a problem. If, when dealing with a question q, the system\nasks a question q and the user does not answer this question but instead raises a new\nu\nquestion q , both q and q will remain on QUD when q has been resolved. Now, if the\n1 u 1\nuser simply answers q immediately after q has been resolved, everything is flne and the\nu 1\nsystem will reload the plan for dealing with q. However, if the user does not answer q ,\nu",
      "context_before": "ved, IBiS1 will forget its plan for dealing with q and\ninstead load the plan for dealing with q0. When q0 has been resolved, IBiS1 will wait for\na new question from the user. However, q is still on QUD, and by adding a simple rule we\ncould make IBiS1 reload the plan for dealing with q and get back to work on it.\nThe recoverPlan rule (rule 2.17) will pick up any question Q lying around on QUD\nwhen the plan and agenda is empty, check if there is a plan for resolving it, and if so load\nthis plan.\n(",
      "context_after": ""
    },
    {
      "title": "rule 2 .18) rule: reraiseIssue",
      "section": "2.12. DISCUSSION 65",
      "page": 87,
      "content": "rule 2.18) rule: reraiseIssue\nclass: select action\nfst($/shared/qud, Q)\npre:\nnot $domain :: plan(Q, SomePlan)\n(\neff: push(/private/agenda, raise(A))\nn\nIssues are divided up between those for which the system has an associated plan in its\ndomain resource and those for which it does not. For example, the \\price issue\" is one for\nwhich there is a plan: the system has to ask where the user wants to go, where from, when\netc. However, there is no plan associated with the question of where the user wants to go\nfrom. This question is simply part of the plan for the price issue. Thus, when the system\nflnds this question in the list of open issues (the flrst condition of this rule) and it flnds\nthat it does not have a plan for this issue (the second condition), it plans to reraise the\nquestion.\nTwo furthermodiflcationsareneededtomakethisworksmoothly. Firstly, whenaquestion\nis reraised that was previously on QUD, the simple stack structure of QUD will result in\ntwo instances of the same question being topmost on QUD. One way of solving this is to\nchange the datatype of /shared/qud into an \\open stack\" or \\stackset\"; this datatype\ncan be regarded as a mix of a stack and a set. The property of open stacks relevant to our\nproblem is that when some element x is pushed on a stack which already contains x (or\nan element uniflable with x), the resulting open stack will contain a single instance of x,\nwhich is also topmost on the open stack.\nSecondly, we need a rule for removing raise(Q) actions from the plan in case Q has already\nbeen resolved; this rule is similar to the removeFindout rule described in Section 2.8.6.",
      "context_before": "2.12. DISCUSSION 65\nthis question will be topmost on QUD and block recoverPlan from triggering. Because of\nthe simple structure of QUD, IBiS1 sees no reason to ask q again; after all, it is already\nu\nunder discussion, and the user is expected to provide an answer.\nThereraiseIssueshownin(rule2.18)ruleprovidesasolutiontothisproblem. Itreraises\nany questions on QUD which are not associated with any plan (i.e. which have been raised\npreviously by the system).\n(",
      "context_after": ""
    },
    {
      "title": "rule 2 .19) rule: removeRaise",
      "section": "2.12. DISCUSSION 65",
      "page": 88,
      "content": "rule 2.19) rule: removeRaise\nclass: exec plan\nfst($/private/plan, raise(A))\npre: in($/shared/com, B)\n8\n>< $domain :: resolves(B, A)\neff: >: pop(/private/plan)\nn\nThis rule is needed to avoid asking the same question twice in case it is flrst reraised and\nthen also included in a recovered plan.\nA sample dialogue involving the system reraising an issue and recovering a plan is shown\nin (dialogue 2.4). Incidentally, this dialogue also demonstrates information sharing be-\ntween dialogue plans; when the user asks about visa, the system already knows what the\ndestination city is andthusdoes not ask thisagain. By contrast, in VoiceXML (McGlashan\net al., 2001), user-initiated subdialogues will cause previous dialogue to be forgotten. Only\nif there is a pre-scripted, system-initiated transition from one form to another can the\nprevious dialogue be resumed after the subdialogue has been completed9.\n(dialogue 2.4)\nS> Welcome to the travel agency!\nU> price information please\nS> How do you want to travel?\nU> plane\nS> What city do you want to go to?\nU> paris\nS> What city do you want to go from?\nU> do i need a visa\ngetLatestMove\n9Information sharing in VoiceXML is only possible in the case where a form F calls another form F .\n1 2\nWhenF isflnishedandcontrolispassedbacktoF , informationmaybesentfromF toF . Information\n2 1 2 1\nsharing is not supported e.g. in cases where user initiative leads to the adoption of F while F is being\n2 1\nexecuted.",
      "context_before": "66 CHAPTER 2. BASIC ISSUE-BASED DIALOGUE MANAGEMENT\n(",
      "context_after": ""
    },
    {
      "title": "Procedure/Rule in 2.12.5 Additional plan constructs",
      "section": "2.12.5 Additional plan constructs",
      "page": 92,
      "content": "70 CHAPTER 2. BASIC ISSUE-BASED DIALOGUE MANAGEMENT\nS> What city do you want to go from?\nU> london\nS> What month do you want to leave?\nU> april\nS> What day do you want to leave?\nU> fifth\nS> What class did you have in mind?\nU>\nS> The price is 7654 crowns, economy class. The price is 456 crowns,\nbusiness class.\nA further possibility (that has not been implemented) is that the user provides a relevant\nbut not resolving answer to one or more questions raised by the system, e.g. by providing\na destination country when asked for a destination city. In this case, either the less speciflc\nanswer must match some other parameter in the database (e.g. if destination countries\nare included in addition to destination cities), or some inference must be performed. This\ninference may result in a disjunction of answers specifying parameters which are in the\ndatabase, e.g. the disjunction of all available destination cities in some specifled country.\nThis disjunction can then be used to search the database. Further database variations\ninclude requesting answers to more that one question at a time (e.g. \\I want information\nabout price information and departure dates for (cid:176)ights to Paris in April.\").\n2.12.5 Additional plan constructs\nIn IBiS1 we have used a very basic set of plan constructs. However, it is fairly straight-\nforward to add new constructs, by adding new objects of type PlanConstruct and update\nrules (of the class exec plan) for dealing with them. Some more complex constructs which\nare not used here but have been used in GoDiS, the predecessor of IBiS (see e.g. Larsson\nand Zaenen, 2000), are listed below, with brief explanations of what the corresponding\nupdate rules do.\n† if then(P, C) where P : proposition and C : PlanConstruct; if P is in /private/bel\nor /shared/com, then replace if then(P, C) with C ; otherwise, delete it\n1\n† if then else(P, C , C ) where P : proposition and C : PlanConstruct and C :\n1 2 1 2\nPlanConstruct; if P is in /private/bel or /shared/com, then replace if then(P,\nC) with C ; otherwise, replace it by C\n1 2\n† exec(fi), where fi : Action is an action such that there is a plan ƒ for doing fi; replace\nexec(fi) with ƒ (see Chapter 5 for a discussion of action-related plans)",
      "context_before": "",
      "context_after": ""
    },
    {
      "title": "Procedure/Rule in 2.12.6 Questions and answers vs. slots and flllers",
      "section": "2.12.6 Questions and answers vs. slots and flllers",
      "page": 93,
      "content": "2.12. DISCUSSION 71\n† hC ;:::;C i where C : PlanConstruct (1 • i • n); prepend C ;:::;C to the\n1 n i 1 n\n/private/plan fleld.\nTheseconstructsaddconsiderablytotheversatilityofdialogueplans, andallowe.g. asking\nwhether the user wants a return trip (formalized e.g. as a question ?return), and ask\nappropriate questions (return date etc.) only if the users gives a positive response (i.e. if\nthe proposition return is in /shared/com). A dialogue plan for accomplishing this is\nshown in (2.23).\n(2.23) issue : ?x.price(x)\nplan: h\nflndout(?x:means of transport(x)),\nflndout(?x:dest city(x)),\nflndout(?x:depart-city(x)),\nflndout(?x:depart-month(x)),\nflndout(?x:depart-day(x)),\nflndout(?x:class(x)),\nflndout(?return),\nif then( return, h flndout(?x:return-month(x)),\nflndout(?x:return-day(x)) i ),\nconsultDB(?x:price(x))\ni\n2.12.6 Questions and answers vs. slots and flllers\nIn principle, a slot in a form can be seen as a question, and a flller can be seen as an answer\nto that question. The result, a slot-flller pair, is the equivalent of a proposition. If the\nvalue of a slot is binary (0/1 or yes/no), the slot corresponds to a y/n-question; otherwise,\nit corresponds to a wh- or alternative question.\nFor example, in a travel agency setting a form-based system might have a form containing\na slot dest-city for the destination city; this would correspond to a question represented\nin lambda-calculus as ?x:dest-city(X) (\\What is the destination city?\"). A flller for this\nwould be e.g. paris, which would also constitute an answer to the question. The slot-\nflller pair dest-city=paris would then correspond to the FOL proposition resulting from\napplying the question to the answer, dest-city(paris).\nBut there are also important difierences between form-based and issue-based dialogue\nmanagement. For example, a single answer may be relevant to questions in several plans.\nThis enables information-sharing between plans, i.e. when executing a plan the system",
      "context_before": "",
      "context_after": ""
    },
    {
      "title": "Procedure/Rule in 3.1.1 Dialogue examples",
      "section": "3.1.1 Dialogue examples",
      "page": 98,
      "content": "76 CHAPTER 3. GROUNDING ISSUES\n3.1.1 Dialogue examples\nThe human-human dialogue excerpt1 in (3.1) shows two common kinds of feedback. J’s\n\\mm\" shows that J (thinks that he) understood P’s previous utterance; P’s \\pardon\"\nshows that P was not able to hear J’s previous utterance. The example also includes a\nhesitation sound (\\um\") from J. (P is a customer and J a travel agent.)\n(3.1) P : o˜m (.) (cid:176)yg ti paris\num (.) (cid:176)ight to paris\nJ : mm (.) ska du ha en returbiljett\nmm (.) do you want a return ticket\nP : va sa du\npardon\nJ : ska du ha en tur”a retur\ndo you want a round trip\nThe feedback in (3.1) consisted of conventionalized feedback words (\\mm\", \\pardon\").\nHowever, feedback may also be more explicit and repeat the central content of the previous\nutterance, as K’s second feedback utterance in (3.2).\n(3.2) B : ja ska va framme i [ go˜teborg ] e e ungefa˜r vi nietiden om\n1 1\nde flnns n”a tidit [ morgon(cid:176)yg ]\n2 2\nI need to be in Gothenburg er er around nine if there is an early\nmorning (cid:176)ight\nK : [ m ]\n1 1\nm\nK : [ vi ] nietiden m vi ska se\n2 2\nAround nine m let’s see\nThe function of an utterance answering a question is not primarily to give feedback, but\nrather to provide task-related information. However, an answer also shows that the pre-\nvious question was understood and integrated. Example (3.3) shows that feedback is\nsometimes given in reaction to a question before the question is answered.\n(3.3) J : sen m”aste du ha e s”an da˜r intenationellt studentkort ocks”a\nha du de\nthen you need one of those international student cards do you\nhave that\nP : mm na˜\nmm no\n1Exceptwherenoted,thehuman-humandialoguesinthischapterhavebeencollectedbytheUniversity\nofLundaspartoftheSDSproject. WequotetranscriptionsdoneinG˜oteborgaspartofthesameproject.\nThe (.) symbol indicates a pause.",
      "context_before": "",
      "context_after": ""
    },
    {
      "title": "Procedure/Rule in 3.2.3 Allwood: Interactive Communication Management",
      "section": "3.2.3 Allwood: Interactive Communication Management",
      "page": 105,
      "content": "3.2. BACKGROUND 83\nFor clarity, we reproduce the full protocol in a more schematic way:\ntry to flnd an answer resolving q (u) = ?x.content(u, x)\ncontent\n† no answer found ! push q (u) on QUD, produce q (u)-speciflc utterance\ncontent content\n† answer c found !\n{ c is a question ! consider q (c) = ?MAX-QUD(c)\naccept\n⁄ decide on \\no\" ! push q (c) on QUD, produce q (c)-speciflc utter-\naccept accept\nance [reject c]\n⁄ decide on \\yes\" ! push c on QUD, produce c-speciflc utterance [accept c]\n{ c is a proposition ! consider q (?c)\naccept\n⁄ no ! push q (?c) on QUD, produce q (?c)-speciflc utterance [reject\naccept accept\n?c as topic for discussion]\n⁄ yes ! consider ?c [accept ?c as topic for discussion]\n¢ no ! push ?c on QUD, produce ?c-speciflc utterance [reject c as fact]\n¢ yes ! add c to FACTS [accept c as fact]\nNote that there are a number of decisions that need to be made by B, and for each of these\ndecisions there is the possibility of rejecting u on the corresponding level. For a question,\nthere is only one way of rejecting it (once the content question has been resolved): to reject\nit as a question under discussion. This amounts to refusing to discuss the question. For\na proposition p, there are two difierent ways of rejecting it. Firstly, one may reject the\nissue \\whether p\" completely; this amounts to refusing to discuss whether p is true or not.\nAlternatively, one may accept \\whether p\" for discussion but reject p as a fact.\n3.2.3 Allwood: Interactive Communication Management\nAllwood(1995)usestheconceptof\\InteractiveCommunicationManagement\"todesignate\nall communication dealing with the management of dialogue interaction. This includes\nfeedback but also sequencing and turn management. Sequencing \\concerns the mecha-\nnisms, whereby a dialogue is structured into sequences, subactivities, topics etc. ...\".\nHere, we will use the term ICM as a general term for coordination of the common ground,\nwhich in an information state update approach comes to mean explicit signals enabling\ncoordination of updates to the common ground. While feedback is associated with speciflc\nutterances, ICM in general does not need to concern any speciflc utterance.",
      "context_before": "",
      "context_after": ""
    },
    {
      "title": "Procedure/Rule in 3.3.1 Levels of action in dialogue",
      "section": "3.3.1 Levels of action in dialogue",
      "page": 106,
      "content": "84 CHAPTER 3. GROUNDING ISSUES\nAs will be seen below, we will also be making use of various other parts of Allwood’s\n\\activity-based pragmatics\" (Allwood, 1995), including Allwood’s action level terminol-\nogy, the concept of Own Communication Management (OCM), and various distinctions\nconcerning ICM.\n3.3 Preliminary discussion\nIn the previous section we have seen examples of difierent ways of accounting for grounding\nand feedback. We feel that they all ofier useful insights, and that they together can serve\nas a basis for our further explorations.\nTherefore, in this section we will discuss the accounts presented in Section 3.2, relate them\nto each other, and establish some basic principles and terminological conventions.\n3.3.1 Levels of action in dialogue\nBoth Allwood (1995) and Clark (1996) distinguish four levels of action involved in com-\nmunication (S is the speaker of utterance u, H is the hearer/addressee). They use slightly\ndifierent terminologies; here we use Allwood’s terminology and add Clark’s (and, for the\nreaction level, also Ginzburg’s) corresponding terms in parenthesis. The deflnitions are\nmainly derived from Allwood.\n† Reaction (acceptance, consideration): whether H has integrated (the content of) u\n† Understanding (recognition): whether H understands u\n† Perception (identiflcation): whether H perceives u\n† Contact (attention): whether H and S have contact, i.e. if they have established a\nchannel of communication\nThese levels of action are involved in all dialogue, and to the extent that contact, per-\nception, understanding and acceptance can be said to be negotiated, all human-human\ndialogue has an element of negotiation built in. Note that the above list of levels is formu-\nlated in terms of the hearer’s perspective.\nGiventhatgroundingisconcernedwithalllevels,itfollowsthatfouraspectsofanutterance\nu in a dialogue between H and S can in principle be represented in the common ground,\none for each action level:",
      "context_before": "",
      "context_after": ""
    },
    {
      "title": "Procedure/Rule in 3.4.1 Classifying explicit feedback",
      "section": "3.4.1 Classifying explicit feedback",
      "page": 112,
      "content": "90 CHAPTER 3. GROUNDING ISSUES\nhaviourinthissenseincludesaskingandansweringtask-levelquestions,givinginstructions,\netc. (cf. the \\Core Speech Acts\" of Poesio and Traum, 1998). Answering a domain-level\nquestion (e.g. saying \\Paris\" in response to \\What city do you want to go to?\") certainly\ninvolves aspects of grounding and acceptance, since it shows that the question was under-\nstood and accepted. However, the primary function of a domain-level answer is to resolve\nthe question, not to show that it was understood and accepted.\nA single utterance may include both feedback and domain-level information. Clark talks\nabout communication of these two types of information as belonging to difierent \\tracks\":\ndomain-level information is on track 1 while feedback, and grounding-related communica-\ntion in general, is on track 2.\nIn this section we will attempt to give an overview of various aspects of feedback. We will\nreturn to sequencing ICM in Section 3.6.9.\n3.4.1 Classifying explicit feedback\nTo get an overview of the range of explicit feedback behaviour that exists in human-human\ndialogue, we will classify feedback according to four criteria. We will assume that DP S\nhas just uttered or is uttering u to DP H, when the feedback utterance f (uttered by H\nto S) occurs.\n† level of action / basic communicative function (contact, perception, understanding,\nreaction / acceptance)\n† polarity (positive / negative): whether f indicates contact / perception / under-\nstanding / acceptance or lack thereof\n† eliciting / non-eliciting: whether f is intended to evoke a response (e.g. a reformu-\nlation or a reason to accept some content)\n† form of f: single word, repetition etc.\n† content of f: object-level or meta-level\nThe action level criterion has been explained above; the others will be explained presently.\nThe criteria of basic communicative function, polarity, eliciting/non-eliciting, and surface\nform are all derived from Allwood et al. (1992) and Allwood (1995).",
      "context_before": "",
      "context_after": ""
    },
    {
      "title": "Procedure/Rule in 3.5.3 The cautious strategy",
      "section": "3.5.3 The cautious strategy",
      "page": 119,
      "content": "3.5. UPDATE STRATEGIES FOR GROUNDING 97\nsurface form of the utterance; to assume grounding on the understanding level is to update\nthe common ground with a semantic representation of the utterance. Finally, to assume\nan utterance has been grounded on the acceptance level is to update the common ground\nwith the intended efiects of the utterance (e.g. pushing a question on QUD). Thus, the\ngrounding assumption can be divided into four independent assumptions, one for each of\nthese levels; we will concentrate on the understanding and integration levels.\nThe independence of these assumptions means e.g. that it is possible to make an optimistic\nassumptionaboutunderstandingbutapessimisticoneaboutacceptance. Thiswouldmean\nassumingthatanutterancewasunderstoodassoonasitwasuttered, butrequiringpositive\nevidence before it is assumed to be accepted.\n3.5.3 The cautious strategy\nClark seems to assume that once an utterance has been grounded, there is no turning back;\nthe grounding assumption cannot be undone. That is, the moment information about an\nutterance is added to the common ground there is no way (short of general strategies for\nbeliefrevision)ofunderstandingnegativefeedbackandreacttoitbymodifyingorremoving\nthe grounded material.\nHowever, we believe that there is a difierence between assuming an utterance as grounded\n(added to the common ground) and giving up the possibility of modifying or correcting\nthe grounded material. This opens up a new kind of grounding strategy not included in\nClark’s account: the cautious strategy.\nFor a DP using a cautious strategy, it is possible to assume an utterance as being grounded,\nwhile still being able to understand and react appropriately to negative feedback. This\nrequires (1) that negative feedback, which is often underspecifled in the sense that it does\nnot explicitly identify which part of an utterance it concerns, can be correctly interpreted,\nand (2) that the DP can revise the common ground in a way which undoes all efiects of\nthe erroneous assumption that the utterance was grounded. A simple example is shown in\n(3.12).\n(3.12) A : Do I need a visa?\nA optimistically assumes that \\does A need a visa?\" is now\nunder discussion.\nB : Pardon?\nA correctly interprets B’s utterance as negative feedback (proba-\nbly on the perception level) regarding the previous utterance, and\nretracts the assumption that \\does A need a visa?\" is on QUD.",
      "context_before": "",
      "context_after": ""
    },
    {
      "title": "procedure in human-human",
      "section": "3.6.3 Issue-based grounding in IBiS",
      "page": 122,
      "content": "procedure in human-human\ndialogue. Second, because it only involves part of the full spectrum of feedback behaviour,\nexcluding e.g. acceptance-related feedback behaviour.",
      "context_before": "stinction is what we have here referred to as polarity: \\explicit\" veriflcation\nis neutral (and eliciting and interrogative) whereas \\implicit\" veriflcation is positive.\nGiven that veriflcation is a rather marginal phenomena in human-human dialogue, it is\nperhaps surprising that it is often the only aspect of feedback covered in dialogue systems\nliterature. Firstly, because itis usually notnecessary for humansto verify what they(think\nthey) have heard; that is, it is a rather uncommon grounding",
      "context_after": "3.6.3 Issue-based grounding in IBiS\nIn this section we outline a (partially) issue-based account of grounding in terms of infor-\nmation state updates, inspired by Ginzburg’s account of content questions and acceptance-\nquestions. However, we make signiflcant departures from Ginzburg’s account, for various\nreasons.\nA basic idea of the account used in IBiS2 is that meta-issues (the content and acceptance\nquestions) do not always have to be represented explicitly. However, in certain cases it is\nu"
    },
    {
      "title": "rule 3 .1).",
      "section": "3.6.6 Grounding of user utterances in IBiS2",
      "page": 132,
      "content": "rule 3.1).\n(rule 3.1) rule: integrateUsrAsk\nclass: integrate\n$/shared/lu/speaker==usr\nfst($/private/nim, ask(Q))\n8\npre: >>>>>><\nS\n$s\nc\nc\no\no\nre\nre\n>\n=\n0\nS\n.7\ncore\n$domain :: plan(Q, Plan)\n>>>>>>:\n1 pop(/private/nim)\n2 push(/private/agenda, icm:acc*pos)\n8\neff:\n>>>>>>>>>>>>>>><\n5\n3\n4\ni\na\ni\nf\nf\np\nd\nd\nd\nu\nd\no\no\ns\n(\nh\n(\n(\n/\ni\nS\ns\n(\nn\n/\nh\nc\n(\np\no\na\n$\nr\nr\n/\nr\ne\ns\ni\ne\nv\nh\n•\nd\na\na\nt\n/\nr\n0\nl\ne\n.\ne\nu\n9\n/\nd\n,\n/\na\n/\nm\ng\nq\ne\no\nu\nn\nv\nd\nd\ne\n,\na\ns\nQ\n,\n,\na\n)\nic\ns\nm\na\nk\nn\n(\n:\nQ\nd\nun\n)\nn\n)\nd\no\n*\nt\npo\nfs\ns\nt\n:u\n($\nsr\n/\n*\ns\ni\nh\nss\na\nu\nr\ne(\ne\nQ\nd\n)\n/\n)\nq\n)\nud, Q),\npush(/private/agenda, icm:reraise:Q))\n>>>>>>>>>>>>>>>:\n6\n7\np\np\nu\nu\ns\ns\nh\nh\n(\n(\n/\n/\ns\np\nh\nr\na\niv\nr\na\ne\nt\nd\ne\n/\n/\nq\na\nu\ng\nd\ne\n,\nn\nQ\nda\n)\n, respond(Q))\nThe flrst two conditions picks out a user ask move on nim. The third and fourth con-\nditions check the recognition score of the utterance and if it is higher than 0.7 (T ), the\n2\nrule proceeds to check for acceptability. If the score is too low, the move should not be\noptimistically integrated; instead, a pessimistic grounding strategy should be applied and\ninterrogative feedback selected (see below).\nThe flfth condition checks for acceptability, i.e. that the system is able to deal with this\nquestion, i.e. that there is a corresponding plan in the domain resource. If not, the\nintegration rule will not trigger and the ask move will remain on nim until the selection\nphase, where it will give rise to an issue rejection (see Section 3.6.6).\nThe flrst update pops the integrated move ofi nim. In update 2, positive integration\nfeedback is added to the agenda, to indicate that the system can integrate the ask-move.\nUpdate 3 adds the move to /shared/lu/moves, thereby re(cid:176)ecting the optimistic ground-\ning assumption on the understanding level. In update 4, positive understanding feedback\nis selected unless the score is higher than 0.9 (T ).\n1",
      "context_before": "110 CHAPTER 3. GROUNDING ISSUES\nIn addition to being checked for relevance, contentful moves are checked for integratability\n(acceptability) and if these conditions are not fulfllled the move will not be integrated;\ninstead, it will give rise to negative acceptance feedback as explained in Section 3.6.6.\nIntegration of user ask move The integration rule for user ask move implementing the\noptimistic grounding strategy is shown in (",
      "context_after": ""
    },
    {
      "title": "rule 3 .1) rule: integrateUsrAsk",
      "section": "3.6.6 Grounding of user utterances in IBiS2",
      "page": 132,
      "content": "rule 3.1) rule: integrateUsrAsk\nclass: integrate\n$/shared/lu/speaker==usr\nfst($/private/nim, ask(Q))\n8\npre: >>>>>><\nS\n$s\nc\nc\no\no\nre\nre\n>\n=\n0\nS\n.7\ncore\n$domain :: plan(Q, Plan)\n>>>>>>:\n1 pop(/private/nim)\n2 push(/private/agenda, icm:acc*pos)\n8\neff:\n>>>>>>>>>>>>>>><\n5\n3\n4\ni\na\ni\nf\nf\np\nd\nd\nd\nu\nd\no\no\ns\n(\nh\n(\n(\n/\ni\nS\ns\n(\nn\n/\nh\nc\n(\np\no\na\n$\nr\nr\n/\nr\ne\ns\ni\ne\nv\nh\n•\nd\na\na\nt\n/\nr\n0\nl\ne\n.\ne\nu\n9\n/\nd\n,\n/\na\n/\nm\ng\nq\ne\no\nu\nn\nv\nd\nd\ne\n,\na\ns\nQ\n,\n,\na\n)\nic\ns\nm\na\nk\nn\n(\n:\nQ\nd\nun\n)\nn\n)\nd\no\n*\nt\npo\nfs\ns\nt\n:u\n($\nsr\n/\n*\ns\ni\nh\nss\na\nu\nr\ne(\ne\nQ\nd\n)\n/\n)\nq\n)\nud, Q),\npush(/private/agenda, icm:reraise:Q))\n>>>>>>>>>>>>>>>:\n6\n7\np\np\nu\nu\ns\ns\nh\nh\n(\n(\n/\n/\ns\np\nh\nr\na\niv\nr\na\ne\nt\nd\ne\n/\n/\nq\na\nu\ng\nd\ne\n,\nn\nQ\nda\n)\n, respond(Q))\nThe flrst two conditions picks out a user ask move on nim. The third and fourth con-\nditions check the recognition score of the utterance and if it is higher than 0.7 (T ), the\n2\nrule proceeds to check for acceptability. If the score is too low, the move should not be\noptimistically integrated; instead, a pessimistic grounding strategy should be applied and\ninterrogative feedback selected (see below).\nThe flfth condition checks for acceptability, i.e. that the system is able to deal with this\nquestion, i.e. that there is a corresponding plan in the domain resource. If not, the\nintegration rule will not trigger and the ask move will remain on nim until the selection\nphase, where it will give rise to an issue rejection (see Section 3.6.6).\nThe flrst update pops the integrated move ofi nim. In update 2, positive integration\nfeedback is added to the agenda, to indicate that the system can integrate the ask-move.\nUpdate 3 adds the move to /shared/lu/moves, thereby re(cid:176)ecting the optimistic ground-\ning assumption on the understanding level. In update 4, positive understanding feedback\nis selected unless the score is higher than 0.9 (T ).\n1",
      "context_before": "110 CHAPTER 3. GROUNDING ISSUES\nIn addition to being checked for relevance, contentful moves are checked for integratability\n(acceptability) and if these conditions are not fulfllled the move will not be integrated;\ninstead, it will give rise to negative acceptance feedback as explained in Section 3.6.6.\nIntegration of user ask move The integration rule for user ask move implementing the\noptimistic grounding strategy is shown in (rule 3.1).\n(",
      "context_after": ""
    },
    {
      "title": "rule 3 .2).",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 111",
      "page": 133,
      "content": "rule 3.2).\n(rule 3.2) rule: selectIcmOther\nclass: select icm\nin($/private/agenda, icm:A)\npre:\nnot in($next moves, B) and B=ask(C)\n(\npush(next moves, icm:A)\neff:\ndel(/private/agenda, icm:A)\n(\nDialogue example: integrating user ask-move The dialogue below shows how a user\nask move with a score of 0.76 is successfully integrated, and positive understanding and\nacceptance feedback is produced.\n(dialogue 3.3)\nS> Welcome to the travel agency!\nU> price information please [0.76]\ngetLatestMoves\nset(/private/nim, oqueue([ask(?A.price(A))]))\nset(/shared/lu/speaker, usr)\n8\nclear(/shared/lu/moves)\n>><\nset(/shared/pm, set([greet]))\nintegrateUsrAsk\n>>:",
      "context_before": "arded as a\nshortcut for reasoning about obligations and intentions; when accepting a user question,\nthus accepting the obligation to try to respond to it, the system will automatically intend\nto respond to it.\nDefault ICM move selection rule The role of the ICM move selection rules is to\nadd moves to be generated to the next moves TIS variable based on the contents of\nthe agenda. ICM which is added to the agenda by the update module will be moved to\nnext moves by the default ICM selection rule (",
      "context_after": ""
    },
    {
      "title": "rule 3 .2) rule: selectIcmOther",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 111",
      "page": 133,
      "content": "rule 3.2) rule: selectIcmOther\nclass: select icm\nin($/private/agenda, icm:A)\npre:\nnot in($next moves, B) and B=ask(C)\n(\npush(next moves, icm:A)\neff:\ndel(/private/agenda, icm:A)\n(\nDialogue example: integrating user ask-move The dialogue below shows how a user\nask move with a score of 0.76 is successfully integrated, and positive understanding and\nacceptance feedback is produced.\n(dialogue 3.3)\nS> Welcome to the travel agency!\nU> price information please [0.76]\ngetLatestMoves\nset(/private/nim, oqueue([ask(?A.price(A))]))\nset(/shared/lu/speaker, usr)\n8\nclear(/shared/lu/moves)\n>><\nset(/shared/pm, set([greet]))\nintegrateUsrAsk\n>>:",
      "context_before": "hortcut for reasoning about obligations and intentions; when accepting a user question,\nthus accepting the obligation to try to respond to it, the system will automatically intend\nto respond to it.\nDefault ICM move selection rule The role of the ICM move selection rules is to\nadd moves to be generated to the next moves TIS variable based on the contents of\nthe agenda. ICM which is added to the agenda by the update module will be moved to\nnext moves by the default ICM selection rule (rule 3.2).\n(",
      "context_after": ""
    },
    {
      "title": "rule 3 .3).",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 111",
      "page": 134,
      "content": "rule 3.3).\n(rule 3.3) rule: selectIcmUndIntAsk\nclass: select icm\n$/shared/lu/speaker==usr\npre: fst($/private/nim, ask(Q))\n8\n>< $score • 0.7\npop(/private/nim)\neff:\n>:\npush(next moves, icm:und*int:usr*issue(Q))\n(",
      "context_before": "next moves, icm:acc*pos)\ndel(/private/agenda, icm:acc*pos)\n‰\nselectIcmOther\npush(next moves, icm:und*pos:usr*issue(?A.price(A)))\ndel(/private/agenda, icm:und*pos:usr*issue(?A.price(A)))\n‰\nselectIcmOther\nselectAsk\nS> Okay. You want to know about price. Lets see. How do you want to\ntravel?\nInterrogative understanding feedback for user ask move If a user ask move cannot\nbe assumed to be understood because of a low recognition score, interrogative feedback on\nthe understanding level is selected by (",
      "context_after": ""
    },
    {
      "title": "rule 3 .3) rule: selectIcmUndIntAsk",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 111",
      "page": 134,
      "content": "rule 3.3) rule: selectIcmUndIntAsk\nclass: select icm\n$/shared/lu/speaker==usr\npre: fst($/private/nim, ask(Q))\n8\n>< $score • 0.7\npop(/private/nim)\neff:\n>:\npush(next moves, icm:und*int:usr*issue(Q))\n(",
      "context_before": "icm:acc*pos)\ndel(/private/agenda, icm:acc*pos)\n‰\nselectIcmOther\npush(next moves, icm:und*pos:usr*issue(?A.price(A)))\ndel(/private/agenda, icm:und*pos:usr*issue(?A.price(A)))\n‰\nselectIcmOther\nselectAsk\nS> Okay. You want to know about price. Lets see. How do you want to\ntravel?\nInterrogative understanding feedback for user ask move If a user ask move cannot\nbe assumed to be understood because of a low recognition score, interrogative feedback on\nthe understanding level is selected by (rule 3.3).\n(",
      "context_after": ""
    },
    {
      "title": "rule 3 .4) is similar to that for ask moves, except that answers are checked for relevance",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 113",
      "page": 135,
      "content": "rule 3.4) is similar to that for ask moves, except that answers are checked for relevance\nas well as reliability and acceptability.\n(rule 3.4) rule: integrateUsrAnswer\nclass: integrate\n1 fst($/private/nim, answer(A))\n2 $/shared/lu/speaker==usr\n8\npre:\n>>>>>>>>>>>>><\n5\n4\n3\nf\nS\n!\ns\nc\nt\n$\n(\no\ns\n$\nr\nc\n/\ne\no\ns\n>\nr\nh\ne\na\n0\n=\nr\n.7\ne\nS\nd\nco\n/\nr\nq\ne\nud, Q)\n6 $domain :: relevant(A, Q)\n>>>>>>>>>>>>>:\n1\n7\n8\np\n$\n$\no\nd\nd\np\na\no\n(\nt\nm\n/\na\np\na\nb\nr\ni\na\nn\niv\ns\n:\na\ne\n:\nt\n:\nc\ne\n:\no\n/\nm\nv\nn\na\nb\ni\nl\nm\ni\ni\nd\nn\n)\nD\ne(\nB\nQ\np\n,\na\nA\nra\n,\nm\nP\ne\n)\nter(P) or P=not(X)\n2 add(/shared/lu/moves, answer(P))\n8\neff:\n>>>>>>>>< 3\n4\np\nif\nu\nd\ns\no\nh\n(\n(\nS\n/p\nco\nr\nr\niv\ne\na\n•\nte\n0\n/\n.9\nag\na\ne\nn\nn\nd\nd\nA\na,\n6=\nic\ny\nm\nes\n:a\na\nc\nn\nc*\nd\np\nA\nos)\n6= no,\npush(/private/agenda, icm:und*pos:usr*P))\n>>>>>>>>: 5 add(/shared/com, P)\nConditions 1-4 are similar to those for the integrateUsrAsk rule. The relevance of the\ncontent of the answer to a question on QUD is checked in condition 6.\nThe acceptability condition in the condition 8 makes sure that the propositional content\nresulting from combining the question topmost on QUD with the content of the answer-\nmove is either\n† a valid database parameter, or\n† a negated proposition",
      "context_before": "ead, we follow the general\nphilosophy of IBiS of trying to keep our representation as simple as possible as long as\nit works. The interrogative feedback selected in the second update will, in a sense, take\nover the function of the original move; if the feedback is answered positively, the end result\nwill be the same as if the ask move had been integrated immediately (see Section 3.6.6 for\nfurther explanation).\nIntegration of user answer move The integration rule for user answer moves, shown in\n(",
      "context_after": ""
    },
    {
      "title": "rule 3 .4) rule: integrateUsrAnswer",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 113",
      "page": 135,
      "content": "rule 3.4) rule: integrateUsrAnswer\nclass: integrate\n1 fst($/private/nim, answer(A))\n2 $/shared/lu/speaker==usr\n8\npre:\n>>>>>>>>>>>>><\n5\n4\n3\nf\nS\n!\ns\nc\nt\n$\n(\no\ns\n$\nr\nc\n/\ne\no\ns\n>\nr\nh\ne\na\n0\n=\nr\n.7\ne\nS\nd\nco\n/\nr\nq\ne\nud, Q)\n6 $domain :: relevant(A, Q)\n>>>>>>>>>>>>>:\n1\n7\n8\np\n$\n$\no\nd\nd\np\na\no\n(\nt\nm\n/\na\np\na\nb\nr\ni\na\nn\niv\ns\n:\na\ne\n:\nt\n:\nc\ne\n:\no\n/\nm\nv\nn\na\nb\ni\nl\nm\ni\ni\nd\nn\n)\nD\ne(\nB\nQ\np\n,\na\nA\nra\n,\nm\nP\ne\n)\nter(P) or P=not(X)\n2 add(/shared/lu/moves, answer(P))\n8\neff:\n>>>>>>>>< 3\n4\np\nif\nu\nd\ns\no\nh\n(\n(\nS\n/p\nco\nr\nr\niv\ne\na\n•\nte\n0\n/\n.9\nag\na\ne\nn\nn\nd\nd\nA\na,\n6=\nic\ny\nm\nes\n:a\na\nc\nn\nc*\nd\np\nA\nos)\n6= no,\npush(/private/agenda, icm:und*pos:usr*P))\n>>>>>>>>: 5 add(/shared/com, P)\nConditions 1-4 are similar to those for the integrateUsrAsk rule. The relevance of the\ncontent of the answer to a question on QUD is checked in condition 6.\nThe acceptability condition in the condition 8 makes sure that the propositional content\nresulting from combining the question topmost on QUD with the content of the answer-\nmove is either\n† a valid database parameter, or\n† a negated proposition",
      "context_before": "errogative feedback selected in the second update will, in a sense, take\nover the function of the original move; if the feedback is answered positively, the end result\nwill be the same as if the ask move had been integrated immediately (see Section 3.6.6 for\nfurther explanation).\nIntegration of user answer move The integration rule for user answer moves, shown in\n(rule 3.4) is similar to that for ask moves, except that answers are checked for relevance\nas well as reliability and acceptability.\n(",
      "context_after": ""
    },
    {
      "title": "rule 3 .5).",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 113",
      "page": 136,
      "content": "rule 3.5).\n(If the question is not acceptable it will instead be rejected; see Section 3.6.6).\n(rule 3.5) rule: selectIcmUndIntAnswer\nclass: select icm\nfst($/private/nim, answer(A))\n$/shared/lu/speaker==usr\n8\npre:\n>>>>>>>>< $\nfs\ns\nt\nc\n($\no\n/\nr\ns\ne\nha\n•\nre\n0.\nd\n7\n/qud, B)\n$domain :: relevant(A, B)\neff:\n>>>>>>>>:\np\n$\no\nd\np\no\n(\nm\n/p\na\nr\nin\niva\n::\nt\nc\ne\no\n/\nm\nn\nb\nim\nin\n)\ne(B, A, C)\npush(next moves, icm:und*int:usr*C)\n(\nThe conditions check that there is a user answer move on nim whose content is relevant\nto and combines with a question on QUD, and that the recognition score was less than or\nequal to 0.7. If these conditions are true, the move is popped ofi nim and interrogative\nunderstanding feedback is selected.\nIntegrating and responding to interrogative feedback\nIntegrating interrogative understanding feedback As explained in Section 3.6.3,\nInterrogative feedback raises understanding questions. This is re(cid:176)ected in (rule 3.6).",
      "context_before": "n\nthat these are easily recognized; if this is not the case, their special status should be\nremoved. Finally, update 5 adds the proposition resulting from combining the question on\nQUD with the content of the answer move to the shared commitments.\nInterrogative understanding feedback for user ask move Ifauseraskmovereceives\na low score (lower than T , which is here set to 0.7) and the question raised by the move is\n2\nacceptable to the system, interrogative understanding feedback is selected by (",
      "context_after": ""
    },
    {
      "title": "rule 3 .5) rule: selectIcmUndIntAnswer",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 113",
      "page": 136,
      "content": "rule 3.5) rule: selectIcmUndIntAnswer\nclass: select icm\nfst($/private/nim, answer(A))\n$/shared/lu/speaker==usr\n8\npre:\n>>>>>>>>< $\nfs\ns\nt\nc\n($\no\n/\nr\ns\ne\nha\n•\nre\n0.\nd\n7\n/qud, B)\n$domain :: relevant(A, B)\neff:\n>>>>>>>>:\np\n$\no\nd\np\no\n(\nm\n/p\na\nr\nin\niva\n::\nt\nc\ne\no\n/\nm\nn\nb\nim\nin\n)\ne(B, A, C)\npush(next moves, icm:und*int:usr*C)\n(\nThe conditions check that there is a user answer move on nim whose content is relevant\nto and combines with a question on QUD, and that the recognition score was less than or\nequal to 0.7. If these conditions are true, the move is popped ofi nim and interrogative\nunderstanding feedback is selected.\nIntegrating and responding to interrogative feedback\nIntegrating interrogative understanding feedback As explained in Section 3.6.3,\nInterrogative feedback raises understanding questions. This is re(cid:176)ected in (rule 3.6).",
      "context_before": "ved. Finally, update 5 adds the proposition resulting from combining the question on\nQUD with the content of the answer move to the shared commitments.\nInterrogative understanding feedback for user ask move Ifauseraskmovereceives\na low score (lower than T , which is here set to 0.7) and the question raised by the move is\n2\nacceptable to the system, interrogative understanding feedback is selected by (rule 3.5).\n(If the question is not acceptable it will instead be rejected; see Section 3.6.6).\n(",
      "context_after": ""
    },
    {
      "title": "rule 3 .6) rule: integrateUndIntICM",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 115",
      "page": 137,
      "content": "rule 3.6) rule: integrateUndIntICM\nclass: integrate\npre: fst($/private/nim, icm:und*int:DP*C)\nn pop(/private/nim)\neff: add(/shared/lu/moves, icm:und*int:DP*C)\n8\n>< push(/shared/qud, und(DP*C))\n>:\nThe condition simply checks that there is an icm:und*int:DP*C move on nim, which is\nthen popped ofi by the flrst update and added to /shared/lu/moves by the second\nupdate. The third update pushes the understanding question ?und(DP*C) on QUD.\nIntegrating positive answer to understanding-question When the system raises\nan understanding question (e.g. by saying \\To Paris, is that correct?\"), the user can either\nsay \\yes\" or \\no\". (The case where the user does not give a relevant answer to the inter-\nrogative feedback is treated in Section 3.6.8). In IBiS2, we do not represent propositions\nrelated to the understanding of utterances in the same way as other propositions (which\nare stored in /shared/com). Therefore, special rules are needed for dealing with answers\nto understanding-questions.\nThe rule for integrating a negative answer to an understanding-question is shown in (rule\n3.7).\n(rule 3.7) rule: integrateNegIcmAnswer",
      "context_before": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 115\n(",
      "context_after": "class: integrate\nfst($/private/nim, answer(no))\npre:\nfst($/shared/qud, und(DP*C))\n(\npop(/private/nim)\nadd(/shared/lu/moves, answer(und(DP*C)))\neff: 8\n>>>< pop(/shared/qud)\npush(/private/agenda, icm:und*pos:DP*not(C))\n>>>:\nThe conditions check that there’s an answer(yes) move on nim and an understanding-\nquestion on QUD. The flrst three updates establish the move as shared and pop the\nunderstanding-question ofi QUD. Finally, positive feedback is selected to indicate that\nthe system has understoo"
    },
    {
      "title": "3 .7).",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 115",
      "page": 137,
      "content": "rule\n3.7).\n(rule 3.7) rule: integrateNegIcmAnswer\nclass: integrate\nfst($/private/nim, answer(no))\npre:\nfst($/shared/qud, und(DP*C))\n(\npop(/private/nim)\nadd(/shared/lu/moves, answer(und(DP*C)))\neff: 8\n>>>< pop(/shared/qud)\npush(/private/agenda, icm:und*pos:DP*not(C))\n>>>:\nThe conditions check that there’s an answer(yes) move on nim and an understanding-\nquestion on QUD. The flrst three updates establish the move as shared and pop the\nunderstanding-question ofi QUD. Finally, positive feedback is selected to indicate that\nthe system has understood that the assumed interpretation C was incorrect.\nIntegrating positive answer to understanding question The rule for integrating a\npositive answer to an understanding-question is shown in (rule 3.8).",
      "context_before": "rect?\"), the user can either\nsay \\yes\" or \\no\". (The case where the user does not give a relevant answer to the inter-\nrogative feedback is treated in Section 3.6.8). In IBiS2, we do not represent propositions\nrelated to the understanding of utterances in the same way as other propositions (which\nare stored in /shared/com). Therefore, special rules are needed for dealing with answers\nto understanding-questions.\nThe rule for integrating a negative answer to an understanding-question is shown in (",
      "context_after": ""
    },
    {
      "title": "rule 3 .7) rule: integrateNegIcmAnswer",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 115",
      "page": 137,
      "content": "rule 3.7) rule: integrateNegIcmAnswer\nclass: integrate\nfst($/private/nim, answer(no))\npre:\nfst($/shared/qud, und(DP*C))\n(\npop(/private/nim)\nadd(/shared/lu/moves, answer(und(DP*C)))\neff: 8\n>>>< pop(/shared/qud)\npush(/private/agenda, icm:und*pos:DP*not(C))\n>>>:\nThe conditions check that there’s an answer(yes) move on nim and an understanding-\nquestion on QUD. The flrst three updates establish the move as shared and pop the\nunderstanding-question ofi QUD. Finally, positive feedback is selected to indicate that\nthe system has understood that the assumed interpretation C was incorrect.\nIntegrating positive answer to understanding question The rule for integrating a\npositive answer to an understanding-question is shown in (rule 3.8).",
      "context_before": "user can either\nsay \\yes\" or \\no\". (The case where the user does not give a relevant answer to the inter-\nrogative feedback is treated in Section 3.6.8). In IBiS2, we do not represent propositions\nrelated to the understanding of utterances in the same way as other propositions (which\nare stored in /shared/com). Therefore, special rules are needed for dealing with answers\nto understanding-questions.\nThe rule for integrating a negative answer to an understanding-question is shown in (rule\n3.7).\n(",
      "context_after": ""
    },
    {
      "title": "rule 3 .8) rule: integratePosIcmAnswer",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 115",
      "page": 138,
      "content": "rule 3.8) rule: integratePosIcmAnswer\nclass: integrate\nfst($/private/nim, answer(yes))\npre:\nfst($/shared/qud, und(DP*Content))\n(\npop(/private/nim)\nadd(/shared/lu/moves, answer(und(DP*Content)))\n8\neff:\n>>>>>>>>>>><\ni\np\nf\no\nt\np\np\nh\n(\nu\ne\n/\nn\ns\ns\nh\nh\ne\n(\na\nl\n/\ns\nr\ns\ne\nh\n(\ne\nC\na\nd\no\nr\n/\nn\nq\ne\nt\nd\nu\ne\n/\nd\nn\nq\nt\n)\n=\nud\nis\n,\nsu\nQ\ne(\n)\nQ), [\npush(/private/agenda, respond(Q)) ],\n>>>>>>>>>>>:\nadd(/shared/com, Content))\nThe conditions and the flrst three updates are similar to those in the integrateNegIc-\nmAnswer rule. The flnal (conditionalized) update integrates the content C. If the \\orig-\ninal\" move (the move which caused the interrogative feedback to be produced in the flrst\nplace) was ask, C will be a proposition issue(Q). Consequently, integrating this propo-\nsitions has the same efiects as integrating an ask-move: pushing the question Q on QUD\nand pushing the action respond(Q) on the agenda. If the proposition is not of this type, it\nis simply added to /shared/com.\nDialogue example: positive and negative response to interrogative feedback In\nthe following dialogue, the system produces interrogative understanding feedback for two\nuser utterances, one containing an ask move and the other containing an answer move. The\nflrst interrogative feedback is answered positively and the second negatively.\n(dialogue 3.4)\nU> price information please [0.65]\ngetLatestMoves\nagenda = hhii\nprivate = plan = hi\n2 2 3 3\nnim = ask(?A.price(A))\n6 4 com = fg 5 7\n6 ›› fifi 7\n6 qud = hi 7\n6 shared = 2 3 7\n6 speaker = usr 7\n6 lu = 7\n6 6 moves = fg 7 7\n6 6 • ‚ 7 7\n4 4 5 5\nbackupShared\nselectIcmUndIntAsk\npop(/private/nim)\npush(/private/agenda, icm:und*int:usr*issue(?A.price(A)))\n‰",
      "context_before": "116 CHAPTER 3. GROUNDING ISSUES\n(",
      "context_after": ""
    },
    {
      "title": "rule 3 .9).",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 119",
      "page": 142,
      "content": "rule 3.9).\n(rule 3.9) rule: selectIcmConNeg\nclass: select icm\n$input= ‘TIMED OUT’\npre: is empty($next moves)\n8\n>< is empty($/private/agenda)\neff: >: push(next moves, icm:con*neg)\nn\nUnless the system has something else to do, this will trigger negative contact ICM by the\nsystem, realisede.g. as\\Ididn’thearanythingfromyou.\". Thepurposeofthisisprimarily\nto indicate to the user that nothing was heard, but perhaps also to elicit some response\nfrom the user to show that she is still there. Admittedly, this is a rather undeveloped\naspect of ICM in the current IBiS implementation, and alternative strategies could be\nexplored. For example, the system could increase the timeout span successively instead of\nrepeating negative contact ICM every flve seconds. Other formulations with more focus on\nthe eliciting function could also be considered, e.g. \\Are you there?\" or simply \\Hello?\".\nThe second and third condition check that nothing is on the agenda or in next moves.\nThe motivation for this is that there is no reason to address contact explicitly in this case,\nsince any utterance from the system implicitly tries to establish contact.\nDefault ICM integration rule Since contact is not explicitly represented in the infor-\nmation state proper, integration of negative system contact ICM moves have no speciflc\nefiect on the information state, and are therefore integrated by the default ICM integration\nrule shown in (rule 3.10). Unless an ICM move has a speciflc integration rule deflned for",
      "context_before": "n the\nperception level, e.g. \\I didn’t hear what you said.\".\nWe have conflgured the input module to set the input variable to ‘TIMED OUT’ if nothing\nis detected, and to ‘FAIL’ if something unrecognizable was detected.\nNegative system contact feedback If the speech recognizer does not get any input\nwithin a certain time frame (specifled by the timeout TIS variable), the input variable\nwill be set to ‘TIMED OUT’ by the input module. The rule for selection of negative contact\nfeedback is shown in (",
      "context_after": "it, it will be integrated by this rule."
    },
    {
      "title": "rule 3 .9) rule: selectIcmConNeg",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 119",
      "page": 142,
      "content": "rule 3.9) rule: selectIcmConNeg\nclass: select icm\n$input= ‘TIMED OUT’\npre: is empty($next moves)\n8\n>< is empty($/private/agenda)\neff: >: push(next moves, icm:con*neg)\nn\nUnless the system has something else to do, this will trigger negative contact ICM by the\nsystem, realisede.g. as\\Ididn’thearanythingfromyou.\". Thepurposeofthisisprimarily\nto indicate to the user that nothing was heard, but perhaps also to elicit some response\nfrom the user to show that she is still there. Admittedly, this is a rather undeveloped\naspect of ICM in the current IBiS implementation, and alternative strategies could be\nexplored. For example, the system could increase the timeout span successively instead of\nrepeating negative contact ICM every flve seconds. Other formulations with more focus on\nthe eliciting function could also be considered, e.g. \\Are you there?\" or simply \\Hello?\".\nThe second and third condition check that nothing is on the agenda or in next moves.\nThe motivation for this is that there is no reason to address contact explicitly in this case,\nsince any utterance from the system implicitly tries to establish contact.\nDefault ICM integration rule Since contact is not explicitly represented in the infor-\nmation state proper, integration of negative system contact ICM moves have no speciflc\nefiect on the information state, and are therefore integrated by the default ICM integration\nrule shown in (rule 3.10). Unless an ICM move has a speciflc integration rule deflned for",
      "context_before": "tion level, e.g. \\I didn’t hear what you said.\".\nWe have conflgured the input module to set the input variable to ‘TIMED OUT’ if nothing\nis detected, and to ‘FAIL’ if something unrecognizable was detected.\nNegative system contact feedback If the speech recognizer does not get any input\nwithin a certain time frame (specifled by the timeout TIS variable), the input variable\nwill be set to ‘TIMED OUT’ by the input module. The rule for selection of negative contact\nfeedback is shown in (rule 3.9).\n(",
      "context_after": "it, it will be integrated by this rule."
    },
    {
      "title": "rule 3 .10). Unless an ICM move has a speciflc integration rule deflned for",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 119",
      "page": 142,
      "content": "rule 3.10). Unless an ICM move has a speciflc integration rule deflned for\nit, it will be integrated by this rule.",
      "context_before": "that nothing is on the agenda or in next moves.\nThe motivation for this is that there is no reason to address contact explicitly in this case,\nsince any utterance from the system implicitly tries to establish contact.\nDefault ICM integration rule Since contact is not explicitly represented in the infor-\nmation state proper, integration of negative system contact ICM moves have no speciflc\nefiect on the information state, and are therefore integrated by the default ICM integration\nrule shown in (",
      "context_after": ""
    },
    {
      "title": "rule 3 .10) rule: integrateOtherICM",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 121",
      "page": 143,
      "content": "rule 3.10) rule: integrateOtherICM\nclass: integrate\npre: fst($/private/nim, icm:A)\nn pop(/private/nim)\neff:\nadd(/shared/lu/moves, icm:A)\n(\nThe condition and updates in this rule are straightforward.\nNegative system perception feedback If the speech recognizer gets some input from\nthe user but is not able to reliably flgure out what was said (the recognition score may be\ntoo low), the input variable gets set to ‘FAIL’. This will trigger negative perception ICM,\ne.g. \\I didn’t hear what you said\".\n(rule 3.11) rule: selectIcmPerNeg",
      "context_before": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 121\n(",
      "context_after": "class: select icm\n$input=’FAIL’\npre:\nnot in($next moves, icm:per*neg)\n(\neff: push(next moves, icm:per*neg)\nn\nThe purpose of the second condition is to prevent selecting negative perception feedback\nmore than once in the selection phase. As with negative system contact feedback, negative\nsystem perception feedback is integrated by the integrateOtherICM rule.\nNegative understanding level feedback\nNegative feedback can concern either of the two sublevels of the understanding level: se-\nmantic and"
    },
    {
      "title": "rule 3 .11) rule: selectIcmPerNeg",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 121",
      "page": 143,
      "content": "rule 3.11) rule: selectIcmPerNeg\nclass: select icm\n$input=’FAIL’\npre:\nnot in($next moves, icm:per*neg)\n(\neff: push(next moves, icm:per*neg)\nn\nThe purpose of the second condition is to prevent selecting negative perception feedback\nmore than once in the selection phase. As with negative system contact feedback, negative\nsystem perception feedback is integrated by the integrateOtherICM rule.\nNegative understanding level feedback\nNegative feedback can concern either of the two sublevels of the understanding level: se-\nmantic and pragmatic understanding.\nNegative system semantic understanding feedback If some input is recognized\nby the recognition module, the interpretation module will try to flnd an interpretation\nof the input. If this fails, the latest moves gets set to failed which triggers selection\nof negative semantic understanding feedback (e.g. \\I don’t understand\"). In addition,\npositive perception feedback (e.g. \\I heard ‘perish’ \") is produced to indicate to the user\nwhat the system thought she said.",
      "context_before": "le 3.10) rule: integrateOtherICM\nclass: integrate\npre: fst($/private/nim, icm:A)\nn pop(/private/nim)\neff:\nadd(/shared/lu/moves, icm:A)\n(\nThe condition and updates in this rule are straightforward.\nNegative system perception feedback If the speech recognizer gets some input from\nthe user but is not able to reliably flgure out what was said (the recognition score may be\ntoo low), the input variable gets set to ‘FAIL’. This will trigger negative perception ICM,\ne.g. \\I didn’t hear what you said\".\n(",
      "context_after": ""
    },
    {
      "title": "rule 3 .12) rule: selectIcmSemNeg",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 121",
      "page": 144,
      "content": "rule 3.12) rule: selectIcmSemNeg\nclass: select icm\n$latest moves=failed\npre: $input=String\n8\n>< not in($next moves, icm:sem*neg)\npush(next moves, icm:per*pos:String)\neff:\n>:\npush(next moves, icm:sem*neg)\n(\nThe purpose of the third condition is to prevent negative semantic understanding feedback\nfrom being selected more than one time. Since only one string is recognized per turn,\nthere is never any reason to apply the rule more than once; and if anything at all can be\ninterpreted, the rule will not trigger at all even if some material was not used in interpreta-\ntion. In a system with a wide-coverage recognizer and a more sophisticated interpretation\nmodule, one may consider producing negative semantic understanding feedback for any\nmaterial which cannot be interpreted (e.g. \\I understand that you want to go to Paris,\nbut I don’t understand what you mean by ‘Londres’.\").\nThe flrst update in this rule selects positive perception ICM to show the user what the\nsystem heard. The second update selects negative semantic understanding ICM.\nNegative system pragmatic understanding feedback The system will try to inte-\ngrate the moves according to the rules above in Section 3.6.7. If this fails (if there are still\nmoves which have not been integrated), the rule in (rule 3.13) will be triggered and a",
      "context_before": "122 CHAPTER 3. GROUNDING ISSUES\nThis will only occur if the recognition lexicon covers sentences not covered by the inter-\npretation lexicon.\n(",
      "context_after": "icm:und*neg-move will be selected by the system. However, if the reason that the move was\nnot integrated is that it had a low score or was not acceptable to the system, interrogative\nunderstanding feedback (Section 3.6.6) or negative acceptance feedback (Section 3.6.6),\nrespectively, will instead be selected and the move will be popped ofi nim before the rule\nin (rule 3.13) is tried.\nIn IBiS, only ask-moves can be irrelevant. Other moves, including ask, do not have any\nrelevance requirements. T"
    },
    {
      "title": "rule 3 .13) will be triggered and a",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 121",
      "page": 144,
      "content": "rule 3.13) will be triggered and a\nicm:und*neg-move will be selected by the system. However, if the reason that the move was\nnot integrated is that it had a low score or was not acceptable to the system, interrogative\nunderstanding feedback (Section 3.6.6) or negative acceptance feedback (Section 3.6.6),\nrespectively, will instead be selected and the move will be popped ofi nim before the rule\nin (rule 3.13) is tried.\nIn IBiS, only ask-moves can be irrelevant. Other moves, including ask, do not have any\nrelevance requirements. This means that answer moves are the only moves that can fail\nto be understood on the pragmatic level, given that they have been understood on the\nsemantic level. Also, for an utterance to be completely irrelevant, no part of it must have\nbeen integrated. For these reasons, the rule in (rule 3.13) will trigger only if no move",
      "context_before": "ted (e.g. \\I understand that you want to go to Paris,\nbut I don’t understand what you mean by ‘Londres’.\").\nThe flrst update in this rule selects positive perception ICM to show the user what the\nsystem heard. The second update selects negative semantic understanding ICM.\nNegative system pragmatic understanding feedback The system will try to inte-\ngrate the moves according to the rules above in Section 3.6.7. If this fails (if there are still\nmoves which have not been integrated), the rule in (",
      "context_after": "in the latest utterance was integrated, and the utterance was interpreted as containing at\nleast one answer-move."
    },
    {
      "title": "rule 3 .13) is tried.",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 121",
      "page": 144,
      "content": "rule 3.13) is tried.\nIn IBiS, only ask-moves can be irrelevant. Other moves, including ask, do not have any\nrelevance requirements. This means that answer moves are the only moves that can fail\nto be understood on the pragmatic level, given that they have been understood on the\nsemantic level. Also, for an utterance to be completely irrelevant, no part of it must have\nbeen integrated. For these reasons, the rule in (rule 3.13) will trigger only if no move\nin the latest utterance was integrated, and the utterance was interpreted as containing at\nleast one answer-move.",
      "context_before": "ction 3.6.7. If this fails (if there are still\nmoves which have not been integrated), the rule in (rule 3.13) will be triggered and a\nicm:und*neg-move will be selected by the system. However, if the reason that the move was\nnot integrated is that it had a low score or was not acceptable to the system, interrogative\nunderstanding feedback (Section 3.6.6) or negative acceptance feedback (Section 3.6.6),\nrespectively, will instead be selected and the move will be popped ofi nim before the rule\nin (",
      "context_after": ""
    },
    {
      "title": "rule 3 .13) will trigger only if no move",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 121",
      "page": 144,
      "content": "rule 3.13) will trigger only if no move\nin the latest utterance was integrated, and the utterance was interpreted as containing at\nleast one answer-move.",
      "context_before": "ill instead be selected and the move will be popped ofi nim before the rule\nin (rule 3.13) is tried.\nIn IBiS, only ask-moves can be irrelevant. Other moves, including ask, do not have any\nrelevance requirements. This means that answer moves are the only moves that can fail\nto be understood on the pragmatic level, given that they have been understood on the\nsemantic level. Also, for an utterance to be completely irrelevant, no part of it must have\nbeen integrated. For these reasons, the rule in (",
      "context_after": ""
    },
    {
      "title": "rule 3 .13) rule: selectIcmUndNeg",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 123",
      "page": 145,
      "content": "rule 3.13) rule: selectIcmUndNeg\nclass: select icm\nnot in($next moves, icm:und*neg)\nin($latest moves, answer(A))\n8\npre:\n>>>>>>>>< fora\n$\nl\n/\nl(\np\n$\nr\nl\ni\na\nv\nt\na\ne\nt\ns\ne\nt\n/n\nm\nim\nov\n/e\ne\nl\ns\ne\n/e\nm\nl\n=\ne\nM\nm=\nov\nM\ne)\nove,\nforall($latest moves/elem=answer(A0),\n>>>>>>>>:\nfora\nn\nl\no\nl\nt\nd\nf\no\ns\n(\nt\n$\n(\nl\n$\na\n/s\nt\nh\ne\na\nst\nre\nm\nd\no\n/q\nve\nu\ns\nd\n/\n,\ne\nD\nle\n)\nm\nan\n=\nd\nM\n$\no\nd\nv\no\ne\nm\n,\nain :: relevant(A0, Q))\neff: push(next moves, icm:sem*pos:Move))\n8\n>< push(next moves, icm:und*neg)\n>:\nThe flrst rule checks that negative pragmatic understanding feedback has not already been\nselected. The second condition checks that the latest utterance contained an answer move,\nand the third checks that none of the moves performed in the latest utterance has been\nintegrated; all moves in latest moves are still on nim. Finally, the fourth condition\nchecks that no answer is relevant to any question on QUD.\nTheflrstupdateselectspositivefeedbackonthesemanticunderstandinglevelforeachmove\nperformed in the latest utterance, to show that the utterance was at least understood to\nsome extent. The second update selects negative feedback and pushes it on next moves.\nThe system is thus able to make a distinction between utterances it cannot interpret (and\nthus not ground), and utterances that it can interpret and ground but not integrate. The\nrule in (3.15) triggers when integration fails because the system cannot see the relevance\nof the user utterance in the current dialogue context. Negative pragmatic understanding\nfeedback is currently realized as \\I don’t quite understand\"; the idea is to indicate that\nthe utterance was almost fully understood, but not quite. Again, it can be argued what\nthe best realization is.\nDialogue example: negative system contact, perception, and understanding\nfeedback In this dialogue, we see examples of negative system feedback on the contact,\nperception, and understanding (both semantic and pragmatic) levels. (Since this dialogue\nuses the text-based input module, we have simulated timeout and recognition failure.)\n(dialogue 3.5)\nS> Welcome to the travel agency!\nU> ’TIMED_OUT’",
      "context_before": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 123\n(",
      "context_after": ""
    },
    {
      "title": "rule 3 .14) rule: rejectProp",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 127",
      "page": 149,
      "content": "rule 3.14) rule: rejectProp\nclass: select action\nin($/private/nim, answer(A))\n$/shared/lu/speaker=usr\n8\npre:\n>>>>>>>>< f\n$\ns\nd\nt(\no\n$\nm\n/s\na\nh\nin\nar\n::\ned\nre\n/\nl\nq\nev\nu\na\nd\nn\n,\nt(\nQ\nA\n)\n, Q)\n$domain :: combine(Q, A, P)\n>>>>>>>>:\nd\nn\ne\no\nl\nt\n(/\n$\np\nd\nr\na\ni\nt\nv\na\na\nb\nt\na\ne\ns\n/\ne\nni\n:\nm\n:\n,\nv\na\na\nn\nli\ns\nd\nw\nD\ne\nB\nr(\np\nA\na\n)\nr\n)\nameter(P)\neff: push(/private/agenda, icm:und*pos:usr*P)\n8\n>< push(/private/agenda, icm:acc*neg:P)\n>:\nThe flrst flve conditions are identical to those for the rule for integrating user answers,\nintegrateUsrAnswer (Section 3.6.6). The flnal condition checks that the proposition P,\nresulting from combining a question on QUD with the content of the answer move, is not\na valid database parameter. The updates remove the move from nim and selects positive\nunderstanding feedback to show what the system understood, and negative acceptance\nfeedback.\nOf course, it is not optimally e–cient that the same sequence of conditions is checked by\nseveral difierent rules; an alternative approach would be to let one rule determine e.g. how\nan answer move is relevant, combine it with a question on QUD, and store the result in\na datastructure containing pragmatically interpreted material. This datastructure could\nthen be inspected by both integration and rejection rules. (See also Section 6.5.1.)\nDialogue example: system proposition rejection In the following dialogue, we il-\nlustrate system rejection of the proposition that the means of transport to search for will\nbe train. A motivation is also given by the system, i.e. that \\train\" is not available as a\nmeans of transport in the database.\n(dialogue 3.8)\nS> Okay. I need some information. How do you want to travel?\ngetLatestMoves\nintegrateOtherICM\nintegrateOtherICM\nintegrateSysAsk\nU> train please",
      "context_before": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 127\n(",
      "context_after": ""
    },
    {
      "title": "rule 3 .15) rule: rejectIssue",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 129",
      "page": 151,
      "content": "rule 3.15) rule: rejectIssue\nclass: select action\nin($/private/nim, ask(Q))\npre: $/shared/lu/speaker=usr\n8\n>< not $domain :: plan(Q, Plan)\ndel(/private/nim, ask(Q))\n>:\neff: push(/private/agenda, icm:und*pos:usr*issue(Q))\n8\n>< push(/private/agenda, icm:acc*neg:issue(Q))\n>:\nThe rule is similar to the rejectProp rule. The third condition checks that there is no\nplan for dealing with the question Q.\nDialogue example: system issue rejection In the following dialogue, the user’s re-\nquest for information about connecting (cid:176)ights is rejected on the grounds that the system\ndoes not know how to address that issue.\n(dialogue 3.9)\nS> Okay. The price is 123 crowns.\nU> what about connecting flights\ngetLatestMoves\nbackupShared\nrejectIssue\ndel(/private/nim, ask(?A.con (cid:176)ight(A)))\npush(/private/agenda, )\n8\npush(/private/agenda, icm:acc*neg:issue(?A.con (cid:176)ight(A)))\n<\nselectIcmOther\n: push(next moves, icm:und*pos:usr*issue(?A.con (cid:176)ight(A)))\ndel(/private/agenda, icm:und*pos:usr*issue(?A.con (cid:176)ight(A)))\n‰\nselectIcmOther\npush(next moves, icm:acc*neg:issue(?A.con (cid:176)ight(A)))\ndel(/private/agenda, icm:acc*neg:issue(?A.con (cid:176)ight(A)))\n‰\nS> You asked about connecting flights. Sorry, I cannot answer questions",
      "context_before": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 129\nIn case the system has interpreted a user utterance as an ask-move with content q, but the\nsystem does not have a plan for dealing with q, the system must reject q and indicate this\nto the user using appropriate feedback. This rule allows the system to respond intelligently\nto user questions even if it cannot answer them (given that they can be recognized and\ninterpreted).\n(",
      "context_after": ""
    },
    {
      "title": "rule 3 .16).",
      "section": "3.6.7 Grounding of system utterances in IBiS2",
      "page": 152,
      "content": "rule 3.16).\n(rule 3.16) rule: getLatestMoves\nclass: grounding\n$latest moves=Moves\npre: $latest speaker=DP\n8\n>< $/shared/lu/moves=PrevMoves\nset(/private/nim, Moves)\n>:\nset(/shared/lu/speaker, DP)\neff: 8\n>>>< clear(/shared/lu/moves)\nset(/shared/pm, PrevMoves)\n>>>:\nThe rule loads information regarding the latest utterance performed into nim and copies\nthe previously grounded moves (in /shared/lu/moves) to the /shared/pm fleld. Note\nthat this rule has changed signiflcantly compared to IBiS1; no optimistic assumption\nabout understanding of the latest utterance is made here. Instead of putting the latest\nmoves in /shared/lu/moves, which would be to assume that they have been mutually",
      "context_before": "has been implemented in IBiS2. We flrst present basic update rules re(cid:176)ecting the\ncautious strategy. We then present integration rules for the \\core\" system dialogue moves\n(ask and answer), and describe the rules for integrating user feedback to system moves.\nEnabling cautious updates\nIBiS2 uses a mix of various grounding strategies. For system utterances, a cautiously\noptimistic strategy is used.\nMoving latest moves to nim The IBiS2 version of the update rule getLatestMoves\nis shown in (",
      "context_after": ""
    },
    {
      "title": "rule 3 .16) rule: getLatestMoves",
      "section": "3.6.7 Grounding of system utterances in IBiS2",
      "page": 152,
      "content": "rule 3.16) rule: getLatestMoves\nclass: grounding\n$latest moves=Moves\npre: $latest speaker=DP\n8\n>< $/shared/lu/moves=PrevMoves\nset(/private/nim, Moves)\n>:\nset(/shared/lu/speaker, DP)\neff: 8\n>>>< clear(/shared/lu/moves)\nset(/shared/pm, PrevMoves)\n>>>:\nThe rule loads information regarding the latest utterance performed into nim and copies\nthe previously grounded moves (in /shared/lu/moves) to the /shared/pm fleld. Note\nthat this rule has changed signiflcantly compared to IBiS1; no optimistic assumption\nabout understanding of the latest utterance is made here. Instead of putting the latest\nmoves in /shared/lu/moves, which would be to assume that they have been mutually",
      "context_before": "emented in IBiS2. We flrst present basic update rules re(cid:176)ecting the\ncautious strategy. We then present integration rules for the \\core\" system dialogue moves\n(ask and answer), and describe the rules for integrating user feedback to system moves.\nEnabling cautious updates\nIBiS2 uses a mix of various grounding strategies. For system utterances, a cautiously\noptimistic strategy is used.\nMoving latest moves to nim The IBiS2 version of the update rule getLatestMoves\nis shown in (rule 3.16).\n(",
      "context_after": ""
    },
    {
      "title": "rule 3 .17) copies relevant parts of the IS to the",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 131",
      "page": 153,
      "content": "rule 3.17) copies relevant parts of the IS to the\ntmp fleld. This makes it possible to backtrack to a previous state, should the optimistic\ngrounding assumptions concerning a system move turn out to be mistaken. This means\nthatanyoptimisticupdatesassociatedwithintegrationofsystemmovesarenowcautiously\noptimistic.\n(rule 3.17) rule: backupShared\nclass: none\npre: f\n/private/tmp/qud := $/shared/qud\n/private/tmp/com := $/shared/com\neff: 8\n>>>< /private/tmp/agenda := $/private/agenda\n/private/tmp/plan := $/private/plan\n>>>:\nThere are no conditions on this rule. It is executed at the start of the selection algorithm\ndescribed in Section 3.7, and is thus only called before system utterances.\nCautiously optimistic integration of system moves\nFor system ask and answer moves, the integration rules are similar to those in IBiS1;\nhowever, rather than picking out moves from /shared/lu/moves, IBiS2 picks moves\nfrom /private/nim and adds them to /shared/lu/moves, thereby assuming grounding\nontheunderstandinglevel, onlyinconnectionwithintegration. Sinceoptimisticgrounding\nis assumed for system moves, it would be okay to handle them the same way we did\nin IBiS1; however, user moves are no longer (always) optimistically grounded, and we\nhave chosen to give a uniform treatment to all moves. Since in IBiS system moves are\nalways successfully integrated, however, there is no real difierence between the way they\nare handled in IBiS1 and IBiS2.",
      "context_before": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 131\nunderstood, IBiS2 clears /shared/lu/moves so that moves can be added when they are\nactually integrated; only then are they assumed to be understood.\nSaving previous state before integration Before selecting, producing, and integrat-\ning a new system utterance, the rule in (",
      "context_after": ""
    },
    {
      "title": "rule 3 .17) rule: backupShared",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 131",
      "page": 153,
      "content": "rule 3.17) rule: backupShared\nclass: none\npre: f\n/private/tmp/qud := $/shared/qud\n/private/tmp/com := $/shared/com\neff: 8\n>>>< /private/tmp/agenda := $/private/agenda\n/private/tmp/plan := $/private/plan\n>>>:\nThere are no conditions on this rule. It is executed at the start of the selection algorithm\ndescribed in Section 3.7, and is thus only called before system utterances.\nCautiously optimistic integration of system moves\nFor system ask and answer moves, the integration rules are similar to those in IBiS1;\nhowever, rather than picking out moves from /shared/lu/moves, IBiS2 picks moves\nfrom /private/nim and adds them to /shared/lu/moves, thereby assuming grounding\nontheunderstandinglevel, onlyinconnectionwithintegration. Sinceoptimisticgrounding\nis assumed for system moves, it would be okay to handle them the same way we did\nin IBiS1; however, user moves are no longer (always) optimistically grounded, and we\nhave chosen to give a uniform treatment to all moves. Since in IBiS system moves are\nalways successfully integrated, however, there is no real difierence between the way they\nare handled in IBiS1 and IBiS2.",
      "context_before": "ly integrated; only then are they assumed to be understood.\nSaving previous state before integration Before selecting, producing, and integrat-\ning a new system utterance, the rule in (rule 3.17) copies relevant parts of the IS to the\ntmp fleld. This makes it possible to backtrack to a previous state, should the optimistic\ngrounding assumptions concerning a system move turn out to be mistaken. This means\nthatanyoptimisticupdatesassociatedwithintegrationofsystemmovesarenowcautiously\noptimistic.\n(",
      "context_after": ""
    },
    {
      "title": "rule 3 .18) rule: integrateSysAsk",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 131",
      "page": 154,
      "content": "rule 3.18) rule: integrateSysAsk\nclass: integrate\n$/shared/lu/speaker==sys\npre:\nfst($/private/nim, ask(A))\n(\npop(/private/nim)\neff: add(/shared/lu/moves, ask(A))\n8\n>< push(/shared/qud, A)\n>:\n(rule 3.19) rule: integrateSysAnswer",
      "context_before": "132 CHAPTER 3. GROUNDING ISSUES\n(",
      "context_after": "class: integrate\nfst($/private/nim, answer(A))\n$/shared/lu/speaker==sys\n8\npre: >>>>>><\nf\n$\ns\nd\nt(\no\n$\nm\n/s\na\nh\nin\nar\n::\ned\npr\n/\no\nq\np\nu\no\nd\nsi\n,\nti\nB\non\n)\n(A)\n$domain :: relevant(A, B)\n>>>>>>:\npop(/private/nim)\neff: add(/shared/lu/moves, answer(A))\n8\n>< add(/shared/com, A)\n>:\nOne complication is that in IBiS2, several moves may be performed in a single utter-\nance. To keep track of which utterances have been integrated, the /private/nim stack\nof non-integrated moves is popped for each move that"
    },
    {
      "title": "rule 3 .19) rule: integrateSysAnswer",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 131",
      "page": 154,
      "content": "rule 3.19) rule: integrateSysAnswer\nclass: integrate\nfst($/private/nim, answer(A))\n$/shared/lu/speaker==sys\n8\npre: >>>>>><\nf\n$\ns\nd\nt(\no\n$\nm\n/s\na\nh\nin\nar\n::\ned\npr\n/\no\nq\np\nu\no\nd\nsi\n,\nti\nB\non\n)\n(A)\n$domain :: relevant(A, B)\n>>>>>>:\npop(/private/nim)\neff: add(/shared/lu/moves, answer(A))\n8\n>< add(/shared/com, A)\n>:\nOne complication is that in IBiS2, several moves may be performed in a single utter-\nance. To keep track of which utterances have been integrated, the /private/nim stack\nof non-integrated moves is popped for each move that gets integrated. Note also that\neach integrated (and thus understood) move is added to /shared/lu/moves (whereas in\nIBiS1 this was done at the start of the update cycle).\nThe cautiously optimistic acceptance assumptions built into these rules can be retracted\non integration of negative user perception feedback, as explained in Section 3.6.6, or on\nnegative user integration feedback, as show in Section 3.6.7. Dialogue examples involving\nthe rules shown above will be given in these sections.\nUser feedback to system utterances\nIn this section we review user feedback to system utterances and how these afiect the\noptimistic grounding assumptions.\nNegative user perception feedback If the system makes an utterance, it will assume\nitisgroundedandaccepted. Iftheuserindicatesthatshedidnotunderstandtheutterance,\nthe rule in (rule 3.20) makes it possible to retract the efiects of the system’s latest move,",
      "context_before": "132 CHAPTER 3. GROUNDING ISSUES\n(rule 3.18) rule: integrateSysAsk\nclass: integrate\n$/shared/lu/speaker==sys\npre:\nfst($/private/nim, ask(A))\n(\npop(/private/nim)\neff: add(/shared/lu/moves, ask(A))\n8\n>< push(/shared/qud, A)\n>:\n(",
      "context_after": "thus cancelling the assumptions of grounding and acceptance."
    },
    {
      "title": "rule 3 .20) makes it possible to retract the efiects of the system’s latest move,",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 131",
      "page": 154,
      "content": "rule 3.20) makes it possible to retract the efiects of the system’s latest move,\nthus cancelling the assumptions of grounding and acceptance.",
      "context_before": "in Section 3.6.6, or on\nnegative user integration feedback, as show in Section 3.6.7. Dialogue examples involving\nthe rules shown above will be given in these sections.\nUser feedback to system utterances\nIn this section we review user feedback to system utterances and how these afiect the\noptimistic grounding assumptions.\nNegative user perception feedback If the system makes an utterance, it will assume\nitisgroundedandaccepted. Iftheuserindicatesthatshedidnotunderstandtheutterance,\nthe rule in (",
      "context_after": ""
    },
    {
      "title": "rule 3 .20) rule: integrateUsrPerNegICM",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 133",
      "page": 155,
      "content": "rule 3.20) rule: integrateUsrPerNegICM\nclass: integrate\n$/shared/lu/speaker==usr\npre:\nfst($/private/nim, icm:per*neg)\n(\npop(/private/nim)\n/shared/qud := $/private/tmp/qud\n8\neff: >>>>>>< /\n/\ns\np\nh\nr\na\niv\nr\na\ne\nt\nd\ne\n/\n/\nc\na\no\ng\nm\nen\n:=\nda\n$/\n:=\npr\n$\ni\n/\nv\np\na\nr\nt\ni\ne\nv\n/\na\nt\nt\nm\ne\np\n/t\n/c\nm\no\np\nm\n/agenda\n/private/plan := $/private/tmp/plan\n>>>>>>:\nThe four last updates revert the com, qud, plan and agenda flelds to the values stored\nin /private/tmp.\nDialogue example: negative user perception feedback This dialogue shows how\nIBiS2 is able to react to negative user perception feedback (e.g. \\pardon\") by retracting\ntheoptimisticgroundingassumptionbybacktrackingrelevantpartsof sharedtothestate\nin /private/tmp/sys, stored before the system utterance was generated. Also, the plan\nand agenda are backtracked to enable the system to continue the dialogue properly.\n(dialogue 3.10)\nS>Okay. You asked about price. I need some information. How do you want\nto travel?\ngetLatestMoves\nintegrateOtherICM\nintegrateOtherICM\nintegrateOtherICM\nintegrateSysAsk",
      "context_before": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 133\n(",
      "context_after": ""
    },
    {
      "title": "rule 3 .21) allows the user to reject a system",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 135",
      "page": 157,
      "content": "rule 3.21) allows the user to reject a system\nquestion (by indicating inability to answer, i.e. by uttering \\I don’t know\" or similar). If\nthis is done, the optimistic grounding update is retracted by restoring the shared parts\nstored in nim, i.e. qud and com, to their previous states.\n(rule 3.21) rule: integrateUsrAccNegICM\nclass: integrate\n$/shared/lu/speaker==usr\npre: fst($/private/nim, icm:acc*neg:issue)\n8\n>< in($/shared/pm, ask(Q))\npop(/private/nim)\n>:\nadd(/shared/lu/moves, icm:acc*neg:issue)\neff: 8\n>>>< /shared/qud := $/private/tmp/qud\n/shared/com := $/private/tmp/com\n>>>:",
      "context_before": "6 consultDB(?H.price(H)) 7 7\n6 6 7 7\n6 6 bel = fg 7 7\n6 6 7 7\n6 6 tmp = ::: 7 7\n6 6 7 7\n6 6 nim = hhii 7 7\n6 6 7 7\n6 4 com = fg 5 7\n6 7\n6 qud = ?A.price(A) 7\n6 2 3 7\n6 shared = speaker = usr 7\n6 lu = › fi 7\n6 6 moves = oqueue([icm:per*neg]) 7 7\n6 6 • ‚ 7 7\n6 6 pm = ::: 7 7\n6 6 7 7\n4 4 5 5\nbackupShared\nselectFromPlan\nselectIcmOther\nselectIcmOther\nselectIcmOther\nselectAsk\nS>Okay. You asked about price. I need some information. How do you want\nto travel?\nExplicit user issue rejection The rule in (",
      "context_after": ""
    },
    {
      "title": "rule 3 .21) rule: integrateUsrAccNegICM",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 135",
      "page": 157,
      "content": "rule 3.21) rule: integrateUsrAccNegICM\nclass: integrate\n$/shared/lu/speaker==usr\npre: fst($/private/nim, icm:acc*neg:issue)\n8\n>< in($/shared/pm, ask(Q))\npop(/private/nim)\n>:\nadd(/shared/lu/moves, icm:acc*neg:issue)\neff: 8\n>>>< /shared/qud := $/private/tmp/qud\n/shared/com := $/private/tmp/com\n>>>:",
      "context_before": "5\nbackupShared\nselectFromPlan\nselectIcmOther\nselectIcmOther\nselectIcmOther\nselectAsk\nS>Okay. You asked about price. I need some information. How do you want\nto travel?\nExplicit user issue rejection The rule in (rule 3.21) allows the user to reject a system\nquestion (by indicating inability to answer, i.e. by uttering \\I don’t know\" or similar). If\nthis is done, the optimistic grounding update is retracted by restoring the shared parts\nstored in nim, i.e. qud and com, to their previous states.\n(",
      "context_after": ""
    },
    {
      "title": "rule 3 .22) rule: irrelevantFollowup",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 141",
      "page": 163,
      "content": "rule 3.22) rule: irrelevantFollowup\nclass: none\n1 $/private/nim=Moves\n2 $/shared/lu/speaker==usr\n8\npre:\n>>>>>>>>>>>>><\n5\n4\n3\nP\ni\nn\nn\no\nr\n(\nt\n$\ne\n/\nv\nA\ns\nM\n/\nh\ne\na\no\nl\nv\nr\ne\ne\ne\nm\n=\nd\n=\na\n/\ns\ni\np\nk\nc\nm\nm\n(Q\n,\n:\n)\nP\no\nr\nr\nevMove)\n( PrevMove=icm:und*int:DP*C and Q=und(DP*C) )\neff:\n>>>>>>>>>>>>>:\n/\n7\n6\ns\nn\nn\nh\no\no\na\nt\nt\nr\nA\nM\ned\n/\no\ne\n/\nv\nl\nq\ne\ne\nu\ns\nm\n/\nd\ne\n=\n:\nl\n=\na\ne\nn\nm\ns\n$\nw\n=\n/p\ne\na\nr\nr\ns\n(\nk\ni\nA\nv\n(\n)\nQ\nat\na\n0)\nn\ne\nd\na\n/\nn\nt\n$\nd\nm\nd\np\n$\no\n/\nd\nm\nq\no\na\nu\nm\ni\nd\nn\nai\n:\nn\n: r\n::\nel\nd\nev\ne\na\np\nn\ne\nt\nn\n(\nd\nA\ns\n,\n(Q\nQ\n,\n)\nQ0)\n/shared/com := $/private/tmp/com\n(\n(Sincethisruleiscalled\\byname\"fromtheupdatealgorithm,thereisnoneedforincluding\nit in a rule class.) Condition 3 checks that no ICM was included in the latest move.\nCondition 4 and 5 tries to flnd a question Q raised by the previous move, possibly an\nunderstanding-question. Note here that we do not check QUD; in IBiS2, questions remain\non QUD only for one turn but it may be the case that we want questions to remain on\nQUD over several turns. What we are interested here is thus not which questions are on\nQUD but which questions were raised by the previous utterance, and this is the reason\nfor looking in pm rather than qud. Conditions 6 and 7 check that no move performed in\nthe latest utterance is relevant to Q, neither by answering it nor by asking a question on\nwhich Q depends. The updates are similar to those for integration of negative acceptance\nfeedback (Section 3.6.7).",
      "context_before": "followups to system ask moves as implicit\nrejections. However, this choice is not obvious and is a further topic for future research.\nImplicit user rejection of issue\nIf an irrelevant followup is detected, this is interpreted as an implicit issue rejection and\nconsequently the optimistic assumption that the question q0 was integrated by the user is\nassumed to be mistaken. Therefore, the optimistic assumption is retracted by reverting\nthe previous shared state for the relevant parts of shared.\n(",
      "context_after": ""
    },
    {
      "title": "rule 3 .23) rule: flndPlan",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 143",
      "page": 165,
      "content": "rule 3.23) rule: flndPlan\nclass: load plan\nin($/private/agenda, respond(Q))\npre: $domain :: plan(Q, Plan)\n8\n>< not in($/private/bel, P) and $domain :: resolves(P, Q)\ndel(/private/agenda, respond(Q))\n>:\neff: set(/private/plan, Plan)\n8\n>< push(/private/agenda, icm:loadplan))\n>:\nThis rule is identical to that in IBiS1 (Section 2.8.6), expect for the flnal update which\npushes the icm:loadplan move on the agenda.\nReraising issues\nSystem reraising of issue associated with plan If the user raises a question Q and\nthen raises Q0 before Q has been resolved, the system should return to dealing with Q once\nQ0 is resolved; this was described in Section 3.6.9. The recoverPlan rule in IBiS2, shown\nin (3.20), is almost identical to the one in IBiS1, except that ICM is produced to indicate\nthat an issue (q1) is being reraised. This ICM is formalized as icm:reraise:q where q is the\nquestion being reraised, and expressed e.g. as \\Returning to the issue of price\".\n(rule 3.24) rule: recoverPlan",
      "context_before": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 143\n(",
      "context_after": "class: load plan\nin($/shared/qud, Q)\nis empty($/private/agenda)\n8\npre: >>>>>>< i\n$\ns\nd\ne\no\nm\nm\np\na\nt\ni\ny\nn\n($\n:\n/\n:\np\np\nr\nla\niv\nn\na\n(Q\nte\n,\n/\nP\np\nl\nl\na\na\nn\nn\n)\n)\nnot in($/private/bel, P) and $domain :: resolves(P, Q)\n>>>>>>:\nset(/private/plan, Plan)\neff: push(/private/agenda, icm:reraise:Q)\n8\n>< push(/private/agenda, icm:loadplan))\n>:\nIssuereraising byuser Inthecasewheretheuserreraisesanopenissue,anicm:reraise:Q\nmove is selected by the integrateUsrAsk described in Section 3.6.6.\nSystem reraisin"
    },
    {
      "title": "rule 3 .24) rule: recoverPlan",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 143",
      "page": 165,
      "content": "rule 3.24) rule: recoverPlan\nclass: load plan\nin($/shared/qud, Q)\nis empty($/private/agenda)\n8\npre: >>>>>>< i\n$\ns\nd\ne\no\nm\nm\np\na\nt\ni\ny\nn\n($\n:\n/\n:\np\np\nr\nla\niv\nn\na\n(Q\nte\n,\n/\nP\np\nl\nl\na\na\nn\nn\n)\n)\nnot in($/private/bel, P) and $domain :: resolves(P, Q)\n>>>>>>:\nset(/private/plan, Plan)\neff: push(/private/agenda, icm:reraise:Q)\n8\n>< push(/private/agenda, icm:loadplan))\n>:\nIssuereraising byuser Inthecasewheretheuserreraisesanopenissue,anicm:reraise:Q\nmove is selected by the integrateUsrAsk described in Section 3.6.6.\nSystem reraising of issue not associated with plan The IBiS1 reraiseIssue rule\ndescribed in Section 2.12.3 reraises any questions on QUD which are not associated with",
      "context_before": "ated with plan If the user raises a question Q and\nthen raises Q0 before Q has been resolved, the system should return to dealing with Q once\nQ0 is resolved; this was described in Section 3.6.9. The recoverPlan rule in IBiS2, shown\nin (3.20), is almost identical to the one in IBiS1, except that ICM is produced to indicate\nthat an issue (q1) is being reraised. This ICM is formalized as icm:reraise:q where q is the\nquestion being reraised, and expressed e.g. as \\Returning to the issue of price\".\n(",
      "context_after": ""
    },
    {
      "title": "rule 3 .25) rule: reraiseIssue",
      "section": "3.6. FEEDBACK AND GROUNDING STRATEGIES FOR IBIS 143",
      "page": 166,
      "content": "rule 3.25) rule: reraiseIssue\nclass: select action\nfst($/shared/issues, Q)\npre:\nnot $domain :: plan(Q, P)\n(\npush(/private/agenda, icm:reraise)\neff:\npush(/private/agenda, raise(Q))\n(\nThe conditions of this rule checks that there is a question Q on issues for which the system\nhas no plan, i.e. one that the system needs to ask the user.\nThe flrst update adds an icm:reraise (without an argument) to signal that it is reraising\na question; this is currently generated as preflxing \\so\" to the next ask move, which is\nan ordinary raising of the question (placed on the agenda by the second update in the\nrule). In a more sophisticated implementation one could consider abbreviating the original\nraising of the question to make an appropriate reraising, e.g. \\So, from what city?\" But\nwe do not have a general method for doing that yet, even in these simple dialogues. To\ndo it properly would probably require more detailed syntactic and semantic analysis of\ncontributions than we currently have in IBiS.\nDialogue example: user and system reraising (dialogue 3.12) is an example of a\ndialogue where the user reraises an issue which was previously raised but not resolved.\nAlso subsequently the system reraises an issue which is relevant for addressing the issue\nthat the user reraised. In order to address the issue of price the system needs to get\ninformation from the user concerning where she wishes to travel from.\n(dialogue 3.12)\nS> Welcome to the travel agency!\nU> price information please\nS> Okay. Lets see. How do you want to travel?\nU> a flight\nS> Okay. What city do you want to go to?\nU> paris\nS> Okay. What city do you want to go from?",
      "context_before": "144 CHAPTER 3. GROUNDING ISSUES\nany plan (i.e. which have been raised previously by the system). In this case it is again\nhelpful to indicate that the system is aware that the issue is being reraised. However, since\nthe issue will be reraised, the sequencing ICM does not need to indicate which question is\nbeing reraised.\n(",
      "context_after": ""
    },
    {
      "title": "rule 3 .26), does not require the agenda",
      "section": "3.7.2 Selection module",
      "page": 168,
      "content": "rule 3.26), does not require the agenda\nto be empty, but only that the respond action has not already been selected, and thus it\nallows several moves to be selected per turn.",
      "context_before": "grate all\nmoves in /private/nim. If the user asked a question, the appropriate plan will be loaded\nby line 5. Any loaded plan is executed by applying the exec plan rule class until no more\nexecution is possible at the current stage of the dialogue.\n3.7.2 Selection module\nAs in IBiS1, action selection rules add actions to the agenda. However, while in IBiS1 only\none action was selected per turn, in IBiS2 several actions may be selected per turn. For\nexample, the selectRespond in IBiS2, shown in (",
      "context_after": ""
    },
    {
      "title": "rule 3 .26) rule: selectRespond",
      "section": "3.7. FURTHER IMPLEMENTATION ISSUES 147",
      "page": 169,
      "content": "rule 3.26) rule: selectRespond\nclass: select action\nis empty($/private/plan)\nfst($/shared/qud, A)\n8\npre:\n>>>>>>>>< i\nn\nn\no\n(\nt\n$/\nin\np\n(\nr\n$\ni\n/\nv\ns\na\nh\nt\na\ne\nr\n/\ne\nb\nd\ne\n/\nl\nc\n,\no\nB\nm\n)\n, B)\n$domain :: resolves(B, A)\neff:\n>>>>>>>>:\np\nn\nu\no\ns\nt\nh\ni\n(\nn\n/\n(\np\n$\nr\n/\ni\np\nv\nr\na\ni\nt\nv\ne\na\n/\nt\na\ne\ng\n/\ne\na\nn\ng\nd\ne\na\nn\n,\nd\nr\na\ne\n,\nsp\nre\no\ns\nn\np\nd\no\n(\nn\nA\nd\n)\n(\n)\nA))\nn\nSimilarly, the move selection rules in IBiS2 are repeatedly applied, popping actions ofi the\nagenda queue and pushing the corresponding moves on next moves. As an example,\nthe selectAnswer rule is shown in (rule 3.27).",
      "context_before": "3.7. FURTHER IMPLEMENTATION ISSUES 147\n(",
      "context_after": "(rule 3.27) rule: selectAnswer\nclass: select move\nfst($/private/agenda, respond(A))\nin($/private/bel, B)\npre: 8\n>>>< not in($/shared/com, B)\n$domain :: resolves(B, A)\neff:\n>>>:\npush(next moves, answer(B))\npop(/private/agenda)\n(\nThe selection algorithm for IBiS2 is shown in (3.21).\n(3.21) h backupShared,\nif not in($/private/agenda, A) and q raising action(A)\nthen try select action,\nrepeat ( select icm orelse select move ) i\nThe select action rule class selects actions and places them on the agen"
    },
    {
      "title": "rule 3 .27).",
      "section": "3.7. FURTHER IMPLEMENTATION ISSUES 147",
      "page": 169,
      "content": "rule 3.27).\n(rule 3.27) rule: selectAnswer\nclass: select move\nfst($/private/agenda, respond(A))\nin($/private/bel, B)\npre: 8\n>>>< not in($/shared/com, B)\n$domain :: resolves(B, A)\neff:\n>>>:\npush(next moves, answer(B))\npop(/private/agenda)\n(\nThe selection algorithm for IBiS2 is shown in (3.21).\n(3.21) h backupShared,\nif not in($/private/agenda, A) and q raising action(A)\nthen try select action,\nrepeat ( select icm orelse select move ) i\nThe select action rule class selects actions and places them on the agenda, whereas\nthe select move and select icm rule classes selects agenda items and places them on\nnext moves. Before selection, the backupShared (Section 3.6.7) is applied to copy\nrelevant parts of the information state to /private/nim.\nThe basic strategy for selection in IBiS is that only one question should be raised by the\nsystem in each utterance. The IBiS2 selection algorithm flrst checks if some question-\nraising action is already on the agenda; if not, it tries to select a new action. Then, it\nselects moves and ICM repeatedly until nothing more can be selected.",
      "context_before": "/plan)\nfst($/shared/qud, A)\n8\npre:\n>>>>>>>>< i\nn\nn\no\n(\nt\n$/\nin\np\n(\nr\n$\ni\n/\nv\ns\na\nh\nt\na\ne\nr\n/\ne\nb\nd\ne\n/\nl\nc\n,\no\nB\nm\n)\n, B)\n$domain :: resolves(B, A)\neff:\n>>>>>>>>:\np\nn\nu\no\ns\nt\nh\ni\n(\nn\n/\n(\np\n$\nr\n/\ni\np\nv\nr\na\ni\nt\nv\ne\na\n/\nt\na\ne\ng\n/\ne\na\nn\ng\nd\ne\na\nn\n,\nd\nr\na\ne\n,\nsp\nre\no\ns\nn\np\nd\no\n(\nn\nA\nd\n)\n(\n)\nA))\nn\nSimilarly, the move selection rules in IBiS2 are repeatedly applied, popping actions ofi the\nagenda queue and pushing the corresponding moves on next moves. As an example,\nthe selectAnswer rule is shown in (",
      "context_after": ""
    },
    {
      "title": "rule 3 .27) rule: selectAnswer",
      "section": "3.7. FURTHER IMPLEMENTATION ISSUES 147",
      "page": 169,
      "content": "rule 3.27) rule: selectAnswer\nclass: select move\nfst($/private/agenda, respond(A))\nin($/private/bel, B)\npre: 8\n>>>< not in($/shared/com, B)\n$domain :: resolves(B, A)\neff:\n>>>:\npush(next moves, answer(B))\npop(/private/agenda)\n(\nThe selection algorithm for IBiS2 is shown in (3.21).\n(3.21) h backupShared,\nif not in($/private/agenda, A) and q raising action(A)\nthen try select action,\nrepeat ( select icm orelse select move ) i\nThe select action rule class selects actions and places them on the agenda, whereas\nthe select move and select icm rule classes selects agenda items and places them on\nnext moves. Before selection, the backupShared (Section 3.6.7) is applied to copy\nrelevant parts of the information state to /private/nim.\nThe basic strategy for selection in IBiS is that only one question should be raised by the\nsystem in each utterance. The IBiS2 selection algorithm flrst checks if some question-\nraising action is already on the agenda; if not, it tries to select a new action. Then, it\nselects moves and ICM repeatedly until nothing more can be selected.",
      "context_before": "shared/qud, A)\n8\npre:\n>>>>>>>>< i\nn\nn\no\n(\nt\n$/\nin\np\n(\nr\n$\ni\n/\nv\ns\na\nh\nt\na\ne\nr\n/\ne\nb\nd\ne\n/\nl\nc\n,\no\nB\nm\n)\n, B)\n$domain :: resolves(B, A)\neff:\n>>>>>>>>:\np\nn\nu\no\ns\nt\nh\ni\n(\nn\n/\n(\np\n$\nr\n/\ni\np\nv\nr\na\ni\nt\nv\ne\na\n/\nt\na\ne\ng\n/\ne\na\nn\ng\nd\ne\na\nn\n,\nd\nr\na\ne\n,\nsp\nre\no\ns\nn\np\nd\no\n(\nn\nA\nd\n)\n(\n)\nA))\nn\nSimilarly, the move selection rules in IBiS2 are repeatedly applied, popping actions ofi the\nagenda queue and pushing the corresponding moves on next moves. As an example,\nthe selectAnswer rule is shown in (rule 3.27).\n(",
      "context_after": ""
    },
    {
      "title": "rule 4 .1) flrst checks whether a question which",
      "section": "4.6.1 Issue accommodation: from dialogue plan to ISSUES",
      "page": 187,
      "content": "rule 4.1) flrst checks whether a question which\nmatches the answer occurs in the current dialogue plan (provided there is one). A question\nmatches an answer if the answer is relevant to, or (in Ginzburg’s terminology) about the\nquestion. If such a question can be found, it can be assumed that this is now an open\nissue. Accommodating this amounts to pushing the question on the ISSUES stack.\n5Since the current plan is presumably being carried out in order to deal with some open issue, we may\nregard the utterance as indirectly relevant to some open issue (via the plan).",
      "context_before": "9 *2 (cid:27) :; &=\nKE MO N\nKE MO NS R !$ UV *X W2 (cid:25)Y ,\n(cid:30)(cid:5) (cid:25)Y :d &) ((cid:9)*2 (cid:27)(cid:26) , (cid:30)(cid:5) (cid:25)Y :d &) ((cid:9)*2 (cid:27)(cid:26) ,\n*X W2 (cid:25)B ,\n(cid:15)b 4i 02 <; &) ((cid:9)%(cid:31)\n(cid:15)@ .A (cid:25)(cid:31) &Y !f Ug\n<) (cid:30)\n((cid:9)(cid:23)\n*X W2\n%>\n0j\n(cid:25)B\n&1\n(cid:27)/\n,\n,\n&\nZ\\[\n[\n[ [\n[ [\n]\nR\nZ\\[\n[\n[ [ [ [\n]\nZ\\[\n[\n[ [\n[ [\n[\n[\n[ [ [ [\n[\n[\n[ [ [ [\n]\nFigure 4.2: Issue accommodation\nThe issue accommodation update rule in (",
      "context_after": ""
    },
    {
      "title": "rule 4 .1) rule: accommodatePlan2Issues",
      "section": "4.6.1 Issue accommodation: from dialogue plan to ISSUES",
      "page": 188,
      "content": "rule 4.1) rule: accommodatePlan2Issues\nclass: accommodate\n$/private/nim/elem/snd = answer(A)\nnot $lexicon :: yn answer(A)\n8\npre:\n>>>>>>>>>>>>><\n$\n$\nin\nd\nd\n(\no\no\n$/\nm\nm\np\na\na\nr\ni\ni\ni\nn\nn\nva\n:\n:\n:\n:\nte\nd\nre\n/\ne\nl\nf\np\ne\na\nv\nl\nu\na\na\nl\nn\nt\nn\nt\n,\nq\n(A\nu\nfl\ne\nn\n,\ns\nd\nQ\nt\no\nio\n)\nu\nn\nt(\n(\nQ\nQ\n)\n)\n)\nor\nnot ( in($/private/plan, flndout(Q0))\neff:\n>>>>>>>>>>>>>:\npush(/sha\na\na\nr\nn\nn\ne\nd\nd\nd\nQ\n$\n/\nd\ni\n6=\ns\no\ns\nm\nu\nC\na\ne\ni\ns\nn\n, B\n::\n)\nrelevant(A, Q0) )\nn\nThe flrst condition picks out a non-integrated answer move with content A. The second\ncondition checks that A is not a y/n answer (e.g. yes, no, maybe etc.), and thus im-\nplements an assumption that such answers cannot trigger question accommodation, since\nthey are too ambiguous6. The third and fourth conditions check if there is a flndout action\nwith content Q in the currently loaded plan, such that A is relevant to Q. The flnal con-\ndition checks that there is no other question in the plan that the answer is relevant to, or\nalternatively that Q has the status of a default question. If this condition does not hold, a\nclariflcation question should be raised by the system; this is described in Section 4.6.3. The\n\\default question\" option allows encoding of the fact that one issue may be signiflcantly\nmore salient in a certain domain. For example, in a travel agency setting the destination\ncity may be regarded as more salient than the departure city question. If this is encoded\nas a default question, then if the user says simply \\Paris\" it is interpreted as answering\nthe destination city question; no clariflcation is triggered7\nExample dialogue: issue accommodation The dialogue in (dialogue 4.1) illus-\ntrates accommodation of the question ?C.class(C) from the plan to the stack of open\nissues.\n(dialogue 4.1)\n6However,ingeneralonecannotruleoutthepossibilitythaty/n answerscantriggeraccommodationin\nseverelyrestricteddomains. Theassumptionthatthiscannothappencanberegardedasaverysimplifled\nversion of a constraint on the number of questions which an answer may be relevant without making\nquestion accommodation infeasible.\n7The normal grounding mechanisms should of course enable correction of this assumption. In IBiS3\nthe choice of grounding strategy depends solely on the recognition score which means that a high-scoring\nanswermaybeinterpretedasananswertoadefaultquestionandnotreceiveanyexplicitfeedback. Thisis\nonecasewhichindicatesaneedfortakingmorefactorsintoaccountwhenchoosingfeedbackandgrounding\nstrategy.",
      "context_before": "166 CHAPTER 4. ADDRESSING UNRAISED ISSUES\n(",
      "context_after": ""
    },
    {
      "title": "Procedure/Rule in 4.6.2 Local question accommodation: from ISSUES to QUD",
      "section": "4.6.2 Local question accommodation: from ISSUES to QUD",
      "page": 190,
      "content": "168 CHAPTER 4. ADDRESSING UNRAISED ISSUES\nagenda = icm:acc*pos\nflndout(?A.dept day(A))\n2 2 plan = ›› fifi 3 3\nprivate = consultDB(?B.price(B))\n¿ (cid:192)\n6 6 bel = fg 7 7\n6 6 7 7\n6 6 nim = hhii 7 7\n6 6 7 7\n6 4 class(economy) 5 7\n6 7\n6 month(april) 7\n6 2 8 9 3 7\n6\n6\n6 6\ncom = >>>><\nd\nd\ne\ne\np\nst\nt\nc\nc\ni\ni\nt\nt\ny\ny\n(\n(\np\nlo\na\nn\nri\nd\ns\no\n)\nn)\n>>>>=\n7\n7\n7\n7\n6 6 7 7\n6 6 how(plane) 7 7\n6 6\n6\n6\nshared = 6 6\n6\n6\ni\nq\ns\nu\nsu\nd\nes\n=\n=\nh\n>>>>:i ?D.price(D) >>>>; 7 7\n7\n7\n7 7\n7\n7\n6 6 › fi 7 7\n6 6 pm = icm:acc*pos, icm:loadplan, ask(?C.month(C)) 7 7\n6 6 7 7\n6 6 speaker = usr 7 7\n6 6 ›› fifi 7 7\n6 6 lu = moves = answer(april), answer(class(economy)) 7 7\n6 6 2 3 7 7\n6 6 score = 1 7 7\n6 6 ›› fifi 7 7\n4 4 4 5 5 5\nS> Okay. What day do you want to leave?\n4.6.2 Local question accommodation: from ISSUES to QUD\nIf a move with underspecifled content is made which does not match any question on the\nQUD, the closest place to look for such a question is ISSUES, and if it can be found there\nit should be pushed on the local QUD to enable ellipsis resolution. As a side-efiect, the\nquestion has now been brought into focus and should, if it is not topmost on the open\nissues stack, be raised to the top of open issues. A schematic overview of local question\naccommodation is shown in Figure 4.3.\n(cid:0)(cid:1)\n(cid:1)\n(cid:1) (cid:1)\n(cid:1) (cid:1)\n(cid:1)\n(cid:1)\n(cid:1) (cid:1) (cid:1) (cid:1)\n(cid:1)\n(cid:1)\n(cid:1) (cid:1) (cid:1) (cid:1)\n(cid:2)\n(cid:3)(cid:5)\nI>\n(cid:4)(cid:7)\n^\n(cid:6)(cid:9)(cid:8)(cid:11)\n(cid:10)(cid:18) (cid:4)(cid:7)\n(cid:10)(cid:11) (cid:12)(cid:14)\n(cid:13)(cid:5)\n(cid:13)\n(cid:20)\n(cid:15)\n(cid:15)\n(cid:0)(cid:1)\n(cid:1)\n(cid:1) (cid:1)\n(cid:1) (cid:1)\n(cid:2)\n(cid:0)(cid:1)\n(cid:1)\n(cid:1) (cid:1) (cid:1) (cid:1)\n(cid:2)\n(cid:10)(cid:17) (cid:16)(cid:18) (cid:13)(cid:5)\n(cid:3) -\" (cid:10)(cid:17)\n?(cid:14) (cid:13)(cid:5) -\n(cid:12)(cid:7) DE (cid:3) (cid:19)(cid:18) (cid:6)T D\n_a ‘ D\n(cid:6) IY I(cid:31) G e (cid:20)\nG\n(cid:3)(cid:26) D\n-\nG\n(cid:19)(cid:17)\n(cid:19)\n(cid:13)\n(cid:20)(cid:7)\nI\n(cid:10)\n(cid:15)b\n(cid:15)@ (cid:15)@\n(cid:15)@\n(cid:15)\n(cid:15)(cid:22)\n(cid:15)(cid:22)\n(cid:15)@\n(cid:15) (cid:15)(cid:22)\n.A\n(cid:21)(cid:24) (cid:21)(cid:24)\n(cid:21)(cid:24)\nF\n(cid:21)(cid:24) (cid:23)(cid:26) (cid:25)(cid:28) (cid:27)(cid:14) (cid:29)(cid:24) (cid:30)(cid:5) (cid:25)(cid:31) (cid:30) (cid:25)\"\n(cid:21)(cid:24) (cid:23)(cid:26) (cid:25)(cid:28) (cid:27)(cid:26) ./ &1 02 %1 3(cid:7) !$\n.A (cid:25)> &B !$ 4C <= *\" (cid:23)(cid:26) ,\n(cid:4) (cid:15)L\nFH GJ I (cid:15)L I’ PQ I (cid:21)(cid:24) (cid:23)(cid:26) (cid:25)(cid:28) (cid:27)(cid:14) (cid:29)(cid:24) (cid:30)(cid:5) (cid:25)(cid:31) (cid:30) (cid:25)\"\n(cid:25)(cid:31) &Y !$ 4C <= *\" (cid:23)(cid:26) ,\n(cid:23)(cid:14) (cid:25)(cid:31) (cid:27)(cid:26) ./ &1 02 %1 3(cid:7) !c (cid:29)(cid:24) (cid:23)(cid:14) (cid:25)(cid:31) (cid:27)(cid:26) ./ &1 02 %1 3(cid:7) !c (cid:29)(cid:24)\n(cid:23)(cid:14) (cid:25)(cid:31) (cid:27)(cid:14) (cid:29)(cid:24) (cid:30)(cid:5) (cid:25)(cid:28) (cid:30)(cid:5) (cid:25)\" !f Ug\n(cid:3) (cid:13)(cid:5) (cid:10)(cid:17) hQ (cid:13)(cid:5) (cid:4)\nI\n‘ D (cid:8)J (cid:13)\n!$ #(cid:24) %’ &) (+*\" (cid:27)(cid:26) ,\n46 5702 (cid:27)(cid:14) 89 *2 (cid:27) :; &=\nKE MO N\nKE MO NS R !$ UV *X W2 (cid:25)Y ,\n(cid:30)(cid:5) (cid:25)Y :d &) ((cid:9)*2 (cid:27)(cid:26) , (cid:30)(cid:5) (cid:25)Y :d &) ((cid:9)*2 (cid:27)(cid:26) ,\n*X W2 (cid:25)B ,\n(cid:15)b 4i 02 <; &) ((cid:9)%(cid:31)\n(cid:15)@ .A (cid:25)(cid:31) &Y !f Ug\n<) (cid:30)\n((cid:9)(cid:23)\n*X W2\n%>\n0j\n(cid:25)B\n&1\n(cid:27)/\n,\n,\n&\nZ\\[\n[\n[ [\n[ [\n]\nR\nZ\\[\n[\n[ [ [ [\n]\nZ\\[\n[\n[ [\n[ [\n[\n[\n[ [ [ [\n[\n[\n[ [ [ [\n]\nFigure 4.3: Local question accommodation\nThis type of accommodation can e.g. occur if a question which was raised previously has\ndropped ofi the local QUD but has not yet been resolved and remains on ISSUES. It should\nalso be noted that several accommodation steps can be taken during the processing of a",
      "context_before": "",
      "context_after": ""
    },
    {
      "title": "rule 4 .2) rule: accommodateIssues2QUD",
      "section": "4.6.3 Issue clariflcation",
      "page": 191,
      "content": "rule 4.2) rule: accommodateIssues2QUD\nclass: accommodate\n$/private/nim/elem=usr-answer(A)\n$domain :: short answer(A)\n8\npre:\n>>>>>>>><\ni\nn\nn\no\n(\nt\n$/\n$\ns\nl\nh\ne\na\nx\nr\nic\ne\no\nd\nn\n/i\n:\ns\n:\nsu\nyn\nes\na\n,\nn\nQ\nsw\n)\ner(A)\nnot in($/shared/qud, Q)\neff:\n>>>>>>>>:\np\n$\nu\nd\ns\no\nh\nm\n(/\na\ns\ni\nh\nn\na\n:\nr\n:\ne\nr\nd\nel\n/\ne\nq\nva\nu\nn\nd\nt\n,\n(A\nQ\n,\n)\nQ)\nraise(/shared/issues, Q)\n(\nThe second condition in (rule 4.2) checks that the content of the answer move picked out",
      "context_before": "4.6. VARIETIESOFQUESTIONACCOMMODATIONANDREACCOMMODATION169\nsingle utterance; for example, if an issue that is in the plan but has not yet been raised is\nanswered elliptically.\n(",
      "context_after": "by condition 1 is semantically underspecifled. The third condition imposes a constraint\non local question accommodation, excluding short answers to y/n-questions (\\yes\", \\no\",\n\\maybe\" etc.). The remaining conditions check that the answer-content is relevant to an\nissue which is on issues but not on qud. The flrst operation pushes the accommodated\nquestion on qud, and the flnal update raises the question to the top of the stack of open\nissues.\n4.6.3 Issue clariflcation\nIn IBiS2, user answers are"
    },
    {
      "title": "rule 4 .2) checks that the content of the answer move picked out",
      "section": "4.6.3 Issue clariflcation",
      "page": 191,
      "content": "rule 4.2) checks that the content of the answer move picked out\nby condition 1 is semantically underspecifled. The third condition imposes a constraint\non local question accommodation, excluding short answers to y/n-questions (\\yes\", \\no\",\n\\maybe\" etc.). The remaining conditions check that the answer-content is relevant to an\nissue which is on issues but not on qud. The flrst operation pushes the accommodated\nquestion on qud, and the flnal update raises the question to the top of the stack of open\nissues.",
      "context_before": "single utterance; for example, if an issue that is in the plan but has not yet been raised is\nanswered elliptically.\n(rule 4.2) rule: accommodateIssues2QUD\nclass: accommodate\n$/private/nim/elem=usr-answer(A)\n$domain :: short answer(A)\n8\npre:\n>>>>>>>><\ni\nn\nn\no\n(\nt\n$/\n$\ns\nl\nh\ne\na\nx\nr\nic\ne\no\nd\nn\n/i\n:\ns\n:\nsu\nyn\nes\na\n,\nn\nQ\nsw\n)\ner(A)\nnot in($/shared/qud, Q)\neff:\n>>>>>>>>:\np\n$\nu\nd\ns\no\nh\nm\n(/\na\ns\ni\nh\nn\na\n:\nr\n:\ne\nr\nd\nel\n/\ne\nq\nva\nu\nn\nd\nt\n,\n(A\nQ\n,\n)\nQ)\nraise(/shared/issues, Q)\n(\nThe second condition in (",
      "context_after": "4.6.3 Issue clariflcation\nIn IBiS2, user answers are either pragmatically relevant to the question topmost on QUD,\nor not relevant at all. When we add mechanisms of accommodation to allow for answers\nto unraised questions, it becomes necessary to deal with cases where an answer may be\npotentially relevant to several difierent questions.\nSemantically underspecifled answers may (but need not) be pragmatically ambiguous, i.e.\nit is not clear what question they provide an answer to. This can be res"
    },
    {
      "title": "rule 4 .3).",
      "section": "4.6.3 Issue clariflcation",
      "page": 192,
      "content": "rule 4.3).\n(rule 4.3) rule: clarifyIssue\nclass: select action\nin($/private/nim, usr-answer(A))\nsetof(C, in($/private/plan, flndout(Q)) and\npre: 8\n>>>< $domain :: relevant(A, Q), QSet)\n$$arity(QSet) > 1\n>>>: ! setof(?P, in(QSet, Q) and $domain :: combine(Q, A, P), AltQ)\neff: push(/private/agenda, flndout(AltQ))\n8\n>< del(/private/nim, usr-answer(A))\n>:\nThe flrst condition picks out the answer-move from the nim queue. The second and third\nconditions check that there is more than one question in the plan to which the answer\nis relevant, by constructing the set of such questions. The flrst operation constructs the\nalternative-question by applying each question in the set constructed in condition 2 to the\nanswer to get a proposition and preflxing the question operator ’?’ to each proposition\nto get a y/n-question. The alternative question is this set of y/n-questions. The second\noperation pushes the action to raise the alternative question on the agenda, and the flnal\noperation removes the answer move from nim; this is motivated above.\nA sample dialogue with issue clariflcation is shown in (dialogue 4.2).\n(dialogue 4.2)\nS> Welcome to the travel agency!\nU> price information please\nS> Okay. I need some information. How do you want to travel?\nU> flight um paris\nS> OK, by flight. Do you mean from paris or to paris?\n8IBiS3onlyhandlesfullanswerstoclariflcationquestions,i.e. \\ToParis.\" or\\FromParis.\". Aslightly\nmore advanced semantics would be required to handle cases where the user again gives an underspecifled\nresponse which resolves the question, i.e. \\To.\" or \\From.\".",
      "context_before": "will answer this question, which means that the ambiguous answer no longer needs to\nbe integrated and can be thrown away8.\nIn this way we see how question accommodation, amended with a mechanism for resolving\nwhichquestiontoaccommodate,canbeusedtoresolvepragmaticambiguitiesinuserinput.\nThe accommodation mechanism can thus be regarded as a reflnement of the account of\ngrounding on the understanding level put forward in Chapter 3. The rule which selects\nthe issue clariflcation issue is shown in (",
      "context_after": ""
    },
    {
      "title": "rule 4 .3) rule: clarifyIssue",
      "section": "4.6.3 Issue clariflcation",
      "page": 192,
      "content": "rule 4.3) rule: clarifyIssue\nclass: select action\nin($/private/nim, usr-answer(A))\nsetof(C, in($/private/plan, flndout(Q)) and\npre: 8\n>>>< $domain :: relevant(A, Q), QSet)\n$$arity(QSet) > 1\n>>>: ! setof(?P, in(QSet, Q) and $domain :: combine(Q, A, P), AltQ)\neff: push(/private/agenda, flndout(AltQ))\n8\n>< del(/private/nim, usr-answer(A))\n>:\nThe flrst condition picks out the answer-move from the nim queue. The second and third\nconditions check that there is more than one question in the plan to which the answer\nis relevant, by constructing the set of such questions. The flrst operation constructs the\nalternative-question by applying each question in the set constructed in condition 2 to the\nanswer to get a proposition and preflxing the question operator ’?’ to each proposition\nto get a y/n-question. The alternative question is this set of y/n-questions. The second\noperation pushes the action to raise the alternative question on the agenda, and the flnal\noperation removes the answer move from nim; this is motivated above.\nA sample dialogue with issue clariflcation is shown in (dialogue 4.2).\n(dialogue 4.2)\nS> Welcome to the travel agency!\nU> price information please\nS> Okay. I need some information. How do you want to travel?\nU> flight um paris\nS> OK, by flight. Do you mean from paris or to paris?\n8IBiS3onlyhandlesfullanswerstoclariflcationquestions,i.e. \\ToParis.\" or\\FromParis.\". Aslightly\nmore advanced semantics would be required to handle cases where the user again gives an underspecifled\nresponse which resolves the question, i.e. \\To.\" or \\From.\".",
      "context_before": "this question, which means that the ambiguous answer no longer needs to\nbe integrated and can be thrown away8.\nIn this way we see how question accommodation, amended with a mechanism for resolving\nwhichquestiontoaccommodate,canbeusedtoresolvepragmaticambiguitiesinuserinput.\nThe accommodation mechanism can thus be regarded as a reflnement of the account of\ngrounding on the understanding level put forward in Chapter 3. The rule which selects\nthe issue clariflcation issue is shown in (rule 4.3).\n(",
      "context_after": ""
    },
    {
      "title": "rule 4 .4) rule: accommodateDependentIssue",
      "section": "4.6.4 Dependent issue accommodation: from domain resource to",
      "page": 194,
      "content": "rule 4.4) rule: accommodateDependentIssue\nclass: accommodate\nsetof(A, $/private/nim/elem/snd=answer(A), AnsSet)\n$$arity(AnsSet) > 0\n8\npre:\n>>>>>>>>>>>>>>>>>>< i\n$\nf\ns\no\nd\nr\ne\no\na\n$\nm\nl\nm\nd\nl(\np\no\na\ni\nt\nn\nm\ni\ny\n(\nn\n(\nA\na\n$\n:\ni\nn\n/\n:\nn\np\ns\np\nS\nr\n:\nl\n:\na\ni\ne\nv\nr\nn\nt\ne\na\n,\n(\nl\nD\nt\nA\nev\ne\n)\ne\na\n/\n,\np\nn\np\ni\nQ\nn\nt\nl\n(\n,\n(\na\nA\nP\nP\nn\n,\nl\nl\n)\na\nQ\na\nn\nn\n)\n,\n)\n)\nflndout(Q)) and\nnot ( $domain :: plan(DepQ0, Plan0) and DepQ0 6= DepQ and\n>>>>>>>>>>>>>>>>>>:\np\nn\nu\no\ns\nt\nf\nh\no\ni\n(\nn\nr\n/\na\n(\n$\ns\n$\nl\nd\nl\nh\n/\n(\no\na\ni\np\nn\nm\nr\nr\n(A\ni\na\ne\nv\nd\ni\nn\na\nn\n/\ns\nt\ni\nw\n:\ne\ns\n:\ns\ne\n/\nr\nu\nr\na\ne\nS\ne\ng\nle\ns\ne\ne\nv\n,\nt\nn\na\n,\nD\nn\nd\nA\nt\ne\na\n(\n)\np\nA\n,\n,\nQ\ni\ni\n,\nc\nn\n)\nm\nQ\n(P\n:\n)\nu\n)\nl\nn\na\n)\nd\nn\n*\n0,\nin\nfl\nt\nn\n:u\nd\ns\no\nr\nu\n*\nt\nis\n(\ns\nQ\nu\n)\ne\n)\n(D\nan\ne\nd\npQ))\npush(/private/agenda, icm:accommodate:DepQ)\n8\neff: >>>>>><\ns\np\ne\nu\nt\ns\n(\nh\n/\n(\np\n/\nr\np\ni\nr\nv\ni\na\nv\nt\na\ne\nt\n/\ne\np\n/\nl\na\na\ng\nn\ne\n,\nn\nP\nd\nl\na\na\n,\nn\ni\n)\ncm:und*pos:usr*issue(DepQ))\npush(/private/agenda, icm:loadplan)\n>>>>>>:\nThe flrst two conditions construct a set of all non-integrated answers and check that the\narity of this set is larger than zero, i.e. that there is at least one non-integrated answer.",
      "context_before": "27)(cid:14) 89 *2 (cid:27) :; &=\nKE MO N\nKE MO NS R !$ UV *X W2 (cid:25)Y ,\n(cid:30)(cid:5) (cid:25)Y :d &) ((cid:9)*2 (cid:27)(cid:26) , (cid:30)(cid:5) (cid:25)Y :d &) ((cid:9)*2 (cid:27)(cid:26) ,\n*X W2 (cid:25)B ,\n(cid:15)b 4i 02 <; &) ((cid:9)%(cid:31)\n(cid:15)@ .A (cid:25)(cid:31) &Y !f Ug\n<) (cid:30)\n((cid:9)(cid:23)\n*X W2\n%>\n0j\n(cid:25)B\n&1\n(cid:27)/\n,\n,\n&\nZ\\[\n[\n[ [\n[ [\n]\nR\nZ\\[\n[\n[ [ [ [\n]\nZ\\[\n[\n[ [\n[ [\n[\n[\n[ [ [ [\n[\n[\n[ [ [ [\n]\nDOMAIN\nRESOURCE\nFigure 4.4: Dependent issue accommodation\n(",
      "context_after": ""
    },
    {
      "title": "rule 4 .5).",
      "section": "4.6.5 Dependent issue clariflcation",
      "page": 198,
      "content": "rule 4.5).\n(rule 4.5) rule: clarifyDependentIssue\nclass: select action\nin($/private/nim, pair(usr, answer(A)))\nsetof(Q0, $domain :: plan(Q0, Plan) and\n8\npre:\n>>>>>>>>>>><\nQS\ni\n$\ne\nn\nd\nt\n(\n0\no\n)\nP\nm\nla\na\nn\ni\n,\nn\nfl\n:\nn\n:\nd\nr\no\ne\nu\nle\nt(\nv\nS\nan\no\nt\nm\n(A\neQ\n, S\n))\no\na\nm\nn\ne\nd\nQ),\nremove uniflables(QSet0, QSet)\neff:\n>>>>>>>>>>>:\n!\n$$\nse\na\nt\nr\no\nit\nf\ny\n(I\n(Q\nss\nS\nu\ne\ne\nt\nQ\n)\n,\n>\nin\n1\n(QSet, I) and IssueQ=?issue(I), AltQ)\npush(/private/agenda, flndout(AltQ))\n(",
      "context_before": "7\n6 6 ›› fifi 7 7\n6 6 lu = moves = oqueueanswer(yes) 7 7\n6 6 2 3 7 7\n6 6 score = 1 7 7\n6 6 7 7\n4 4 4 5 5 5\nbackupSharedSys\nselectIcmOther\nselectIcmOther\nS> I need some information. by flight , is that correct?\n4.6.5 Dependent issue clariflcation\nIf no plan is loaded and one or several non-integrated answers are relevant to several plans,\na clariflcation question should be raised by the system to flnd out which issue the user\nwants the system to deal with. This is done by the selection rule in (",
      "context_after": ""
    },
    {
      "title": "rule 4 .5) rule: clarifyDependentIssue",
      "section": "4.6.5 Dependent issue clariflcation",
      "page": 198,
      "content": "rule 4.5) rule: clarifyDependentIssue\nclass: select action\nin($/private/nim, pair(usr, answer(A)))\nsetof(Q0, $domain :: plan(Q0, Plan) and\n8\npre:\n>>>>>>>>>>><\nQS\ni\n$\ne\nn\nd\nt\n(\n0\no\n)\nP\nm\nla\na\nn\ni\n,\nn\nfl\n:\nn\n:\nd\nr\no\ne\nu\nle\nt(\nv\nS\nan\no\nt\nm\n(A\neQ\n, S\n))\no\na\nm\nn\ne\nd\nQ),\nremove uniflables(QSet0, QSet)\neff:\n>>>>>>>>>>>:\n!\n$$\nse\na\nt\nr\no\nit\nf\ny\n(I\n(Q\nss\nS\nu\ne\ne\nt\nQ\n)\n,\n>\nin\n1\n(QSet, I) and IssueQ=?issue(I), AltQ)\npush(/private/agenda, flndout(AltQ))\n(",
      "context_before": "fi 7 7\n6 6 lu = moves = oqueueanswer(yes) 7 7\n6 6 2 3 7 7\n6 6 score = 1 7 7\n6 6 7 7\n4 4 4 5 5 5\nbackupSharedSys\nselectIcmOther\nselectIcmOther\nS> I need some information. by flight , is that correct?\n4.6.5 Dependent issue clariflcation\nIf no plan is loaded and one or several non-integrated answers are relevant to several plans,\na clariflcation question should be raised by the system to flnd out which issue the user\nwants the system to deal with. This is done by the selection rule in (rule 4.5).\n(",
      "context_after": ""
    },
    {
      "title": "4 .6).",
      "section": "4.6. VARIETIESOFQUESTIONACCOMMODATIONANDREACCOMMODATION179",
      "page": 201,
      "content": "rule\n4.6).\n(rule 4.6) rule: accommodateCom2Issues\nclass: accommodate\n$/private/nim/elem/snd=answer(A)\nin($/shared/com, P)\n8\npre: >>>>>><\n$\n$\nd\nd\no\no\nm\nm\na\na\ni\ni\nn\nn\n:\n:\n:\n:\nr\nq\ne\nu\nl\ne\ne\ns\nv\nt\na\ni\nn\no\nt\nn\n(\n(\nA\nQ\n,\n)\nQ)\n$domain :: relevant(P, Q)\neff:\n>>>>>>:\npush(/shared/issues, Q)\nn\nThis accommodation rule looks for an answer A among the moves which have not yet been\nintegrated (flrst condition). It then looks for a proposition among the shared commitments\nestablishedinthedialoguesofar(secondcondition)whichaccordingtothesystem’sdomain\nresource is an appropriate answer to some question for which A is also an answer (third to\nflfth conditions). Given that in this simple system answers can only be relevant to a single\nquestion10, this strategy will be successful in identifying cases where we have two answers\nto the same question. A system that deals with more complex dialogues where this is not\nthe case would need to keep track of closed issues in a separate list of closed issues. Thus\ntheconditionswillsucceedifthereisaquestionsuchthatboththeuseranswerandastored\nproposition are relevant answers to it; in the example dialogue above, \\departure date is\nthe fourth\" and \\departure date is the flfth\" are both relevant answers to the question\n\\which day do you want to travel?\". If such a question is found it is accommodated to\nissues, that is, it becomes an open issue again.\nWhenaccommodateCom2Issueshasbeensuccessfullyapplied, theretractrulein(rule\n10That is, in the full form in which they appear in $/shared/com. \\Chicago\" can be an answer to\n\\Which city do you want to go to?\" and \\Which city do you want to go from?\" but when it has been\ncombined with the questions the result will be \\destination(Chicago)\" and \\from(Chicago)\" respectively\nand it is this which is entered into the commitments.",
      "context_before": "ATIONANDREACCOMMODATION179\nU> a flight, april the fifth\nS> by flight. in april. the fifth. Okay. What city do you want to go\nto?\nU> london\nS> Okay. to london.\nU> actually, i want to go on the fourth\nS> the fourth. What city do you want to go from?\nInitially, integration of the answer using integrateUsrAnswer (Section 3.6.6) will fail\nsince there is no matching question on issues. The system will then try various accom-\nmodation strategies, including accommodation from /shared/com formulated in (",
      "context_after": ""
    },
    {
      "title": "rule 4 .6) rule: accommodateCom2Issues",
      "section": "4.6. VARIETIESOFQUESTIONACCOMMODATIONANDREACCOMMODATION179",
      "page": 201,
      "content": "rule 4.6) rule: accommodateCom2Issues\nclass: accommodate\n$/private/nim/elem/snd=answer(A)\nin($/shared/com, P)\n8\npre: >>>>>><\n$\n$\nd\nd\no\no\nm\nm\na\na\ni\ni\nn\nn\n:\n:\n:\n:\nr\nq\ne\nu\nl\ne\ne\ns\nv\nt\na\ni\nn\no\nt\nn\n(\n(\nA\nQ\n,\n)\nQ)\n$domain :: relevant(P, Q)\neff:\n>>>>>>:\npush(/shared/issues, Q)\nn\nThis accommodation rule looks for an answer A among the moves which have not yet been\nintegrated (flrst condition). It then looks for a proposition among the shared commitments\nestablishedinthedialoguesofar(secondcondition)whichaccordingtothesystem’sdomain\nresource is an appropriate answer to some question for which A is also an answer (third to\nflfth conditions). Given that in this simple system answers can only be relevant to a single\nquestion10, this strategy will be successful in identifying cases where we have two answers\nto the same question. A system that deals with more complex dialogues where this is not\nthe case would need to keep track of closed issues in a separate list of closed issues. Thus\ntheconditionswillsucceedifthereisaquestionsuchthatboththeuseranswerandastored\nproposition are relevant answers to it; in the example dialogue above, \\departure date is\nthe fourth\" and \\departure date is the flfth\" are both relevant answers to the question\n\\which day do you want to travel?\". If such a question is found it is accommodated to\nissues, that is, it becomes an open issue again.\nWhenaccommodateCom2Issueshasbeensuccessfullyapplied, theretractrulein(rule\n10That is, in the full form in which they appear in $/shared/com. \\Chicago\" can be an answer to\n\\Which city do you want to go to?\" and \\Which city do you want to go from?\" but when it has been\ncombined with the questions the result will be \\destination(Chicago)\" and \\from(Chicago)\" respectively\nand it is this which is entered into the commitments.",
      "context_before": "COMMODATION179\nU> a flight, april the fifth\nS> by flight. in april. the fifth. Okay. What city do you want to go\nto?\nU> london\nS> Okay. to london.\nU> actually, i want to go on the fourth\nS> the fourth. What city do you want to go from?\nInitially, integration of the answer using integrateUsrAnswer (Section 3.6.6) will fail\nsince there is no matching question on issues. The system will then try various accom-\nmodation strategies, including accommodation from /shared/com formulated in (rule\n4.6).\n(",
      "context_after": ""
    },
    {
      "title": "10 That is, in the full form in which they appear in $/shared/com. \\Chicago\" can be an answer to",
      "section": "4.6. VARIETIESOFQUESTIONACCOMMODATIONANDREACCOMMODATION179",
      "page": 201,
      "content": "rule\n10That is, in the full form in which they appear in $/shared/com. \\Chicago\" can be an answer to\n\\Which city do you want to go to?\" and \\Which city do you want to go from?\" but when it has been\ncombined with the questions the result will be \\destination(Chicago)\" and \\from(Chicago)\" respectively\nand it is this which is entered into the commitments.",
      "context_before": "a separate list of closed issues. Thus\ntheconditionswillsucceedifthereisaquestionsuchthatboththeuseranswerandastored\nproposition are relevant answers to it; in the example dialogue above, \\departure date is\nthe fourth\" and \\departure date is the flfth\" are both relevant answers to the question\n\\which day do you want to travel?\". If such a question is found it is accommodated to\nissues, that is, it becomes an open issue again.\nWhenaccommodateCom2Issueshasbeensuccessfullyapplied, theretractrulein(",
      "context_after": ""
    },
    {
      "title": "rule 4 .7) rule: retract",
      "section": "4.6. VARIETIESOFQUESTIONACCOMMODATIONANDREACCOMMODATION179",
      "page": 202,
      "content": "rule 4.7) rule: retract\nclass: integrate\n$/private/nim/elem/snd=answer(A)\nin($/shared/com, P0)\n8\npre:\n>>>>>>>>>>><\n$\n$\nfs\nd\nd\nt(\no\no\n$\nm\nm\n/s\na\na\nh\ni\ni\nn\nn\nar\n:\n:\n:\n:\ned\nr\nr\ne\ne\n/\nl\nl\ni\ne\ne\ns\nv\nv\ns\na\na\nu\nn\nn\ne\nt\nt\n(\n(\ns\nP\nA\n,\n,\nQ\n,\nQ\nQ\n)\n)\n)\n$domain :: combine(Q, A, P)\neff:\n>>>>>>>>>>>:\nd\n$\ne\nd\nl(\no\n/\nm\nsh\na\na\nin\nre\n::\nd/\nin\nc\nc\no\no\nm\nm\n,\np\nP\nat\n0\ni\n)\nble(P, P0)\nn\nThe conditions here are similar to those in (rule 4.6). We look for an unintegrated",
      "context_before": "180 CHAPTER 4. ADDRESSING UNRAISED ISSUES\n4.7) will remove the incompatible information from the system’s view of shared commit-\nments represented in /shared/com.\n(",
      "context_after": "answer (flrst condition) which is relevant to a question at the head of the list of open issues\n(third and flfth conditions) and for which there is already a relevant answer in the shared\ncommitments (second and fourth conditions). Finally, we determine that the result of\ncombining the answer with the question (sixth condition) is incompatible with the answer\nalready found (seventh condition). If all this is true we delete the answer which is currently\nin the shared commitments. This will flnal"
    },
    {
      "title": "rule 4 .6). We look for an unintegrated",
      "section": "4.6. VARIETIESOFQUESTIONACCOMMODATIONANDREACCOMMODATION179",
      "page": 202,
      "content": "rule 4.6). We look for an unintegrated\nanswer (flrst condition) which is relevant to a question at the head of the list of open issues\n(third and flfth conditions) and for which there is already a relevant answer in the shared\ncommitments (second and fourth conditions). Finally, we determine that the result of\ncombining the answer with the question (sixth condition) is incompatible with the answer\nalready found (seventh condition). If all this is true we delete the answer which is currently\nin the shared commitments. This will flnally allow the new answer to be integrated by a\nrule that integrates an answer from the user, and a further rule will remove the resolved\nissue from QUD. Note that this rule is of class integrate. As is indicated in Appendix B, it\nis tried before any other integration rule, to avoid integration of con(cid:176)icting information.\nNote also that the \\incompatible\" relation is deflned as a part of the domain resource, and\ncan thus be domain speciflc. The simple kind of revision that IBiS currently deals with\nis also handled by some form-based systems (although they usually do not give feedback\nindicating that information has been removed or replaced, as IBiS does). For example,\nChu-Carroll (2000) achieves a similar result by extracting parameter values from the latest\nuser utterance and subsequently (if possible) copying values from the previous form for\nany parameters not specifled in the latest utterance. A similar mechanism is referred to\nas \\overlay\" by Alexandersson and Becker (2000). While we are dealing only with very\nsimple revision here, the rule in (rule 4.7) and the \\incompatible\" relation can be seen as",
      "context_before": "information from the system’s view of shared commit-\nments represented in /shared/com.\n(rule 4.7) rule: retract\nclass: integrate\n$/private/nim/elem/snd=answer(A)\nin($/shared/com, P0)\n8\npre:\n>>>>>>>>>>><\n$\n$\nfs\nd\nd\nt(\no\no\n$\nm\nm\n/s\na\na\nh\ni\ni\nn\nn\nar\n:\n:\n:\n:\ned\nr\nr\ne\ne\n/\nl\nl\ni\ne\ne\ns\nv\nv\ns\na\na\nu\nn\nn\ne\nt\nt\n(\n(\ns\nP\nA\n,\n,\nQ\n,\nQ\nQ\n)\n)\n)\n$domain :: combine(Q, A, P)\neff:\n>>>>>>>>>>>:\nd\n$\ne\nd\nl(\no\n/\nm\nsh\na\na\nin\nre\n::\nd/\nin\nc\nc\no\no\nm\nm\n,\np\nP\nat\n0\ni\n)\nble(P, P0)\nn\nThe conditions here are similar to those in (",
      "context_after": "placeholders for a more sophisticated mechanism of belief revision.\nIt is also possible to remove the old answer by denying it (asserting its negation) as in\n(dialogue 4.7).\n(dialogue 4.7)"
    },
    {
      "title": "rule 4 .7) and the \\incompatible\" relation can be seen as",
      "section": "4.6. VARIETIESOFQUESTIONACCOMMODATIONANDREACCOMMODATION179",
      "page": 202,
      "content": "rule 4.7) and the \\incompatible\" relation can be seen as\nplaceholders for a more sophisticated mechanism of belief revision.\nIt is also possible to remove the old answer by denying it (asserting its negation) as in\n(dialogue 4.7).\n(dialogue 4.7)",
      "context_before": "lly do not give feedback\nindicating that information has been removed or replaced, as IBiS does). For example,\nChu-Carroll (2000) achieves a similar result by extracting parameter values from the latest\nuser utterance and subsequently (if possible) copying values from the previous form for\nany parameters not specifled in the latest utterance. A similar mechanism is referred to\nas \\overlay\" by Alexandersson and Becker (2000). While we are dealing only with very\nsimple revision here, the rule in (",
      "context_after": ""
    },
    {
      "title": "rule 4 .8) rule: accommodateCom2IssuesDependent",
      "section": "4.6.7 Opening up implicit grounding issues",
      "page": 204,
      "content": "rule 4.8) rule: accommodateCom2IssuesDependent\nclass: accommodate\n$/private/nim/elem/snd=answer(A)\nin($/shared/com, P)\n8\npre:\n>>>>>>>>>>>>>>><\n$\n$\ni\n$\ns\nd\nd\nd\ne\no\no\no\nm\nm\nm\nm\np\na\na\na\nt\ni\ni\ni\ny\nn\nn\nn\n($\n:\n:\n:\n/\n:\n:\n:\ns\nr\nr\nq\nh\ne\ne\nu\na\nl\nl\ne\ne\ne\nr\ns\nv\nv\nt\na\na\ne\ni\nn\nn\no\nd\nt\nt\nn\n/\n(\n(\n(\ni\nP\nA\nQ\nss\n,\n,\n)\nu\nQ\nQ\ne\n)\n)\ns)\n$domain :: depends(Q0, Q)\n>>>>>>>>>>>>>>>:\nd\n$\nin\ne\nd\n(\nl\no\n(\n$\n/\n/\nm\np\ns\na\nr\nh\ni\ni\na\nn\nv\nr\na\n:\ne\nt\n:\nd\ne\nr\n/\ne\n/\nc\nl\nb\ne\no\ne\nva\nl\nm\nn\n,\n,\nt\nP\n(\nP\nP\n0)\n0)\n0, Q0)\ndel(/shared/com, P0)\n8\neff: >>>>>><\np\np\nu\nu\ns\ns\nh\nh\n(\n(\n/\n/\ns\ns\nh\nh\na\na\nr\nr\ne\ne\nd\nd\n/\n/\ni\ni\ns\ns\ns\ns\nu\nu\ne\ne\ns\ns\n,\n,\nQ\nQ\n)\n0)\npush(/private/agenda, respond(Q0))\n>>>>>>:\nThis rule is similar to 6 except that is looks for a question which depends on the question\nit flnds corresponding to the answer provided by the user. It puts both question onto the\nlist of open issues and plans to respond to the dependent question. This rule, as currently\nimplemented, is speciflc to the particular case treated in the system. There is, of course, a\ngreat deal more to say about what it means for one question to be dependent on another\nand how the system knows whether it should respond to dependent questions or raise them\nwith the user.",
      "context_before": "182 CHAPTER 4. ADDRESSING UNRAISED ISSUES\n(",
      "context_after": "4.6.7 Opening up implicit grounding issues\nIn Chapter 3 we outlined a general issue-based account of grounding, where issues of con-\ntact, perception, understanding and acceptance of utterances may be raised and addressed.\nParts of this account were implemented in IBiS2, allowing the system e.g. to raise under-\nstanding questions regarding the user’s input (e.g. \\To Paris, is that correct?\"). This is\na case of explicitly raising the understanding-question which results in this question being\nun"
    },
    {
      "title": "rule 4 .9) rule: accommodateQUD2Issues",
      "section": "4.6. VARIETIESOFQUESTIONACCOMMODATIONANDREACCOMMODATION183",
      "page": 205,
      "content": "rule 4.9) rule: accommodateQUD2Issues\nclass: accommodate\n$/private/nim/elem/snd=answer(A)\nin($/shared/qud, Q)\npre: 8\n>>>< $domain :: relevant(A, Q)\nnot in($/shared/issues, Q)\neff:\n>>>:\npush(/shared/issues, Q)\nn\nThe rule in (rule 4.9) picks out a non-integrated answer-move which is relevant to a",
      "context_before": "erpretation\nwas correct, we can use this to allow the user to reject faulty system interpretations. Be-\nsides, we already have mechanisms in place for representing and dealing with answers to\nthe understanding-question.\nTo model the fact that the acceptance question regarding understanding is implicit rather\nthan explicit, we push it onto the local QUD only. If the user addresses it (e.g. by saying\n\\no\"), the implicit issue is \\opened up\", i.e. it becomes an open issue; it is pushed on\nISSUES.\n(",
      "context_after": "question on QUD which is not currently an open issue, and pushes it on issues.\nTo handle integration responses to positive understanding feedback, we also need to mod-\nify the integrateNegIcmAnswer rule described in Section 3.6.6. A signiflcant difierence\nbetween positive and interrogative feedback in IBiS is that the former is associated with\ncautiously optimistic grounding, while the latter is used in the pessimistic grounding strat-\negy. This means that a negative response to feedback on the"
    },
    {
      "title": "rule 4 .9) picks out a non-integrated answer-move which is relevant to a",
      "section": "4.6. VARIETIESOFQUESTIONACCOMMODATIONANDREACCOMMODATION183",
      "page": 205,
      "content": "rule 4.9) picks out a non-integrated answer-move which is relevant to a\nquestion on QUD which is not currently an open issue, and pushes it on issues.\nTo handle integration responses to positive understanding feedback, we also need to mod-\nify the integrateNegIcmAnswer rule described in Section 3.6.6. A signiflcant difierence\nbetween positive and interrogative feedback in IBiS is that the former is associated with\ncautiously optimistic grounding, while the latter is used in the pessimistic grounding strat-\negy. This means that a negative response to feedback on the understanding level must be\nhandled difierently depending on whether the content in question has been added to the\ndialogue gameboard or not. Speciflcally, if the positive feedback is rejected the optimistic\ngrounding assumption must be retracted.",
      "context_before": "odel the fact that the acceptance question regarding understanding is implicit rather\nthan explicit, we push it onto the local QUD only. If the user addresses it (e.g. by saying\n\\no\"), the implicit issue is \\opened up\", i.e. it becomes an open issue; it is pushed on\nISSUES.\n(rule 4.9) rule: accommodateQUD2Issues\nclass: accommodate\n$/private/nim/elem/snd=answer(A)\nin($/shared/qud, Q)\npre: 8\n>>>< $domain :: relevant(A, Q)\nnot in($/shared/issues, Q)\neff:\n>>>:\npush(/shared/issues, Q)\nn\nThe rule in (",
      "context_after": ""
    },
    {
      "title": "rule 4 .10) rule: integrateNegIcmAnswer",
      "section": "4.6. VARIETIESOFQUESTIONACCOMMODATIONANDREACCOMMODATION183",
      "page": 206,
      "content": "rule 4.10) rule: integrateNegIcmAnswer\nclass: integrate\n$/private/nim/fst/snd=answer(A)\nfst($/shared/issues, Q)\n8\npre:\n>>>>>>>>< $\nfs\nd\nt(\no\n$\nm\n/s\na\nh\nin\nar\n::\ned\nre\n/\ns\nq\no\nu\nlv\nd\nes\n,\n(\nQ\nA\n)\n, Q)\n$domain :: combine(Q, A, P)\n>>>>>>>>:\np\nP\no\n=\np(\nn\n/\no\np\nt(\nr\nu\ni\nn\nv\nd\na\n(\nt\nD\ne\nP\n/n\n*\ni\nC\nm\n)\n)\n)\npop(/shared/issues)\n8\neff:\n>>>>>>>>>>>>>>>>>>>>>>>< if d\n/\n/\n/\nC\no\ns\ns\ns\n(\n=\nh\nh\nh\nin\ni\na\na\na\ns\n(\ns\nr\nr\nr\n$\nu\n/\ne\ne\ne\ne\ns\nd\nd\nd\n(\nh\nQ\n/\n/\n/\na\ni\nq\nc\n0\ns\n)\nr\no\nu\ns\ne\na\nu\nm\nd\nn\nd\ne\nd\n:\n/\n:\ns\n=\n=\nc\ni\n:\nn\no\n=\n$\n$\n(\nm\n/\n/\n$\n$\np\np\n/\n,\n/\nr\ns\nr\nC\np\nh\ni\ni\nv\nr\n)\nv\na\na\na\ni\no\nr\nv\nt\nt\nr\ne\na\ne\ne\nd\nt\n/\n/\ne\n/\nt\nt\ni\n/\nm\nm\ns\nt\ns\np\np\nm\nu\n/\n/\ne\np\nD\nD\ns\n/\nP\n,\nP\nD\nQ\n/\n/\nP\nq\nc\n0)\n/\nu\no\n,\ni\nd\ns\nm\n[\nsues\n/private/agenda := $/private/tmp/DP/agenda\n>>>>>>>>>>>>>>>>>>>>>>>:\ni\np\nc\nn\nl\nu\ne\nit\ns\na\n/\nh\nr\np\ns\n(\n(\nh\nr\n/\n/\ni\np\np\ni\nf\nv\nt\nr\nr\n(\na\ni\ni\n/\nt\nv\nv\np\na\na\ne\nr\nt\nt\n/\ni\np\ne\ne\nv\nl\na\n/\n/\na\nn\na\nt\nn\ng\ni\ne\nm\n/\ne\n:\n)\nn\n=\nn\ni\nd\nm\n$\na\n)\n/\n,\np\ni\nr\ncm\niv\n:\na\nu\nt\nnd\ne\n*\n/\np\nt\no\nm\ns:\np\nD\n/D\nP*\nP\nn\n/\no\np\nt(\nl\nC\na\n)\nn\n)\n])\nThe rule in (rule 4.10) is similar to those for integrating \\normal\" user answers (see Sec-",
      "context_before": "184 CHAPTER 4. ADDRESSING UNRAISED ISSUES\n(",
      "context_after": "tion 3.6.6), because of the special nature of grounding issues, we include issue downdating\nin the rule rather than adding a further rule for downdating issues for this special case.\nThis means the rule has to check that the answer resolves the grounding issue, rather than\nmerely checking that it is relevant; this is done in the third condition. The content result-\ning from combining the issue on QUD and the answer is computed in the flfth condition.\nFinally, the sixth condition checks that the"
    },
    {
      "title": "rule 4 .10) is similar to those for integrating \\normal\" user answers (see Sec-",
      "section": "4.6. VARIETIESOFQUESTIONACCOMMODATIONANDREACCOMMODATION183",
      "page": 206,
      "content": "rule 4.10) is similar to those for integrating \\normal\" user answers (see Sec-\ntion 3.6.6), because of the special nature of grounding issues, we include issue downdating\nin the rule rather than adding a further rule for downdating issues for this special case.\nThis means the rule has to check that the answer resolves the grounding issue, rather than\nmerely checking that it is relevant; this is done in the third condition. The content result-\ning from combining the issue on QUD and the answer is computed in the flfth condition.\nFinally, the sixth condition checks that the content is not(und(DP*C)) where DP is a DP\nand C is the content that is being grounded (or in this case, not grounded).\nThe second update removes the grounding question from issues. The third update flrst\nchecks if C has been optimistically grounded. In this case, the optimistic grounding as-\nsumption regarding the grounding of C is retracted. This is where the new tmp/usr fleld,\ncontaining relevant parts of the information state as they were before the latest user utter-\nance was optimistically assumed to be grounded, is used. If C has not been optimistically\nassumed to be grounded, nothing in particular needs to be done.\nThe fourth update adds positive feedback that the system has understood that C was false.\nNote that not(C) is not added to /shared/com. The reason for this is that the negated\nproposition is not something that the user intended to add to the DGB - it was simply a\nresult of a misunderstanding by the system.",
      "context_before": "o\n=\n$\n$\n(\nm\n/\n/\n$\n$\np\np\n/\n,\n/\nr\ns\nr\nC\np\nh\ni\ni\nv\nr\n)\nv\na\na\na\ni\no\nr\nv\nt\nt\nr\ne\na\ne\ne\nd\nt\n/\n/\ne\n/\nt\nt\ni\n/\nm\nm\ns\nt\ns\np\np\nm\nu\n/\n/\ne\np\nD\nD\ns\n/\nP\n,\nP\nD\nQ\n/\n/\nP\nq\nc\n0)\n/\nu\no\n,\ni\nd\ns\nm\n[\nsues\n/private/agenda := $/private/tmp/DP/agenda\n>>>>>>>>>>>>>>>>>>>>>>>:\ni\np\nc\nn\nl\nu\ne\nit\ns\na\n/\nh\nr\np\ns\n(\n(\nh\nr\n/\n/\ni\np\np\ni\nf\nv\nt\nr\nr\n(\na\ni\ni\n/\nt\nv\nv\np\na\na\ne\nr\nt\nt\n/\ni\np\ne\ne\nv\nl\na\n/\n/\na\nn\na\nt\nn\ng\ni\ne\nm\n/\ne\n:\n)\nn\n=\nn\ni\nd\nm\n$\na\n)\n/\n,\np\ni\nr\ncm\niv\n:\na\nu\nt\nnd\ne\n*\n/\np\nt\no\nm\ns:\np\nD\n/D\nP*\nP\nn\n/\no\np\nt(\nl\nC\na\n)\nn\n)\n])\nThe rule in (",
      "context_after": ""
    },
    {
      "title": "Procedure/Rule in 4.6. VARIETIESOFQUESTIONACCOMMODATIONANDREACCOMMODATION187",
      "section": "4.6. VARIETIESOFQUESTIONACCOMMODATIONANDREACCOMMODATION187",
      "page": 209,
      "content": "4.6. VARIETIESOFQUESTIONACCOMMODATIONANDREACCOMMODATION187\npop(/private/nim)\npop(/shared/issues)\n8\nif do(in($/shared/com, issue(?A.price(A))) or\n>>>>>>>>>>>>>>>>>><\n/\n/\n/\n/\nis\ns\np\ns\ns\ns\nh\nh\nh\nu\nr\ne\na\na\na\niv\n(\nr\nr\nr\n?\na\ne\ne\ne\nA\nt\nd\nd\nd\n.\ne\np\n/\n/\n/\n/\nr\nc\ni\nq\na\ni\ns\nc\no\nu\ns\ng\ne\nu\nm\nd\n(\ne\nA\ne\nn\n:\n:\ns\n)\n=\n=\nd\n)\n:\na\n=\n=\n$\n$\ni\n/\n:\n/\ns\n=\n$\np\ns\np\nu\n/\nr\nr\n$\ne\np\ni\ni\n(\n/\nv\nr\nv\nD\np\na\na\niv\nr\nt\nt\n)\na\ni\ne\ne\na\nv\nt\n/\n/\nn\na\ne\nt\nt\nd\nt\n/\nm\nm\ne\nt\ni\np\nn\np\n/\nm\n/\nt\n(\n/\np\n$\nu\nu\nm\n/\n/\ns\ns\np\ns\nu\nr\nr\nh\n/\ns\n/\n/\nu\na\nr\nq\nc\ns\n/\nr\nu\no\nr\ni\ne\nd\ns\nm\n/\nd\ns\na\nu\n/\ng\ni\ne\ns\ne\ns\ns\nn\nu\nd\ne\na\ns, D), [\n/private/plan := $/private/tmp/usr/plan ])\n>>>>>>>>>>>>>>>>>>:\ndow\np\ni\nc\nn\nl\nu\nn\ne\nit\ns\na\nd\nh\nr\ns\na\n(\n(\nh\n/\n/\nt\ni\ne\np\np\nft\nQ\nr\nr\n(\ni\ni\n/\nU\nv\nv\np\na\na\nr\nD\nt\nt\ni\ne\ne\nv\n/\n/\na\nn\na\nt\ng\ni\ne\nm\n/\ne\n)\nn\nn\ni\nd\nm\na\n)\n, icm:und*pos:usr*not(issue(?A.price(A))))\nicm:loadplan\nagenda =\nicm:und*pos:usr*not(issue(?A.price(A)))\n2 2 ¿¿ (cid:192)(cid:192) 3 3\nplan = hi\n6 6 bel = fg 7 7\n6 6 7 7\n6 6 com = fg 7 7\n6 private = 6 7 7\n6 6 qud = hi 7 7\n6 6 2 2 3 3 7 7\n6 6 tmp = usr = issues = hi 7 7\n6 6 7 7\n6 6 6 6 agenda = hhii 7 7 7 7\n6 6 6 6 7 7 7 7\n6 6 6 6 plan = hi 7 7 7 7\n6 6 6 6 7 7 7 7\n6 6 nim = h4hii 4 5 5 7 7\n6 6 7 7\n6 4 com = fg 5 7\n6 7\n6 issues = hi 7\n6 2 3 7\n6 qud = hi 7\n6 shared = 7\n6 6 pm = icm:und*pos:usr*issue(?A.price(A)), icm:acc*pos 7 7\n6 6 7 7\n6 6 speaker = usr 7 7\n6 6 lu = ' “ 7 7\n6 6 moves = answer(not(und(usr*issue(?A.price(A))))) 7 7\n6 6 • ‚ 7 7\n4 4 5 5\n' “\nbackupSharedSys\nselectIcmOther\nS> You did not ask about price.\nFeedback for utterances realizing several moves\nIn the case where a user utterance provides answers to several questions (and perhaps\nalso asks a question), the strategy we have chosen is to produce feedback for each move\nindividually to give the user a chance to correct mishearings or misunderstandings. If\npositive feedback regarding one piece of information is rejected, the optimistic assumption\nisretractedbymodifyingtheinformationstateaccordingtothe/private/tmp/usrsaved\nstate. If feedback regarding one piece of information is accepted, this information should\nnot disappear if a later feedback utterance from the system should be rejected.",
      "context_before": "",
      "context_after": ""
    },
    {
      "title": "rule 4 .11) rule: integratePosIcmAnswer",
      "section": "4.6. VARIETIESOFQUESTIONACCOMMODATIONANDREACCOMMODATION189",
      "page": 211,
      "content": "rule 4.11) rule: integratePosIcmAnswer\nclass: integrate\n$/private/nim/fst/snd=answer(A)\nfst($/shared/issues, Q)\n8\npre:\n>>>>>>>>< $\nfs\nd\nt(\no\n$\nm\n/s\na\nh\nin\nar\n::\ned\nre\n/\ns\nq\no\nu\nlv\nd\nes\n,\n(\nQ\nA\n)\n, Q)\n$domain :: combine(Q, A, P)\n>>>>>>>>:\np\nP\no\n=\np(\nu\n/\nn\np\nd\nr\n(D\niv\nP\nat\n*\ne\nC\n/\no\nn\nn\ni\nt\nm\nen\n)\nt)\npop(/shared/issues)\n8\neff:\n>>>>>>>>>>>>>>>>>>>>>>>>>>><\ni\ni\nf\nf t\nd\na\np\np\np\nh\no\nd\nu\nu\nu\ne\n(\nn\nd\nn\ns\ns\ns\nh\nh\nh\n(\no\ne\n/\n(\n(\n(\nt\nl\n/\n/\n/\np\ns\n(\np\np\np\ne\nr\n(\nr\nr\nr\ni\ni\nn\nC\nv\ni\ni\ni\n(\nv\nv\nv\na\no\n$\na\na\na\nt\nn\n/\nt\nt\nt\ne\nt\ns\ne\ne\ne\ne\nh\n/\nn\n/\n/\n/\nt\na\nt\nt\nt\nt\nm\nr\n=\nm\nm\nm\ne\np\nis\np\np\np\nd\n/\ns\n/\n/\n/\nD\nu\n/\nD\nD\nD\ne\nc\nP\n(\no\nP\nP\nP\nQ\n/\nm\n/\n/\n/\nc\n0)\na\ni\nq\n,\no\n,\ns\ng\nu\nC\ns\nm\n[\nu\ne\nd\no\n,\nn\ne\n,\nn\nC\ns\nd\nQ\nte\n,\no\na\n0\nn\nn\nQ\n)\n,\nt\nt\nr\n)\n0\ne\n)\ne\nn\no\ns\nt\np\nr\n)\no\n)\nnd(Q0)) ],\nContent=issue(Q0) and in($/shared/issues, Q0) ),\n>>>>>>>>>>>>>>>>>>>>>>>>>>>:\na\nif\nd\nt\nd\np\np\np\nh\n(\nu\nu\nu\ne\n/\nn\ns\ns\ns\ns\nh\nh\nh\nh\ne\n(\n(\n(\na\nl\n/\n/\n/\ns\nr\np\ns\ns\ne\nh\nh\n(\ne\nr\nC\na\na\nd\niv\no\nr\nr\n/\na\nn\nc\ne\ne\nt\nt\no\nd\nd\ne\ne\nm\n/\n/\nn\n/\ni\nq\nt\na\n,\ns\n=\nu\ns\ng\nC\nu\nd\ni\ne\ns\no\ne\n,\ns\nn\nn\nu\ns\nQ\nd\nt\ne\n,\ne\n(\na\n0\nQ\nn\n)\nQ\n,\nt\n0\n0\n)\nr\n)\n)\ne\n)\n,\n)\nsp\n[\nond(Q0)) ],\nThe conditions are similar to those of the previous version of the rule, except for inspecting\nissues instead of qud. The flrst two updates are also the same. The third update adds the\ncontent Content which is being grounded to tmp/usr (in case DP is usr, which it always\nis in IBiS3). This means that if future feedback (concerning the same utterance) from the\nsystem is rejected, the system will backtrack to a state where Content is integrated. The\nconditionals in the third and fourth updates re(cid:176)ect the fact that questions are integrated\ndifierently from propositions. The fourth update is similar to the third update in the\nprevious version of the rule.\nImplicit acceptance\nBefore we move on there is one more thing to consider. If the user does not reject the\nsystem’s positive feedback concerning a piece of information, this is regarded as an implicit\nacceptance. Therefore, we also need to add a noFollowup rule, for cases where positive\nsystem feedback is not responded to at all (i.e. the user does not take the turn ofiered).",
      "context_before": "4.6. VARIETIESOFQUESTIONACCOMMODATIONANDREACCOMMODATION189\n(",
      "context_after": ""
    },
    {
      "title": "rule 4 .12) rule: noFollowup",
      "section": "4.6. VARIETIESOFQUESTIONACCOMMODATIONANDREACCOMMODATION189",
      "page": 212,
      "content": "rule 4.12) rule: noFollowup\nclass: (none)\n$input, ’TIMED OUT’\npre:\nin($/shared/pm, icm:und*pos:usr*Content)\n(\nif then else(Content=issue(Q), [\npush(/private/tmp/usr/qud, Q)\n8\neff: >>>>>>< p\np\nu\nu\ns\ns\nh\nh\n(\n(\n/\n/\np\np\nr\nr\ni\ni\nv\nv\na\na\nt\nt\ne\ne\n/\n/\nt\nt\nm\nm\np\np\n/\n/\nu\nu\ns\ns\nr\nr\n/\n/\ni\na\ns\ng\nsu\nen\nes\nd\n,\na\nQ\n, r\n)\nespond(Q)) ],\nadd(/private/tmp/usr/com, Content))\n>>>>>>:\nThe flrst condition is true only if the user did not produce any utterance (that the system\nheard) during her latest turn11. The second condition checks that the moves performed in\nthe previous utterance includes positive understanding feedback regarding Content. The\nflrst updates are identical to the third update in the integratePosIcmAnswer rule in\nSection 4.6.7.\nBelow is a dialogue example involving positive, implicit positive, and negative followups\nto system feedback.\n(dialogue 4.12)\nS> Welcome to the travel agency!\nU> price information please\nS> Okay. Lets see. How do you want to travel?\nU> a flight to paris in april\nS> Okay. by flight.\nU> yes\nS> to paris.\nU>\nS> in april.\nU> no\nS> not in april. What city do you want to go to?\nImplicit questions and elliptical answers\nIn the case of implicit acceptance questions in English (and Swedish) it appears that they\ncan be addressed by short answers; however, we cannot assume that all implicit issues\ncan be addressed elliptically. The use of QUD for storing implicit issues relies on the fact\n11See Section 3.6.6 for an explanation of ’TIMED OUT’.",
      "context_before": "190 CHAPTER 4. ADDRESSING UNRAISED ISSUES\n(",
      "context_after": ""
    },
    {
      "title": "rule 4 .13) rule: backupSharedUsr",
      "section": "4.7. FURTHER IMPLEMENTATION ISSUES 193",
      "page": 215,
      "content": "rule 4.13) rule: backupSharedUsr\nclass: (none)\n$latest speaker=usr\n$latest moves=Moves\n8\npre:\n>>>>>>>>>>><\nn\nn\nn\no\no\no\nt\nt\nt\ni\ni\n(\nn\nn\nf\n(\n(\ns\nM\nM\nt($\no\no\n/\nv\nv\ns\ne\ne\nh\ns\ns\n,\n,\na\nn\ni\nr\nc\no\nm\ned\nm\n:X\n/\no\nq\n)\nv\nu\ne)\nd, und(usr*C)) and\nin(A, answer(D)) and\n>>>>>>>>>>>:\n/pr\n$\ni\nd\nva\no\nt\nm\ne\na\n/\ni\nt\nn\nm\n:\np\n:\n/\nr\nu\nel\ns\ne\nr\nv\n/\na\nq\nnt\nu\n(\nd\nD,\n:=\nun\n$\nd\n/\n(\ns\nu\nh\nsr\na\n*\nr\nC\ne\n)\nd\n))\n/qud\n/private/tmp/usr/issues := $/shared/issues\n8\neff: >>>>>>< /\n/\np\np\nr\nr\ni\ni\nv\nv\na\na\nt\nt\ne\ne\n/\n/\nt\nt\nm\nm\np\np\n/\n/\nu\nu\ns\ns\nr\nr\n/\n/\nc\na\no\ng\nm\nen\n:\nd\n=\na\n$\n:\n/\n=\nsh\n$\na\n/p\nr\nr\ne\ni\nd\nv\n/\na\nc\nt\no\ne\nm\n/agenda\n/private/tmp/usr/plan := $/private/plan\n>>>>>>:\nThe flrst condition checks that the latest speaker was indeed the user; if not, the rule\nshould of course not trigger. The next four conditions are used to prevent triggering in\ncase of an ICM subdialog, i.e. if the user produced an ICM move or responded to one from\nthe system. (Note that no move may count as implicit ICM if the user does not respond to\nICM from the system; see Section 4.6.7). The flfth condition checks if the user utterance\ncontains an answer relevant to a grounding-question on QUD. The efiects simply copy the\ncontents of tmp/usr to the corresponding paths in the information state.\nIntegration rules and nim\nIn IBiS2, the integration rules inspect nim using the condition in(/private/nim, Moves).\nSince TrindiKit uses backtracking to flnd instantiations of variables in conditions (see\nAppendix A), this results in each integration rule looking through the whole queue of non-\nintegrated moves. Thus, in IBiS2 the ordering of the integration rules determines which\nmove is integrated flrst. This is okay for dialogues with a very simple structure, but when\ndialogues become more complex (e.g. because of accommodation), the ordering of the\nmoves becomes more important.\nTherefore, in IBiS3 all integration rules inspect only the flrst move on the nim queue, using\ntheconditionfst(/private/nim, Move)orsimilar. Incombinationwiththequeue-shifting\ntechnique described in Section 4.7.2, this means that the algorithm tries to integrate moves\nin the order they were performed.",
      "context_before": "4.7. FURTHER IMPLEMENTATION ISSUES 193\n(",
      "context_after": ""
    },
    {
      "title": "Procedure/Rule in 4.8.1 Phrase spotting and syntax in (cid:176)exible dialogue",
      "section": "4.8.1 Phrase spotting and syntax in (cid:176)exible dialogue",
      "page": 219,
      "content": "4.8. DISCUSSION 197\n4.7.3 Selection module\nThe selection module is almost unchanged from IBiS2. Some minor adjustments have been\nmade to adapt the rules to the changes in the information state type: that objects in nim\nare pairs of DPs and moves, and that tmp is divided into two substructures.\n4.8 Discussion\nIn this section we discuss some variations on IBiS3, show some additional \\emergent\"\nfeatures, and discuss various aspects of question accommodation.\n4.8.1 Phrase spotting and syntax in (cid:176)exible dialogue\nAs it turns out, IBiS3 sometimes runs into trouble if the interpreter recognizes several\nanswers to the same question in an utterance. Whereas IBiS2 would simply integrate the\nflrst answer and ignore the second, IBiS3 will try to make sense of all the moves in an\nutterance, which may lead to problems if the accommodation rules are not designed to\ncover the case at hand.\nFor example, if the system recognizes \\paris to london\" as a flrst utterance in a dialogue,\nthe system will try dependent issue accommodation (see Section 4.6.4) and note that the\nset of answers (answer(paris) and answer(dest city(london))) is (indirectly) relevant to\nboth the price issue and the visa issue. It might seem that this is wrong, since the two\nanswers are in fact relevant to the same question (regarding destination city) in the \\visa\"\nplan, whereas it is relevant to two separate questions (destination and departure city) in\nthe \\price\" plan, so it should be indirectly relevant only to the \\price\" issue. But in\ngeneral, one cannot require that the two answers must be answers to difierent questions,\nsince the second answer may be a correction of the flrst. This may of course be signalled\nmore clearly, as in \\to paris uh no to london\", but the correction signals may be left out,\ninaudible, or not recognized.\nOne way to solve this problem is to sometimes look for constructions which realize more\nthan one move, and do some \\cleaning up\" in the interpretation phase so that the DME\nwill not get into trouble. For example, we can add a lexical entry looking for phrases\nof the form \\X to Y\" and interpret this as \\from X to Y\", i.e. answer(dept city(X))\nandanswer(dest city(Y)).\nA related problem occurs if the user flrst chooses Gothenburg as departure city and then",
      "context_before": "",
      "context_after": ""
    },
    {
      "title": "procedure may also have side-efiects (e.g. loading a new",
      "section": "4.8.6 Accommodation vs. normal integration",
      "page": 224,
      "content": "procedure may also have side-efiects (e.g. loading a new\ndialogue plan) which serve to drive the dialogue forward.\nInstead of giving rules for accommodation and integration separately, one could deny the\nexistence of accommodation and just give more complex integration rules. The integration\nrule for short answers requires that there is a question on the QUD to which the latest\nmove is an appropriate answer, and the accommodation rules are used if no such question\ncan be found. The alternative is to skip the QUD requirement, thus incorporating the\naccommodation mechanisms into the integration rule, which would then split into several\nrules. For example, there would be one rule for integrating answers by matching them to\nquestions in the plan directly.\nApart from the theoretical argument that question accommodation provides a generaliza-\ntion of the way answers are integrated, there are also practical motivations. In particular,",
      "context_before": "ny real difierence to the internal\nprocessing and/or external behaviour of the system remains a future research issue. For\nexample, if QUD is updated with Q before A is produced, and the utterance realizing A\nis interrupted, should Q be removed from QUD?\n4.8.6 Accommodation vs. normal integration\nAs we have seen, question accommodation allows a generalized account for how answers\nare integrated into the information state, regardless of the status of the corresponding\nquestion. The accommodation",
      "context_after": ""
    },
    {
      "title": "Procedure/Rule in 4.9 Summary",
      "section": "4.9 Summary",
      "page": 225,
      "content": "4.9. SUMMARY 203\nthe fact that several steps of accommodation may be necessary to integrate a single answer\nmeans that the total number of rules for integrating answers would be higher if accom-\nmodation was not used - one would need at least one integration rule for each possible\ncombination of accommodation rules.\nA further argument which is not explored in this thesis (but see Engdahl et al., 1999) is\nthatquestionpresuppositionandaccommodationinteractwithintra-sententialinformation\nstructure in interesting and useful ways.\n4.8.7 Dependent issue accommodation in VoiceXML?\nOn a close reading of the VoiceXML speciflcation (McGlashan et al., 2001), it may ap-\npear that VoiceXML ofiers a mechanism similar to dependent issue accommodation12. In\nVoiceXML, a grammar can have scope over a single slot, over a form, or over a whole\ndocument (containing several forms). Given a grammar with document scope (deflning a\nset of sentences which the VoiceXML interpreter will listen for during the whole dialogue),\nif the user gives information which does not match the currently active form, VoiceXML\nwill jump to a form matching the input13. This corresponds roughly to the dependent issue\naccommodation mechanism in IBiS . However, if input matches more than one task (e.g.\n\\raise the volume\" could match a task related to the TV or one related to the CD player),\nVoiceXML will not ask which of these tasks the user wants to perform but instead go to\nthe one it flnds flrst, regardless of what the user intended. Generally, it is hard to see how\nclariflcation questions could be handled in a general way in VoiceXML, since they do not\nbelong to a particular form.\n4.9 Summary\nTo enable more (cid:176)exible dialogue behaviour, we made a distinction between a local and\na global QUD (referring to the latter as \\open issues\", or just \\issues\"). The notions of\n12ThisdiscussionisbasedontheVoiceXMLspeciflcationratherthanhands-onexperienceofVoiceXML.\nThis means that some unclarity remains about the capabilities of VoiceXML in general, and individual\nimplementations of VoiceXML servers in particular. For both these reasons, the discussion should be\nregarded as tentative and open for revision. However, it should also be pointed out that it is fairly\nclear what is supported in VoiceXML; most of the unclarities refer to what is possible, but not explicitly\nsupported, in VoiceXML. In general, it is more important to know what is supported by a standard than\nwhat is possible, since almost anything is possible in any programming environment (given a su–cient\nnumber of hacks).\n13Although the VoiceXML documentation does not provide any examples of this kind of behaviour, it\nappears to be possible, at least in principle.",
      "context_before": "",
      "context_after": ""
    },
    {
      "title": "rule 5 .1).",
      "section": "5.6.2 Executing device actions",
      "page": 238,
      "content": "rule 5.1).\n(rule 5.1) rule: integrateUsrRequest\nclass: integrate\n$/private/nim/fst/snd=request(A)\n$/shared/lu/speaker==usr\n8\npre: >>>>>><\nS\n$s\nc\nc\no\no\nre\nre\n>\n=\n0\nS\n.7\ncore\n$domain :: plan(A, Plan)\n>>>>>>:\npop(/private/nim)\nadd(/shared/lu/moves, request(A))\n8\neff:\n>>>>>>>>>>>< p\nif\nu\nd\ns\np\no\nh\nu\n(\n(\nS\ns\n/\nh\np\nc\n(\no\nr\n/\nr\ni\np\nv\ne\nr\na\n•\ni\nt\nv\ne\na\n0\n/\nt\n.9\na\ne\n,\ng\n/\ne\na\nn\ng\nd\ne\na\nn\n,\nd\ni\na\ncm\n, i\n:\nc\na\nm\ncc\n:u\n*\nn\np\nd\no\n*\ns)\npos:usr*action(A)))\npush(/shared/actions, A)\n>>>>>>>>>>>:\npush(/private/agenda, A)\nThis rule is similar to that for integrating user ask moves (see Section 3.6.6); instead of\npushing an issue Q on ISSUES and QUD, and pushing respond(Q) on the agenda, this rule\npushes the requested action A on /shared/actions and /private/agenda.\nAs for user ask moves we also need to deal with the case where the system must reject an\naction since it does not have a plan for dealing with it. This rule is shown in (rule 5.2).",
      "context_before": "216 CHAPTER 5. ACTION-ORIENTED AND NEGOTIATIVE DIALOGUE\nThe rule for integrating user requests is shown in (",
      "context_after": "(rule 5.2) rule: rejectAction\nclass: select action\nin($/private/nim, request(A))\npre: $/shared/lu/speaker=usr\n8\n>< not $domain :: plan(A, Plan)\ndel(/private/nim, request(A))\n>:\neff: push(/private/agenda, icm:und*pos:usr*action(A))\n8\n>< push(/private/agenda, icm:acc*neg:action(A))\n>:\n5.6.2 Executing device actions\nThe update rule for executing the dev do device action is shown in (rule 5.3)."
    },
    {
      "title": "rule 5 .1) rule: integrateUsrRequest",
      "section": "5.6.2 Executing device actions",
      "page": 238,
      "content": "rule 5.1) rule: integrateUsrRequest\nclass: integrate\n$/private/nim/fst/snd=request(A)\n$/shared/lu/speaker==usr\n8\npre: >>>>>><\nS\n$s\nc\nc\no\no\nre\nre\n>\n=\n0\nS\n.7\ncore\n$domain :: plan(A, Plan)\n>>>>>>:\npop(/private/nim)\nadd(/shared/lu/moves, request(A))\n8\neff:\n>>>>>>>>>>>< p\nif\nu\nd\ns\np\no\nh\nu\n(\n(\nS\ns\n/\nh\np\nc\n(\no\nr\n/\nr\ni\np\nv\ne\nr\na\n•\ni\nt\nv\ne\na\n0\n/\nt\n.9\na\ne\n,\ng\n/\ne\na\nn\ng\nd\ne\na\nn\n,\nd\ni\na\ncm\n, i\n:\nc\na\nm\ncc\n:u\n*\nn\np\nd\no\n*\ns)\npos:usr*action(A)))\npush(/shared/actions, A)\n>>>>>>>>>>>:\npush(/private/agenda, A)\nThis rule is similar to that for integrating user ask moves (see Section 3.6.6); instead of\npushing an issue Q on ISSUES and QUD, and pushing respond(Q) on the agenda, this rule\npushes the requested action A on /shared/actions and /private/agenda.\nAs for user ask moves we also need to deal with the case where the system must reject an\naction since it does not have a plan for dealing with it. This rule is shown in (rule 5.2).",
      "context_before": "216 CHAPTER 5. ACTION-ORIENTED AND NEGOTIATIVE DIALOGUE\nThe rule for integrating user requests is shown in (rule 5.1).\n(",
      "context_after": "(rule 5.2) rule: rejectAction\nclass: select action\nin($/private/nim, request(A))\npre: $/shared/lu/speaker=usr\n8\n>< not $domain :: plan(A, Plan)\ndel(/private/nim, request(A))\n>:\neff: push(/private/agenda, icm:und*pos:usr*action(A))\n8\n>< push(/private/agenda, icm:acc*neg:action(A))\n>:\n5.6.2 Executing device actions\nThe update rule for executing the dev do device action is shown in (rule 5.3)."
    },
    {
      "title": "rule 5 .2).",
      "section": "5.6.2 Executing device actions",
      "page": 238,
      "content": "rule 5.2).\n(rule 5.2) rule: rejectAction\nclass: select action\nin($/private/nim, request(A))\npre: $/shared/lu/speaker=usr\n8\n>< not $domain :: plan(A, Plan)\ndel(/private/nim, request(A))\n>:\neff: push(/private/agenda, icm:und*pos:usr*action(A))\n8\n>< push(/private/agenda, icm:acc*neg:action(A))\n>:",
      "context_before": "os:usr*action(A)))\npush(/shared/actions, A)\n>>>>>>>>>>>:\npush(/private/agenda, A)\nThis rule is similar to that for integrating user ask moves (see Section 3.6.6); instead of\npushing an issue Q on ISSUES and QUD, and pushing respond(Q) on the agenda, this rule\npushes the requested action A on /shared/actions and /private/agenda.\nAs for user ask moves we also need to deal with the case where the system must reject an\naction since it does not have a plan for dealing with it. This rule is shown in (",
      "context_after": "5.6.2 Executing device actions\nThe update rule for executing the dev do device action is shown in (rule 5.3)."
    },
    {
      "title": "rule 5 .2) rule: rejectAction",
      "section": "5.6.2 Executing device actions",
      "page": 238,
      "content": "rule 5.2) rule: rejectAction\nclass: select action\nin($/private/nim, request(A))\npre: $/shared/lu/speaker=usr\n8\n>< not $domain :: plan(A, Plan)\ndel(/private/nim, request(A))\n>:\neff: push(/private/agenda, icm:und*pos:usr*action(A))\n8\n>< push(/private/agenda, icm:acc*neg:action(A))\n>:",
      "context_before": "n(A)))\npush(/shared/actions, A)\n>>>>>>>>>>>:\npush(/private/agenda, A)\nThis rule is similar to that for integrating user ask moves (see Section 3.6.6); instead of\npushing an issue Q on ISSUES and QUD, and pushing respond(Q) on the agenda, this rule\npushes the requested action A on /shared/actions and /private/agenda.\nAs for user ask moves we also need to deal with the case where the system must reject an\naction since it does not have a plan for dealing with it. This rule is shown in (rule 5.2).\n(",
      "context_after": "5.6.2 Executing device actions\nThe update rule for executing the dev do device action is shown in (rule 5.3)."
    },
    {
      "title": "rule 5 .3) rule: exec dev do",
      "section": "5.6.3 Selecting and integrating conflrm-moves",
      "page": 239,
      "content": "rule 5.3) rule: exec dev do\nclass: exec plan\npre: fst($/private/plan, dev do(Dev, A ))\ndev\nn pop(/private/plan)\n! $/shared/com=PropSet\neff: 8\n>>>< devices/Dev :: dev do(PropSet, A\ndev\n)\nadd(/private/bel, done(A ))\ndev\n>>>:\nThe condition looks for a dev do upnp action in the plan, with arguments Dev, the device\npath name, and A , the device action. The updates pop the action ofi the plan, and\ndev\napplies the corresponding update dev do(PropSet, A ) to the device Dev. Finally, the\ndev\nproposition done(A ) is added the the private beliefs.\ndev\nIn addition, we have implemented rules for executing the dev get, dev set and dev query\nactions.",
      "context_before": "5.6. UPDATE RULES AND DIALOGUE EXAMPLES 217\n(",
      "context_after": "5.6.3 Selecting and integrating conflrm-moves\nThe selection rule for the conflrm action is shown in (rule 5.4).\n(rule 5.4) rule: selectConflrmAction\nclass: select action\nfst($/shared/actions, A)\n$domain :: postcond(A, PC)\npre: 8\n>>>< in($/private/bel, PC)\nnot in($/shared/com, PC)\neff:\n>>>:\npush(/private/agenda, conflrm(A))\nn\nThe conditions in this rule check that the there is an action in /shared/actions whose\npostcondition is believed by the system to be true, however, this is not yet shared i"
    },
    {
      "title": "rule 5 .4).",
      "section": "5.6.3 Selecting and integrating conflrm-moves",
      "page": 239,
      "content": "rule 5.4).\n(rule 5.4) rule: selectConflrmAction\nclass: select action\nfst($/shared/actions, A)\n$domain :: postcond(A, PC)\npre: 8\n>>>< in($/private/bel, PC)\nnot in($/shared/com, PC)\neff:\n>>>:\npush(/private/agenda, conflrm(A))\nn\nThe conditions in this rule check that the there is an action in /shared/actions whose\npostcondition is believed by the system to be true, however, this is not yet shared infor-\nmation. If this is true, a conflrm action is pushed on the agenda. Eventually, this action\n(which also is a dialogue move) is moved to next moves by (rule 5.5).",
      "context_before": "r a dev do upnp action in the plan, with arguments Dev, the device\npath name, and A , the device action. The updates pop the action ofi the plan, and\ndev\napplies the corresponding update dev do(PropSet, A ) to the device Dev. Finally, the\ndev\nproposition done(A ) is added the the private beliefs.\ndev\nIn addition, we have implemented rules for executing the dev get, dev set and dev query\nactions.\n5.6.3 Selecting and integrating conflrm-moves\nThe selection rule for the conflrm action is shown in (",
      "context_after": "(rule 5.5) rule: selectConflrm\nclass: select move\npre: fst($/private/agenda, conflrm(A))\nn push(next moves, conflrm(A))\neff:\npop(/private/agenda)\n("
    },
    {
      "title": "rule 5 .4) rule: selectConflrmAction",
      "section": "5.6.3 Selecting and integrating conflrm-moves",
      "page": 239,
      "content": "rule 5.4) rule: selectConflrmAction\nclass: select action\nfst($/shared/actions, A)\n$domain :: postcond(A, PC)\npre: 8\n>>>< in($/private/bel, PC)\nnot in($/shared/com, PC)\neff:\n>>>:\npush(/private/agenda, conflrm(A))\nn\nThe conditions in this rule check that the there is an action in /shared/actions whose\npostcondition is believed by the system to be true, however, this is not yet shared infor-\nmation. If this is true, a conflrm action is pushed on the agenda. Eventually, this action\n(which also is a dialogue move) is moved to next moves by (rule 5.5).",
      "context_before": "pnp action in the plan, with arguments Dev, the device\npath name, and A , the device action. The updates pop the action ofi the plan, and\ndev\napplies the corresponding update dev do(PropSet, A ) to the device Dev. Finally, the\ndev\nproposition done(A ) is added the the private beliefs.\ndev\nIn addition, we have implemented rules for executing the dev get, dev set and dev query\nactions.\n5.6.3 Selecting and integrating conflrm-moves\nThe selection rule for the conflrm action is shown in (rule 5.4).\n(",
      "context_after": "(rule 5.5) rule: selectConflrm\nclass: select move\npre: fst($/private/agenda, conflrm(A))\nn push(next moves, conflrm(A))\neff:\npop(/private/agenda)\n("
    },
    {
      "title": "rule 5 .5).",
      "section": "5.6.3 Selecting and integrating conflrm-moves",
      "page": 239,
      "content": "rule 5.5).\n(rule 5.5) rule: selectConflrm\nclass: select move\npre: fst($/private/agenda, conflrm(A))\nn push(next moves, conflrm(A))\neff:\npop(/private/agenda)\n(",
      "context_before": "select action\nfst($/shared/actions, A)\n$domain :: postcond(A, PC)\npre: 8\n>>>< in($/private/bel, PC)\nnot in($/shared/com, PC)\neff:\n>>>:\npush(/private/agenda, conflrm(A))\nn\nThe conditions in this rule check that the there is an action in /shared/actions whose\npostcondition is believed by the system to be true, however, this is not yet shared infor-\nmation. If this is true, a conflrm action is pushed on the agenda. Eventually, this action\n(which also is a dialogue move) is moved to next moves by (",
      "context_after": ""
    },
    {
      "title": "rule 5 .5) rule: selectConflrm",
      "section": "5.6.3 Selecting and integrating conflrm-moves",
      "page": 239,
      "content": "rule 5.5) rule: selectConflrm\nclass: select move\npre: fst($/private/agenda, conflrm(A))\nn push(next moves, conflrm(A))\neff:\npop(/private/agenda)\n(",
      "context_before": "on\nfst($/shared/actions, A)\n$domain :: postcond(A, PC)\npre: 8\n>>>< in($/private/bel, PC)\nnot in($/shared/com, PC)\neff:\n>>>:\npush(/private/agenda, conflrm(A))\nn\nThe conditions in this rule check that the there is an action in /shared/actions whose\npostcondition is believed by the system to be true, however, this is not yet shared infor-\nmation. If this is true, a conflrm action is pushed on the agenda. Eventually, this action\n(which also is a dialogue move) is moved to next moves by (rule 5.5).\n(",
      "context_after": ""
    },
    {
      "title": "rule 5 .6).",
      "section": "5.6.4 Dialogue example: menu traversal and multiple threads",
      "page": 240,
      "content": "rule 5.6).\n(rule 5.6) rule: integrateConflrm\nclass: integrate\npre: $/private/nim/fst/snd=conflrm(A)\nn pop(/private/nim)\neff:\nadd(/shared/com, done(A))\n(\nThis rule adds the proposition done(A) to the shared commitments which enables the\ndowndateActions rule in (rule 5.7) to trigger.\n(rule 5.7) rule: downdateActions",
      "context_before": "218 CHAPTER 5. ACTION-ORIENTED AND NEGOTIATIVE DIALOGUE\nWhen the conflrmation move has been made, it is integrated by the rule in (",
      "context_after": "class: downdate issues\nfst($/shared/actions, A)\npre: $domain :: postcond(A, PC)\n8\n>< in($/shared/com, PC )\neff: >: pop(/shared/actions)\nn\nThis rule removes an action A whose postcondition is jointly believed to be true from\nactions2.\n5.6.4 Dialogue example: menu traversal and multiple threads\nIn (dialogue 5.1) we show a sample dialogue interaction with the menu-based VCR\napplication. It shows both menu traversal and accommodation, as well as dealing with\nmultiple tasks (issues and actions).\n(di"
    },
    {
      "title": "rule 5 .6) rule: integrateConflrm",
      "section": "5.6.4 Dialogue example: menu traversal and multiple threads",
      "page": 240,
      "content": "rule 5.6) rule: integrateConflrm\nclass: integrate\npre: $/private/nim/fst/snd=conflrm(A)\nn pop(/private/nim)\neff:\nadd(/shared/com, done(A))\n(\nThis rule adds the proposition done(A) to the shared commitments which enables the\ndowndateActions rule in (rule 5.7) to trigger.\n(rule 5.7) rule: downdateActions\nclass: downdate issues\nfst($/shared/actions, A)\npre: $domain :: postcond(A, PC)\n8\n>< in($/shared/com, PC )\neff: >: pop(/shared/actions)\nn\nThis rule removes an action A whose postcondition is jointly believed to be true from\nactions2.",
      "context_before": "218 CHAPTER 5. ACTION-ORIENTED AND NEGOTIATIVE DIALOGUE\nWhen the conflrmation move has been made, it is integrated by the rule in (rule 5.6).\n(",
      "context_after": "5.6.4 Dialogue example: menu traversal and multiple threads\nIn (dialogue 5.1) we show a sample dialogue interaction with the menu-based VCR\napplication. It shows both menu traversal and accommodation, as well as dealing with\nmultiple tasks (issues and actions).\n(dialogue 5.1)\nS> Welcome to the VCR manager!\nS> Lets see. What can I do for you?\nU>\n2Note that done(fi) is trivially a postcondition for any action fi."
    },
    {
      "title": "rule 5 .7) to trigger.",
      "section": "5.6.4 Dialogue example: menu traversal and multiple threads",
      "page": 240,
      "content": "rule 5.7) to trigger.\n(rule 5.7) rule: downdateActions\nclass: downdate issues\nfst($/shared/actions, A)\npre: $domain :: postcond(A, PC)\n8\n>< in($/shared/com, PC )\neff: >: pop(/shared/actions)\nn\nThis rule removes an action A whose postcondition is jointly believed to be true from\nactions2.",
      "context_before": "218 CHAPTER 5. ACTION-ORIENTED AND NEGOTIATIVE DIALOGUE\nWhen the conflrmation move has been made, it is integrated by the rule in (rule 5.6).\n(rule 5.6) rule: integrateConflrm\nclass: integrate\npre: $/private/nim/fst/snd=conflrm(A)\nn pop(/private/nim)\neff:\nadd(/shared/com, done(A))\n(\nThis rule adds the proposition done(A) to the shared commitments which enables the\ndowndateActions rule in (",
      "context_after": "5.6.4 Dialogue example: menu traversal and multiple threads\nIn (dialogue 5.1) we show a sample dialogue interaction with the menu-based VCR\napplication. It shows both menu traversal and accommodation, as well as dealing with\nmultiple tasks (issues and actions).\n(dialogue 5.1)\nS> Welcome to the VCR manager!\nS> Lets see. What can I do for you?\nU>\n2Note that done(fi) is trivially a postcondition for any action fi."
    },
    {
      "title": "rule 5 .7) rule: downdateActions",
      "section": "5.6.4 Dialogue example: menu traversal and multiple threads",
      "page": 240,
      "content": "rule 5.7) rule: downdateActions\nclass: downdate issues\nfst($/shared/actions, A)\npre: $domain :: postcond(A, PC)\n8\n>< in($/shared/com, PC )\neff: >: pop(/shared/actions)\nn\nThis rule removes an action A whose postcondition is jointly believed to be true from\nactions2.",
      "context_before": "218 CHAPTER 5. ACTION-ORIENTED AND NEGOTIATIVE DIALOGUE\nWhen the conflrmation move has been made, it is integrated by the rule in (rule 5.6).\n(rule 5.6) rule: integrateConflrm\nclass: integrate\npre: $/private/nim/fst/snd=conflrm(A)\nn pop(/private/nim)\neff:\nadd(/shared/com, done(A))\n(\nThis rule adds the proposition done(A) to the shared commitments which enables the\ndowndateActions rule in (rule 5.7) to trigger.\n(",
      "context_after": "5.6.4 Dialogue example: menu traversal and multiple threads\nIn (dialogue 5.1) we show a sample dialogue interaction with the menu-based VCR\napplication. It shows both menu traversal and accommodation, as well as dealing with\nmultiple tasks (issues and actions).\n(dialogue 5.1)\nS> Welcome to the VCR manager!\nS> Lets see. What can I do for you?\nU>\n2Note that done(fi) is trivially a postcondition for any action fi."
    },
    {
      "title": "rule 5 .8) rule: accommodateAction",
      "section": "5.6. UPDATE RULES AND DIALOGUE EXAMPLES 221",
      "page": 243,
      "content": "rule 5.8) rule: accommodateAction\nclass: accommodate\nsetof(A, $/private/nim/elem/snd=answer(A), AnsSet)\n$$arity(AnsSet) > 0\n8\npre:\n>>>>>>>>>>>>>>>>>><\n$\n$\nfo\nd\nd\nr\no\no\na\n$\nl\nm\nm\nd\nl(\no\na\na\nin\nm\ni\ni\n(\nn\nn\nA\na\n:\n:\ni\nn\n:\n:\nn\ns\na\np\nS\n:\nc\nl\n:\na\ne\nt\nr\ni\nn\nt\no\ne\n,\n(\nn\nl\nA\nA\ne\n(\nv\nc\nA\n)\na\nt\n,\nc\ni\nn\ni\no\nt\nn\nt\ni\nn\n(\n(\no\nA\n,\nP\nn\nP\n,\n)\nla\nQ\nl\nn\na\n)\nn\n,\n)\n)\nflndout(Q)) and\nnot $domain :: plan(Action0, Plan0) and Action06=Action and\n>>>>>>>>>>>>>>>>>>:\np\nn\nu\no\ns\nt\nf\n$\nh\no\ni\nd\n(\nn\nr\n/\no\na\n(\ns\n$\nl\nm\nl\nh\n/\n(\na\na\ni\np\nn\ni\nr\nr\n(\nn\nA\ni\ne\nv\n:\nd\nn\na\n:\n/\ns\nt\nr\na\nS\ne\ne\nc\nl\ne\n/\ne\nt\nt\na\nv\n,\ni\na\ng\no\nA\nn\ne\nn\nt\n)\nn\n(\n,\ns\nA\nd\n,\nin\na\n,\nA\n(\n,\nQ\nP\nct\ni\n)\nc\nl\ni\n)\na\nm\no\nn\nn\n:u\n0\n)\n,\nn\nfl\nd\nn\n*\nd\nin\no\nt\nu\n:u\nt(\ns\nQ\nr*\n)\na\n)\nc\na\nti\nn\no\nd\nn(Action))\npush(/private/agenda, icm:accommodate:Action)\n8\neff: >>>>>>< p\nse\nu\nt\ns\n(\nh\n/\n(\np\n/\nr\np\ni\nr\nv\ni\na\nv\nt\na\ne\nt\n/\ne\np\n/\nl\na\na\ng\nn\ne\n,\nn\nP\nd\nl\na\na\n,\nn\ni\n)\ncm:und*pos:usr*action(action))\npush(/private/agenda, icm:loadplan)\n>>>>>>:\nThisruleisverysimilartotheaccommodateDependentIssue(seeSection4.6.4), except\nthat it accommodates a dependent action rather than a dependent issue.\nIfthesystemflndsseveralactionsmatchingtheinformationgivenbytheuser,aclariflcation\nquestion is raised. This is again similar to the behaviour for issues described in Section\n4.6.5; in fact, the rule below replaces the previous clarifyDependentIssue rule.\n(rule 5.9) rule: clarifyIssueAction",
      "context_before": "5.6. UPDATE RULES AND DIALOGUE EXAMPLES 221\n(",
      "context_after": "class: select action\nin($/private/nim, pair(usr, answer(A)))\nsetof(Action, $domain :: depends(fi, Q) and\n8\npre: >>>>>><\nrem\n$\no\nd\nv\no\ne\nm\nu\na\nn\ni\ni\nn\nfla\n:\nb\n:\nle\nre\ns(\nle\nA\nv\nc\na\nt\nn\ni\nt\no\n(\nn\nA\ns\n,\n,\nQ\nAc\n),\nti\nA\non\nct\ns\ni\n0\no\n)\nnSet)\n$$arity(Actions0) > 1\n>>>>>>:\n! setof(?IssueProp, in(Actions0, Issue0) and\nnot $domain :: action(Issue0) and\n8\neff:\n>>>>>>>>>>>>><\n! se\nI\n$\nt\nd\ns\no\ns\nf\no\n(\nu\nm\n?\ne\nA\nP\na\nc\ni\nr\nt\nn\no\nio\np\n:\nn\n:\n=\nP\na\nis\nc\nr\ns\nt\no\nu\ni\np\ne\no\n(\n,\nn\nI\ni\n(\nn\ns\nA\ns\n(\nc\nu\nA\nt\ne\ni\nc\n0\no"
    },
    {
      "title": "rule 5 .9) rule: clarifyIssueAction",
      "section": "5.6. UPDATE RULES AND DIALOGUE EXAMPLES 221",
      "page": 243,
      "content": "rule 5.9) rule: clarifyIssueAction\nclass: select action\nin($/private/nim, pair(usr, answer(A)))\nsetof(Action, $domain :: depends(fi, Q) and\n8\npre: >>>>>><\nrem\n$\no\nd\nv\no\ne\nm\nu\na\nn\ni\ni\nn\nfla\n:\nb\n:\nle\nre\ns(\nle\nA\nv\nc\na\nt\nn\ni\nt\no\n(\nn\nA\ns\n,\n,\nQ\nAc\n),\nti\nA\non\nct\ns\ni\n0\no\n)\nnSet)\n$$arity(Actions0) > 1\n>>>>>>:\n! setof(?IssueProp, in(Actions0, Issue0) and\nnot $domain :: action(Issue0) and\n8\neff:\n>>>>>>>>>>>>><\n! se\nI\n$\nt\nd\ns\no\ns\nf\no\n(\nu\nm\n?\ne\nA\nP\na\nc\ni\nr\nt\nn\no\nio\np\n:\nn\n:\n=\nP\na\nis\nc\nr\ns\nt\no\nu\ni\np\ne\no\n(\n,\nn\nI\ni\n(\nn\ns\nA\ns\n(\nc\nu\nA\nt\ne\ni\nc\n0\no\nt\n)\nn\ni\n,\no\n0\nI\nn\n)\ns\ns\na\ns\n0\nn\n,\nu\nd\nA\neQ\nct\nu\ni\ne\no\ns\nn\nt\n0\ni\n)\no\na\nn\nn\ns\nd\n)\nActionProp=action(Action), ActionQuestions)\n>>>>>>>>>>>>>:\np\n!\nu\nu\ns\nn\nh\ni\n(\no\n/\nn\np\n(\nr\nIs\niv\ns\na\nu\nt\neQ\ne/\nu\na\ne\ng\nst\ne\ni\nn\non\nd\ns\na\n,\n,\nA\nfl\nc\nn\nt\nd\ni\no\non\nut\nQ\n(A\nue\nlt\ns\nQ\nti\n)\no\n)\nns, AltQ)",
      "context_before": ",\nn\nP\nd\nl\na\na\n,\nn\ni\n)\ncm:und*pos:usr*action(action))\npush(/private/agenda, icm:loadplan)\n>>>>>>:\nThisruleisverysimilartotheaccommodateDependentIssue(seeSection4.6.4), except\nthat it accommodates a dependent action rather than a dependent issue.\nIfthesystemflndsseveralactionsmatchingtheinformationgivenbytheuser,aclariflcation\nquestion is raised. This is again similar to the behaviour for issues described in Section\n4.6.5; in fact, the rule below replaces the previous clarifyDependentIssue rule.\n(",
      "context_after": ""
    },
    {
      "title": "Procedure/Rule in 5.8.2 Rejection, negotiation and downshifting",
      "section": "5.8.2 Rejection, negotiation and downshifting",
      "page": 254,
      "content": "232 CHAPTER 5. ACTION-ORIENTED AND NEGOTIATIVE DIALOGUE\n5.8.2 Rejection, negotiation and downshifting\nIn the context of discussing referent identiflcation in instructional assembly dialogues,\nCohen (1981) makes an analogy between shifts in dialogue strategy and shifting gears\nwhen driving a car. In a dialogue in high gear, the speaker introduces several subgoals\nin each utterance, whereas fewer goals are introduced in low-gear dialogue. The type of\nsubgoals discussed by Cohen are mainly identifying a referent, requests to pick up objects,\nand requesting an assembly action. As long as the dialogue proceeds smoothly and the\nhearer is able to correctly identify referents and carry out actions, the speaker requests\nassembly actions and expects the hearer to be able to identify and pick up the objects\nreferred to without explicit requests for this. However, when this fails and the hearer fails\nto identify a referent, the speaker may shift into a lower gear (downshift) and make explicit\nrequests for identiflcation of referents. At a later stage, the speaker may shift to a higher\ngear and request the hearer to pick up an object and then to perform an assembly action.\nFinally, the speaker may return to the initial gear and only make requests for assembly\nactions.\nSeverinsson (1983) views to the process of downshifting as making latent subgames into\nexplicit subgames. In the case mentioned above, the goals of the latent subgames are (1)\nto get the hearer to identify a referent, and (2) for the hearer to pick up the object referred\nto. In high gear, these subgames are latent in the sense that they do not give rise to any\nutterances (dialogue moves). When the latent subgames become explicit, the process that\nwas previously carried out silently is instead carried out using utterances.\nThis view flts well with the concept of tacit moves introduced in Section 4.4.2. Updates for\nlatent referent identiflcation and utterance acceptance can be regarded as tacit moves (or\ngames) corresponding to explicit referent identiflcation or negotiation subdialogues, similar\nto the way that question accommodation updates are tacit moves corresponding to the ask\ndialogue moves.\nBoth these notions, shifting gears in dialogue and latent subgames, are useful for shedding\nlight on the relation between negotiative dialogue and utterance acceptance. Firstly, the\nnotions of optimism and pessimism regarding grounding strategies seem intimately related\nto the notion of gears, both metaphorically and factually. Metaphorically, we may say that\nan optimistic driver will use a higher gear than a pessimistic one; only when she encounters\na bumpy road will she shift into lower gear (thus taking a more pessimistic approach).\nLater, when the road becomes smoother, she may again resume her optimistic strategy\nand use a higher gear. Similarly, speakers can be expected to switch between higher and\nlower gears, and between optimistic and pessimistic grounding strategies regarding the\ngrounding of their utterances. Thus we claim that the notion of shifting gears is applicable\nnot only to referent identiflcation, but also to other grounding related games, including\nutterance acceptance.",
      "context_before": "",
      "context_after": ""
    },
    {
      "title": "1 n",
      "section": "68. Lund : CWK Gleerup.",
      "page": 291,
      "content": "rule\n1 n\nin (A.16) allows specifying an object by applying Fun to Obj ;:::;Obj .\n1 n\n(A.16) Obj ! $$Fun(Obj ;:::;Obj )\n1 n\nBy using paths, built up by selectors, it is possible to \\point\" at an object embedded at the\ncorresponding location inside a (complex) object and inspect or manipulate it. Paths thus\nappear in two contexts: inspection, where they specify objects, and manipulation, where\nthey specify locations.\nAn object X can be specifled by a complex object and a selector Sel pointing out X inside\nthe complex object. The syntax rule for pointing out embedded objects using selectors is\nshown in (A.17).\n(A.17) Obj ! Obj=Sel\nThis recursive deflnition allows selectors to be iteratively applied to objects, using expres-\nsions of the form Obj=Sel =Sel :::=Sel ; this is equivalent to (:::((Obj=Sel )=Sel ):::\n1 2 n 1 2\n=Sel ).\nn\nAnother basic concept in TrindiKit is that of locations in objects. The general syntax\nfor locations is shown in (A.18); here, Sel is a selector and Obj is a complex object (a\ncollection).\n(A.18) Loc ! Loc=Sel\nLoc ! TISvar\nAgain, the recursive deflnition allows selectors to be iteratively applied, using expressions\nof the form TISvar=Sel =Sel :::=Sel ; this is equivalent to (:::((TISvar=Sel )=Sel ):::\n1 2 n 1 2\n=Sel ).\nn\nFor example, assume we have a TIS where the information state proper (the IS variable)\nhas the type given in (A.19) and the value given in (1.19.) (This examples assumes there\nare deflnitions of the types Proposition and Topic.)\nbeliefs : Set(Proposition)\n(A.19) is :\ntopics = Stack(Topic)\n\" #\nbeliefs = f happy(sys), frustrated(usr) g\n(A.20) is =\ntopics = h the weather, foreign politics i\n\" #",
      "context_before": "A.3. METHODS FOR ACCESSING THE TIS 269\n(A.15) Obj ! $TISvar\nObjectscanalsobespecifledusingevaluationoffunctions; thefunctionevaluationoperator\nis denoted \\$$\". Given a function Fun taking arguments Arg ;:::;Arg , the syntax",
      "context_after": ""
    },
    {
      "title": "Procedure/Rule in 13. SubAlg",
      "section": "13. SubAlg",
      "page": 298,
      "content": "276 APPENDIX A. TRINDIKIT FUNCTIONALITY\n1. Rule\napply the update rule Rule\n2. RuleClass\napply an update rule of class RuleClass; rules are tried in the order they are declared\n3. [R ;:::;R ]\n1 n\nexecute R ;:::;R in sequence\n1 n\n4. if C then S else T\nIf C is true of the TIS, execute S; otherwise, execute T\n5. while C do R\nwhile C is true of the TIS, execute R repeatedly\n6. repeat R until C\nexecute R repeatedly until C is true of the TIS\n7. repeat R\nexecute R repeatedly until it fails; report no error when it fails\n8. repeat+ R\nexecute R repeatedly, but at least once, until it fails; report no error when it fails\n9. try R\ntry to execute R; if it fails, report no error\n10. R orelse S\nTry to execute R; if it fails, report no error and execute S instead\n11. test C\nif C is true of the TIS, do nothing; otherwise, halt execution of the current algorithm\n12. apply Op\napply operation Op\n13. SubAlg\nexecute subalgorithm SubAlg\nSubalgorithms are declared using ), which is preceded by the subalgorithm name and\nfollowed by the algorithm, as in (A.33).\n(A.33) main update ) h grounding,\nrepeat+ ( integrate orelse accommodate ) i",
      "context_before": "",
      "context_after": ""
    },
    {
      "title": "rule 3 .1) (p. 41)",
      "section": "13. SubAlg",
      "page": 303,
      "content": "rule 3.1) (p. 41)\n† integrate\n1. integrateUsrAsk (rule 3.3) (p. 44)\n2. integrateSysAsk (rule 3.2) (p. 43)\n3. integrateAnswer (rule 3.4) (p. 47)\n4. integrateGreet (rule 3.6) (p. 48)\n5. integrateSysQuit (rule 3.8) (p. 49)\n281",
      "context_before": "ppendix lists rule classes used by the various versions of IBiS. Rules are listed in\nthe order they are tried when the corresponding rule class is called in a module algorithm.\nThe IBiS systems and TrindiKit can be downloaded from:\nhttp://www.ling.gu.se/~sl/Thesis.\nThe size of the systems range from approximately 1,200 lines of code (32kbyte) for IBiS1\nto about 2,500 lines (75 kbyte) for IBiS4, excluding domain-speciflc resources.\nB.1 IBiS1\nB.1.1 IBiS1 update module\n† grounding\n{ getLatestMove (",
      "context_after": ""
    },
    {
      "title": "rule 3 .3) (p. 44)",
      "section": "13. SubAlg",
      "page": 303,
      "content": "rule 3.3) (p. 44)\n2. integrateSysAsk (rule 3.2) (p. 43)\n3. integrateAnswer (rule 3.4) (p. 47)\n4. integrateGreet (rule 3.6) (p. 48)\n5. integrateSysQuit (rule 3.8) (p. 49)\n281",
      "context_before": "sions of IBiS. Rules are listed in\nthe order they are tried when the corresponding rule class is called in a module algorithm.\nThe IBiS systems and TrindiKit can be downloaded from:\nhttp://www.ling.gu.se/~sl/Thesis.\nThe size of the systems range from approximately 1,200 lines of code (32kbyte) for IBiS1\nto about 2,500 lines (75 kbyte) for IBiS4, excluding domain-speciflc resources.\nB.1 IBiS1\nB.1.1 IBiS1 update module\n† grounding\n{ getLatestMove (rule 3.1) (p. 41)\n† integrate\n1. integrateUsrAsk (",
      "context_after": ""
    },
    {
      "title": "rule 3 .2) (p. 43)",
      "section": "13. SubAlg",
      "page": 303,
      "content": "rule 3.2) (p. 43)\n3. integrateAnswer (rule 3.4) (p. 47)\n4. integrateGreet (rule 3.6) (p. 48)\n5. integrateSysQuit (rule 3.8) (p. 49)\n281",
      "context_before": "order they are tried when the corresponding rule class is called in a module algorithm.\nThe IBiS systems and TrindiKit can be downloaded from:\nhttp://www.ling.gu.se/~sl/Thesis.\nThe size of the systems range from approximately 1,200 lines of code (32kbyte) for IBiS1\nto about 2,500 lines (75 kbyte) for IBiS4, excluding domain-speciflc resources.\nB.1 IBiS1\nB.1.1 IBiS1 update module\n† grounding\n{ getLatestMove (rule 3.1) (p. 41)\n† integrate\n1. integrateUsrAsk (rule 3.3) (p. 44)\n2. integrateSysAsk (",
      "context_after": ""
    },
    {
      "title": "rule 3 .7) (p. 48)",
      "section": "13. SubAlg",
      "page": 304,
      "content": "rule 3.7) (p. 48)\n† downdate qud\n1. downdateQUD (rule 3.5) (p. 48)\n2. downdateQUD2 (rule 3.16) (p. 63)\n† load plan\n1. recoverPlan (rule 3.17) (p. 64)\n2. flndPlan (rule 3.9) (p. 49)\n† exec plan\n1. removeFindout (rule 3.10) (p. 50)\n2. removeRaise (rule 3.19) (p. 66)\n3. exec consultDB (rule 3.11) (p. 50)",
      "context_before": "282 APPENDIX B. RULES AND CLASSES\n6. integrateUsrQuit (",
      "context_after": "B.1.2 IBiS1 select module\n† select action\n1. selectRespond (rule 3.14) (p. 53)\n2. selectFromPlan (rule 3.12) (p. 51)\n3. reraiseIssue (rule 3.18) (p. 65)\n† select move\n1. selectAnswer (rule 3.15) (p. 54)\n2. selectAsk (rule 3.13) (p. 52)\n3. selectOther\nB.2 IBiS2\nB.2.1 IBiS2 update module\n† grounding\n{ getLatestMoves (rule 4.16) (p. 130)"
    },
    {
      "title": "rule 3 .5) (p. 48)",
      "section": "13. SubAlg",
      "page": 304,
      "content": "rule 3.5) (p. 48)\n2. downdateQUD2 (rule 3.16) (p. 63)\n† load plan\n1. recoverPlan (rule 3.17) (p. 64)\n2. flndPlan (rule 3.9) (p. 49)\n† exec plan\n1. removeFindout (rule 3.10) (p. 50)\n2. removeRaise (rule 3.19) (p. 66)\n3. exec consultDB (rule 3.11) (p. 50)\nB.1.2 IBiS1 select module\n† select action\n1. selectRespond (rule 3.14) (p. 53)",
      "context_before": "282 APPENDIX B. RULES AND CLASSES\n6. integrateUsrQuit (rule 3.7) (p. 48)\n† downdate qud\n1. downdateQUD (",
      "context_after": "2. selectFromPlan (rule 3.12) (p. 51)\n3. reraiseIssue (rule 3.18) (p. 65)\n† select move\n1. selectAnswer (rule 3.15) (p. 54)\n2. selectAsk (rule 3.13) (p. 52)\n3. selectOther\nB.2 IBiS2\nB.2.1 IBiS2 update module\n† grounding\n{ getLatestMoves (rule 4.16) (p. 130)"
    },
    {
      "title": "rule 3 .16) (p. 63)",
      "section": "13. SubAlg",
      "page": 304,
      "content": "rule 3.16) (p. 63)\n† load plan\n1. recoverPlan (rule 3.17) (p. 64)\n2. flndPlan (rule 3.9) (p. 49)\n† exec plan\n1. removeFindout (rule 3.10) (p. 50)\n2. removeRaise (rule 3.19) (p. 66)\n3. exec consultDB (rule 3.11) (p. 50)\nB.1.2 IBiS1 select module\n† select action\n1. selectRespond (rule 3.14) (p. 53)",
      "context_before": "282 APPENDIX B. RULES AND CLASSES\n6. integrateUsrQuit (rule 3.7) (p. 48)\n† downdate qud\n1. downdateQUD (rule 3.5) (p. 48)\n2. downdateQUD2 (",
      "context_after": "2. selectFromPlan (rule 3.12) (p. 51)\n3. reraiseIssue (rule 3.18) (p. 65)\n† select move\n1. selectAnswer (rule 3.15) (p. 54)\n2. selectAsk (rule 3.13) (p. 52)\n3. selectOther\nB.2 IBiS2\nB.2.1 IBiS2 update module\n† grounding\n{ getLatestMoves (rule 4.16) (p. 130)"
    },
    {
      "title": "rule 3 .17) (p. 64)",
      "section": "13. SubAlg",
      "page": 304,
      "content": "rule 3.17) (p. 64)\n2. flndPlan (rule 3.9) (p. 49)\n† exec plan\n1. removeFindout (rule 3.10) (p. 50)\n2. removeRaise (rule 3.19) (p. 66)\n3. exec consultDB (rule 3.11) (p. 50)\nB.1.2 IBiS1 select module\n† select action\n1. selectRespond (rule 3.14) (p. 53)\n2. selectFromPlan (rule 3.12) (p. 51)\n3. reraiseIssue (rule 3.18) (p. 65)",
      "context_before": "282 APPENDIX B. RULES AND CLASSES\n6. integrateUsrQuit (rule 3.7) (p. 48)\n† downdate qud\n1. downdateQUD (rule 3.5) (p. 48)\n2. downdateQUD2 (rule 3.16) (p. 63)\n† load plan\n1. recoverPlan (",
      "context_after": "† select move\n1. selectAnswer (rule 3.15) (p. 54)\n2. selectAsk (rule 3.13) (p. 52)\n3. selectOther\nB.2 IBiS2\nB.2.1 IBiS2 update module\n† grounding\n{ getLatestMoves (rule 4.16) (p. 130)"
    },
    {
      "title": "rule 3 .9) (p. 49)",
      "section": "13. SubAlg",
      "page": 304,
      "content": "rule 3.9) (p. 49)\n† exec plan\n1. removeFindout (rule 3.10) (p. 50)\n2. removeRaise (rule 3.19) (p. 66)\n3. exec consultDB (rule 3.11) (p. 50)\nB.1.2 IBiS1 select module\n† select action\n1. selectRespond (rule 3.14) (p. 53)\n2. selectFromPlan (rule 3.12) (p. 51)\n3. reraiseIssue (rule 3.18) (p. 65)\n† select move\n1. selectAnswer (rule 3.15) (p. 54)",
      "context_before": "282 APPENDIX B. RULES AND CLASSES\n6. integrateUsrQuit (rule 3.7) (p. 48)\n† downdate qud\n1. downdateQUD (rule 3.5) (p. 48)\n2. downdateQUD2 (rule 3.16) (p. 63)\n† load plan\n1. recoverPlan (rule 3.17) (p. 64)\n2. flndPlan (",
      "context_after": "2. selectAsk (rule 3.13) (p. 52)\n3. selectOther\nB.2 IBiS2\nB.2.1 IBiS2 update module\n† grounding\n{ getLatestMoves (rule 4.16) (p. 130)"
    },
    {
      "title": "rule 3 .10) (p. 50)",
      "section": "13. SubAlg",
      "page": 304,
      "content": "rule 3.10) (p. 50)\n2. removeRaise (rule 3.19) (p. 66)\n3. exec consultDB (rule 3.11) (p. 50)\nB.1.2 IBiS1 select module\n† select action\n1. selectRespond (rule 3.14) (p. 53)\n2. selectFromPlan (rule 3.12) (p. 51)\n3. reraiseIssue (rule 3.18) (p. 65)\n† select move\n1. selectAnswer (rule 3.15) (p. 54)\n2. selectAsk (rule 3.13) (p. 52)",
      "context_before": "282 APPENDIX B. RULES AND CLASSES\n6. integrateUsrQuit (rule 3.7) (p. 48)\n† downdate qud\n1. downdateQUD (rule 3.5) (p. 48)\n2. downdateQUD2 (rule 3.16) (p. 63)\n† load plan\n1. recoverPlan (rule 3.17) (p. 64)\n2. flndPlan (rule 3.9) (p. 49)\n† exec plan\n1. removeFindout (",
      "context_after": "3. selectOther\nB.2 IBiS2\nB.2.1 IBiS2 update module\n† grounding\n{ getLatestMoves (rule 4.16) (p. 130)"
    },
    {
      "title": "rule 3 .19) (p. 66)",
      "section": "13. SubAlg",
      "page": 304,
      "content": "rule 3.19) (p. 66)\n3. exec consultDB (rule 3.11) (p. 50)\nB.1.2 IBiS1 select module\n† select action\n1. selectRespond (rule 3.14) (p. 53)\n2. selectFromPlan (rule 3.12) (p. 51)\n3. reraiseIssue (rule 3.18) (p. 65)\n† select move\n1. selectAnswer (rule 3.15) (p. 54)\n2. selectAsk (rule 3.13) (p. 52)\n3. selectOther\nB.2 IBiS2\nB.2.1 IBiS2 update module\n† grounding\n{ getLatestMoves (rule 4.16) (p. 130)",
      "context_before": "282 APPENDIX B. RULES AND CLASSES\n6. integrateUsrQuit (rule 3.7) (p. 48)\n† downdate qud\n1. downdateQUD (rule 3.5) (p. 48)\n2. downdateQUD2 (rule 3.16) (p. 63)\n† load plan\n1. recoverPlan (rule 3.17) (p. 64)\n2. flndPlan (rule 3.9) (p. 49)\n† exec plan\n1. removeFindout (rule 3.10) (p. 50)\n2. removeRaise (",
      "context_after": ""
    },
    {
      "title": "rule 3 .11) (p. 50)",
      "section": "13. SubAlg",
      "page": 304,
      "content": "rule 3.11) (p. 50)\nB.1.2 IBiS1 select module\n† select action\n1. selectRespond (rule 3.14) (p. 53)\n2. selectFromPlan (rule 3.12) (p. 51)\n3. reraiseIssue (rule 3.18) (p. 65)\n† select move\n1. selectAnswer (rule 3.15) (p. 54)\n2. selectAsk (rule 3.13) (p. 52)\n3. selectOther\nB.2 IBiS2\nB.2.1 IBiS2 update module\n† grounding\n{ getLatestMoves (rule 4.16) (p. 130)",
      "context_before": "282 APPENDIX B. RULES AND CLASSES\n6. integrateUsrQuit (rule 3.7) (p. 48)\n† downdate qud\n1. downdateQUD (rule 3.5) (p. 48)\n2. downdateQUD2 (rule 3.16) (p. 63)\n† load plan\n1. recoverPlan (rule 3.17) (p. 64)\n2. flndPlan (rule 3.9) (p. 49)\n† exec plan\n1. removeFindout (rule 3.10) (p. 50)\n2. removeRaise (rule 3.19) (p. 66)\n3. exec consultDB (",
      "context_after": ""
    },
    {
      "title": "rule 3 .14) (p. 53)",
      "section": "13. SubAlg",
      "page": 304,
      "content": "rule 3.14) (p. 53)\n2. selectFromPlan (rule 3.12) (p. 51)\n3. reraiseIssue (rule 3.18) (p. 65)\n† select move\n1. selectAnswer (rule 3.15) (p. 54)\n2. selectAsk (rule 3.13) (p. 52)\n3. selectOther\nB.2 IBiS2\nB.2.1 IBiS2 update module\n† grounding\n{ getLatestMoves (rule 4.16) (p. 130)",
      "context_before": "282 APPENDIX B. RULES AND CLASSES\n6. integrateUsrQuit (rule 3.7) (p. 48)\n† downdate qud\n1. downdateQUD (rule 3.5) (p. 48)\n2. downdateQUD2 (rule 3.16) (p. 63)\n† load plan\n1. recoverPlan (rule 3.17) (p. 64)\n2. flndPlan (rule 3.9) (p. 49)\n† exec plan\n1. removeFindout (rule 3.10) (p. 50)\n2. removeRaise (rule 3.19) (p. 66)\n3. exec consultDB (rule 3.11) (p. 50)\nB.1.2 IBiS1 select module\n† select action\n1. selectRespond (",
      "context_after": ""
    },
    {
      "title": "rule 3 .12) (p. 51)",
      "section": "13. SubAlg",
      "page": 304,
      "content": "rule 3.12) (p. 51)\n3. reraiseIssue (rule 3.18) (p. 65)\n† select move\n1. selectAnswer (rule 3.15) (p. 54)\n2. selectAsk (rule 3.13) (p. 52)\n3. selectOther\nB.2 IBiS2\nB.2.1 IBiS2 update module\n† grounding\n{ getLatestMoves (rule 4.16) (p. 130)",
      "context_before": "282 APPENDIX B. RULES AND CLASSES\n6. integrateUsrQuit (rule 3.7) (p. 48)\n† downdate qud\n1. downdateQUD (rule 3.5) (p. 48)\n2. downdateQUD2 (rule 3.16) (p. 63)\n† load plan\n1. recoverPlan (rule 3.17) (p. 64)\n2. flndPlan (rule 3.9) (p. 49)\n† exec plan\n1. removeFindout (rule 3.10) (p. 50)\n2. removeRaise (rule 3.19) (p. 66)\n3. exec consultDB (rule 3.11) (p. 50)\nB.1.2 IBiS1 select module\n† select action\n1. selectRespond (rule 3.14) (p. 53)\n2. selectFromPlan (",
      "context_after": ""
    },
    {
      "title": "rule 3 .18) (p. 65)",
      "section": "13. SubAlg",
      "page": 304,
      "content": "rule 3.18) (p. 65)\n† select move\n1. selectAnswer (rule 3.15) (p. 54)\n2. selectAsk (rule 3.13) (p. 52)\n3. selectOther\nB.2 IBiS2\nB.2.1 IBiS2 update module\n† grounding\n{ getLatestMoves (rule 4.16) (p. 130)",
      "context_before": "282 APPENDIX B. RULES AND CLASSES\n6. integrateUsrQuit (rule 3.7) (p. 48)\n† downdate qud\n1. downdateQUD (rule 3.5) (p. 48)\n2. downdateQUD2 (rule 3.16) (p. 63)\n† load plan\n1. recoverPlan (rule 3.17) (p. 64)\n2. flndPlan (rule 3.9) (p. 49)\n† exec plan\n1. removeFindout (rule 3.10) (p. 50)\n2. removeRaise (rule 3.19) (p. 66)\n3. exec consultDB (rule 3.11) (p. 50)\nB.1.2 IBiS1 select module\n† select action\n1. selectRespond (rule 3.14) (p. 53)\n2. selectFromPlan (rule 3.12) (p. 51)\n3. reraiseIssue (",
      "context_after": ""
    },
    {
      "title": "rule 3 .15) (p. 54)",
      "section": "13. SubAlg",
      "page": 304,
      "content": "rule 3.15) (p. 54)\n2. selectAsk (rule 3.13) (p. 52)\n3. selectOther\nB.2 IBiS2\nB.2.1 IBiS2 update module\n† grounding\n{ getLatestMoves (rule 4.16) (p. 130)",
      "context_before": "rateUsrQuit (rule 3.7) (p. 48)\n† downdate qud\n1. downdateQUD (rule 3.5) (p. 48)\n2. downdateQUD2 (rule 3.16) (p. 63)\n† load plan\n1. recoverPlan (rule 3.17) (p. 64)\n2. flndPlan (rule 3.9) (p. 49)\n† exec plan\n1. removeFindout (rule 3.10) (p. 50)\n2. removeRaise (rule 3.19) (p. 66)\n3. exec consultDB (rule 3.11) (p. 50)\nB.1.2 IBiS1 select module\n† select action\n1. selectRespond (rule 3.14) (p. 53)\n2. selectFromPlan (rule 3.12) (p. 51)\n3. reraiseIssue (rule 3.18) (p. 65)\n† select move\n1. selectAnswer (",
      "context_after": ""
    },
    {
      "title": "rule 3 .13) (p. 52)",
      "section": "13. SubAlg",
      "page": 304,
      "content": "rule 3.13) (p. 52)\n3. selectOther\nB.2 IBiS2\nB.2.1 IBiS2 update module\n† grounding\n{ getLatestMoves (rule 4.16) (p. 130)",
      "context_before": "downdate qud\n1. downdateQUD (rule 3.5) (p. 48)\n2. downdateQUD2 (rule 3.16) (p. 63)\n† load plan\n1. recoverPlan (rule 3.17) (p. 64)\n2. flndPlan (rule 3.9) (p. 49)\n† exec plan\n1. removeFindout (rule 3.10) (p. 50)\n2. removeRaise (rule 3.19) (p. 66)\n3. exec consultDB (rule 3.11) (p. 50)\nB.1.2 IBiS1 select module\n† select action\n1. selectRespond (rule 3.14) (p. 53)\n2. selectFromPlan (rule 3.12) (p. 51)\n3. reraiseIssue (rule 3.18) (p. 65)\n† select move\n1. selectAnswer (rule 3.15) (p. 54)\n2. selectAsk (",
      "context_after": ""
    },
    {
      "title": "rule 4 .1) (p. 110)",
      "section": "13. SubAlg",
      "page": 305,
      "content": "rule 4.1) (p. 110)\n2. integrateSysAsk (rule 4.18) (p. 132)\n3. integrateNegIcmAnswer (rule 4.7) (p. 115)\n4. integratePosIcmAnswer (rule 4.8) (p. 116)\n5. integrateUsrAnswer (rule 4.4) (p. 113)\n6. integrateSysAnswer (rule 4.19) (p. 132)\n7. integrateUndIntICM (rule 4.6) (p. 115)\n8. integrateUsrPerNegICM (rule 4.20) (p. 133)\n9. integrateUsrAccNegICM (rule 4.21) (p. 135)\n10. integrateOtherICM (rule 4.10) (p. 121)\n11. integrateGreet\n12. integrateSysQuit\n13. integrateUsrQuit\n14. integrateNoMove\n† downdate qud\n{ downdateQUD\n{ downdateQUD2\n† load plan\n1. recoverPlan (rule 4.24) (p. 143)",
      "context_before": "B.2. IBIS2 283\n† integrate\n1. integrateUsrAsk (",
      "context_after": "2. flndPlan (rule 4.23) (p. 143)\n† exec plan\n1. removeFindout\n2. exec consultDB\n† (none)\n{ irrelevantFollowup (rule 4.22) (p. 141)\n{ unclearFollowup"
    },
    {
      "title": "rule 4 .18) (p. 132)",
      "section": "13. SubAlg",
      "page": 305,
      "content": "rule 4.18) (p. 132)\n3. integrateNegIcmAnswer (rule 4.7) (p. 115)\n4. integratePosIcmAnswer (rule 4.8) (p. 116)\n5. integrateUsrAnswer (rule 4.4) (p. 113)\n6. integrateSysAnswer (rule 4.19) (p. 132)\n7. integrateUndIntICM (rule 4.6) (p. 115)\n8. integrateUsrPerNegICM (rule 4.20) (p. 133)\n9. integrateUsrAccNegICM (rule 4.21) (p. 135)\n10. integrateOtherICM (rule 4.10) (p. 121)\n11. integrateGreet\n12. integrateSysQuit\n13. integrateUsrQuit\n14. integrateNoMove\n† downdate qud\n{ downdateQUD\n{ downdateQUD2\n† load plan\n1. recoverPlan (rule 4.24) (p. 143)",
      "context_before": "B.2. IBIS2 283\n† integrate\n1. integrateUsrAsk (rule 4.1) (p. 110)\n2. integrateSysAsk (",
      "context_after": "2. flndPlan (rule 4.23) (p. 143)\n† exec plan\n1. removeFindout\n2. exec consultDB\n† (none)\n{ irrelevantFollowup (rule 4.22) (p. 141)\n{ unclearFollowup"
    },
    {
      "title": "rule 4 .7) (p. 115)",
      "section": "13. SubAlg",
      "page": 305,
      "content": "rule 4.7) (p. 115)\n4. integratePosIcmAnswer (rule 4.8) (p. 116)\n5. integrateUsrAnswer (rule 4.4) (p. 113)\n6. integrateSysAnswer (rule 4.19) (p. 132)\n7. integrateUndIntICM (rule 4.6) (p. 115)\n8. integrateUsrPerNegICM (rule 4.20) (p. 133)\n9. integrateUsrAccNegICM (rule 4.21) (p. 135)\n10. integrateOtherICM (rule 4.10) (p. 121)\n11. integrateGreet\n12. integrateSysQuit\n13. integrateUsrQuit\n14. integrateNoMove\n† downdate qud\n{ downdateQUD\n{ downdateQUD2\n† load plan\n1. recoverPlan (rule 4.24) (p. 143)",
      "context_before": "B.2. IBIS2 283\n† integrate\n1. integrateUsrAsk (rule 4.1) (p. 110)\n2. integrateSysAsk (rule 4.18) (p. 132)\n3. integrateNegIcmAnswer (",
      "context_after": "2. flndPlan (rule 4.23) (p. 143)\n† exec plan\n1. removeFindout\n2. exec consultDB\n† (none)\n{ irrelevantFollowup (rule 4.22) (p. 141)\n{ unclearFollowup"
    },
    {
      "title": "rule 4 .8) (p. 116)",
      "section": "13. SubAlg",
      "page": 305,
      "content": "rule 4.8) (p. 116)\n5. integrateUsrAnswer (rule 4.4) (p. 113)\n6. integrateSysAnswer (rule 4.19) (p. 132)\n7. integrateUndIntICM (rule 4.6) (p. 115)\n8. integrateUsrPerNegICM (rule 4.20) (p. 133)\n9. integrateUsrAccNegICM (rule 4.21) (p. 135)\n10. integrateOtherICM (rule 4.10) (p. 121)\n11. integrateGreet\n12. integrateSysQuit\n13. integrateUsrQuit\n14. integrateNoMove\n† downdate qud\n{ downdateQUD\n{ downdateQUD2\n† load plan\n1. recoverPlan (rule 4.24) (p. 143)",
      "context_before": "B.2. IBIS2 283\n† integrate\n1. integrateUsrAsk (rule 4.1) (p. 110)\n2. integrateSysAsk (rule 4.18) (p. 132)\n3. integrateNegIcmAnswer (rule 4.7) (p. 115)\n4. integratePosIcmAnswer (",
      "context_after": "2. flndPlan (rule 4.23) (p. 143)\n† exec plan\n1. removeFindout\n2. exec consultDB\n† (none)\n{ irrelevantFollowup (rule 4.22) (p. 141)\n{ unclearFollowup"
    },
    {
      "title": "rule 4 .4) (p. 113)",
      "section": "13. SubAlg",
      "page": 305,
      "content": "rule 4.4) (p. 113)\n6. integrateSysAnswer (rule 4.19) (p. 132)\n7. integrateUndIntICM (rule 4.6) (p. 115)\n8. integrateUsrPerNegICM (rule 4.20) (p. 133)\n9. integrateUsrAccNegICM (rule 4.21) (p. 135)\n10. integrateOtherICM (rule 4.10) (p. 121)\n11. integrateGreet\n12. integrateSysQuit\n13. integrateUsrQuit\n14. integrateNoMove\n† downdate qud\n{ downdateQUD\n{ downdateQUD2\n† load plan\n1. recoverPlan (rule 4.24) (p. 143)",
      "context_before": "B.2. IBIS2 283\n† integrate\n1. integrateUsrAsk (rule 4.1) (p. 110)\n2. integrateSysAsk (rule 4.18) (p. 132)\n3. integrateNegIcmAnswer (rule 4.7) (p. 115)\n4. integratePosIcmAnswer (rule 4.8) (p. 116)\n5. integrateUsrAnswer (",
      "context_after": "2. flndPlan (rule 4.23) (p. 143)\n† exec plan\n1. removeFindout\n2. exec consultDB\n† (none)\n{ irrelevantFollowup (rule 4.22) (p. 141)\n{ unclearFollowup"
    },
    {
      "title": "rule 4 .19) (p. 132)",
      "section": "13. SubAlg",
      "page": 305,
      "content": "rule 4.19) (p. 132)\n7. integrateUndIntICM (rule 4.6) (p. 115)\n8. integrateUsrPerNegICM (rule 4.20) (p. 133)\n9. integrateUsrAccNegICM (rule 4.21) (p. 135)\n10. integrateOtherICM (rule 4.10) (p. 121)\n11. integrateGreet\n12. integrateSysQuit\n13. integrateUsrQuit\n14. integrateNoMove\n† downdate qud\n{ downdateQUD\n{ downdateQUD2\n† load plan\n1. recoverPlan (rule 4.24) (p. 143)",
      "context_before": "B.2. IBIS2 283\n† integrate\n1. integrateUsrAsk (rule 4.1) (p. 110)\n2. integrateSysAsk (rule 4.18) (p. 132)\n3. integrateNegIcmAnswer (rule 4.7) (p. 115)\n4. integratePosIcmAnswer (rule 4.8) (p. 116)\n5. integrateUsrAnswer (rule 4.4) (p. 113)\n6. integrateSysAnswer (",
      "context_after": "2. flndPlan (rule 4.23) (p. 143)\n† exec plan\n1. removeFindout\n2. exec consultDB\n† (none)\n{ irrelevantFollowup (rule 4.22) (p. 141)\n{ unclearFollowup"
    },
    {
      "title": "rule 4 .6) (p. 115)",
      "section": "13. SubAlg",
      "page": 305,
      "content": "rule 4.6) (p. 115)\n8. integrateUsrPerNegICM (rule 4.20) (p. 133)\n9. integrateUsrAccNegICM (rule 4.21) (p. 135)\n10. integrateOtherICM (rule 4.10) (p. 121)\n11. integrateGreet\n12. integrateSysQuit\n13. integrateUsrQuit\n14. integrateNoMove\n† downdate qud\n{ downdateQUD\n{ downdateQUD2\n† load plan\n1. recoverPlan (rule 4.24) (p. 143)",
      "context_before": "B.2. IBIS2 283\n† integrate\n1. integrateUsrAsk (rule 4.1) (p. 110)\n2. integrateSysAsk (rule 4.18) (p. 132)\n3. integrateNegIcmAnswer (rule 4.7) (p. 115)\n4. integratePosIcmAnswer (rule 4.8) (p. 116)\n5. integrateUsrAnswer (rule 4.4) (p. 113)\n6. integrateSysAnswer (rule 4.19) (p. 132)\n7. integrateUndIntICM (",
      "context_after": "2. flndPlan (rule 4.23) (p. 143)\n† exec plan\n1. removeFindout\n2. exec consultDB\n† (none)\n{ irrelevantFollowup (rule 4.22) (p. 141)\n{ unclearFollowup"
    },
    {
      "title": "rule 4 .20) (p. 133)",
      "section": "13. SubAlg",
      "page": 305,
      "content": "rule 4.20) (p. 133)\n9. integrateUsrAccNegICM (rule 4.21) (p. 135)\n10. integrateOtherICM (rule 4.10) (p. 121)\n11. integrateGreet\n12. integrateSysQuit\n13. integrateUsrQuit\n14. integrateNoMove\n† downdate qud\n{ downdateQUD\n{ downdateQUD2\n† load plan\n1. recoverPlan (rule 4.24) (p. 143)",
      "context_before": "B.2. IBIS2 283\n† integrate\n1. integrateUsrAsk (rule 4.1) (p. 110)\n2. integrateSysAsk (rule 4.18) (p. 132)\n3. integrateNegIcmAnswer (rule 4.7) (p. 115)\n4. integratePosIcmAnswer (rule 4.8) (p. 116)\n5. integrateUsrAnswer (rule 4.4) (p. 113)\n6. integrateSysAnswer (rule 4.19) (p. 132)\n7. integrateUndIntICM (rule 4.6) (p. 115)\n8. integrateUsrPerNegICM (",
      "context_after": "2. flndPlan (rule 4.23) (p. 143)\n† exec plan\n1. removeFindout\n2. exec consultDB\n† (none)\n{ irrelevantFollowup (rule 4.22) (p. 141)\n{ unclearFollowup"
    },
    {
      "title": "rule 4 .21) (p. 135)",
      "section": "13. SubAlg",
      "page": 305,
      "content": "rule 4.21) (p. 135)\n10. integrateOtherICM (rule 4.10) (p. 121)\n11. integrateGreet\n12. integrateSysQuit\n13. integrateUsrQuit\n14. integrateNoMove\n† downdate qud\n{ downdateQUD\n{ downdateQUD2\n† load plan\n1. recoverPlan (rule 4.24) (p. 143)",
      "context_before": "B.2. IBIS2 283\n† integrate\n1. integrateUsrAsk (rule 4.1) (p. 110)\n2. integrateSysAsk (rule 4.18) (p. 132)\n3. integrateNegIcmAnswer (rule 4.7) (p. 115)\n4. integratePosIcmAnswer (rule 4.8) (p. 116)\n5. integrateUsrAnswer (rule 4.4) (p. 113)\n6. integrateSysAnswer (rule 4.19) (p. 132)\n7. integrateUndIntICM (rule 4.6) (p. 115)\n8. integrateUsrPerNegICM (rule 4.20) (p. 133)\n9. integrateUsrAccNegICM (",
      "context_after": "2. flndPlan (rule 4.23) (p. 143)\n† exec plan\n1. removeFindout\n2. exec consultDB\n† (none)\n{ irrelevantFollowup (rule 4.22) (p. 141)\n{ unclearFollowup"
    },
    {
      "title": "rule 4 .10) (p. 121)",
      "section": "13. SubAlg",
      "page": 305,
      "content": "rule 4.10) (p. 121)\n11. integrateGreet\n12. integrateSysQuit\n13. integrateUsrQuit\n14. integrateNoMove\n† downdate qud\n{ downdateQUD\n{ downdateQUD2\n† load plan\n1. recoverPlan (rule 4.24) (p. 143)\n2. flndPlan (rule 4.23) (p. 143)",
      "context_before": "B.2. IBIS2 283\n† integrate\n1. integrateUsrAsk (rule 4.1) (p. 110)\n2. integrateSysAsk (rule 4.18) (p. 132)\n3. integrateNegIcmAnswer (rule 4.7) (p. 115)\n4. integratePosIcmAnswer (rule 4.8) (p. 116)\n5. integrateUsrAnswer (rule 4.4) (p. 113)\n6. integrateSysAnswer (rule 4.19) (p. 132)\n7. integrateUndIntICM (rule 4.6) (p. 115)\n8. integrateUsrPerNegICM (rule 4.20) (p. 133)\n9. integrateUsrAccNegICM (rule 4.21) (p. 135)\n10. integrateOtherICM (",
      "context_after": "† exec plan\n1. removeFindout\n2. exec consultDB\n† (none)\n{ irrelevantFollowup (rule 4.22) (p. 141)\n{ unclearFollowup"
    },
    {
      "title": "rule 4 .24) (p. 143)",
      "section": "13. SubAlg",
      "page": 305,
      "content": "rule 4.24) (p. 143)\n2. flndPlan (rule 4.23) (p. 143)\n† exec plan\n1. removeFindout\n2. exec consultDB\n† (none)\n{ irrelevantFollowup (rule 4.22) (p. 141)\n{ unclearFollowup",
      "context_before": "tegrateNegIcmAnswer (rule 4.7) (p. 115)\n4. integratePosIcmAnswer (rule 4.8) (p. 116)\n5. integrateUsrAnswer (rule 4.4) (p. 113)\n6. integrateSysAnswer (rule 4.19) (p. 132)\n7. integrateUndIntICM (rule 4.6) (p. 115)\n8. integrateUsrPerNegICM (rule 4.20) (p. 133)\n9. integrateUsrAccNegICM (rule 4.21) (p. 135)\n10. integrateOtherICM (rule 4.10) (p. 121)\n11. integrateGreet\n12. integrateSysQuit\n13. integrateUsrQuit\n14. integrateNoMove\n† downdate qud\n{ downdateQUD\n{ downdateQUD2\n† load plan\n1. recoverPlan (",
      "context_after": ""
    },
    {
      "title": "rule 4 .23) (p. 143)",
      "section": "13. SubAlg",
      "page": 305,
      "content": "rule 4.23) (p. 143)\n† exec plan\n1. removeFindout\n2. exec consultDB\n† (none)\n{ irrelevantFollowup (rule 4.22) (p. 141)\n{ unclearFollowup",
      "context_before": ". 115)\n4. integratePosIcmAnswer (rule 4.8) (p. 116)\n5. integrateUsrAnswer (rule 4.4) (p. 113)\n6. integrateSysAnswer (rule 4.19) (p. 132)\n7. integrateUndIntICM (rule 4.6) (p. 115)\n8. integrateUsrPerNegICM (rule 4.20) (p. 133)\n9. integrateUsrAccNegICM (rule 4.21) (p. 135)\n10. integrateOtherICM (rule 4.10) (p. 121)\n11. integrateGreet\n12. integrateSysQuit\n13. integrateUsrQuit\n14. integrateNoMove\n† downdate qud\n{ downdateQUD\n{ downdateQUD2\n† load plan\n1. recoverPlan (rule 4.24) (p. 143)\n2. flndPlan (",
      "context_after": ""
    },
    {
      "title": "rule 4 .15) (p. 129)",
      "section": "13. SubAlg",
      "page": 306,
      "content": "rule 4.15) (p. 129)\n2. rejectProp (rule 4.14) (p. 127)\n3. selectIcmUndIntAsk (rule 4.3) (p. 112)\n4. selectIcmUndIntAnswer (rule 4.5) (p. 114)\n5. selectRespond (rule 4.26) (p. 147)\n6. selectFromPlan\n7. reraiseIssue (rule 4.25) (p. 144)\n† select icm\n1. selectIcmConNeg (rule 4.9) (p. 120)\n2. selectIcmPerNeg (rule 4.11) (p. 121)\n3. selectIcmSemNeg (rule 4.12) (p. 122)",
      "context_before": "284 APPENDIX B. RULES AND CLASSES\nB.2.2 IBiS2 select module\n† select action\n1. rejectIssue (",
      "context_after": "4. selectIcmUndNeg (rule 4.13) (p. 123)\n5. selectIcmOther (rule 4.2) (p. 111)\n† select move\n1. selectAnswer (rule 4.27) (p. 147)\n2. selectAsk\n3. selectOther\n4. selectIcmOther (rule 4.2) (p. 111)\n† (none)\n{ backupShared (rule 4.17) (p. 131)\nB.3 IBiS3\nB.3.1 IBiS3 update module\n† grounding\n{ getLatestMoves"
    },
    {
      "title": "rule 4 .14) (p. 127)",
      "section": "13. SubAlg",
      "page": 306,
      "content": "rule 4.14) (p. 127)\n3. selectIcmUndIntAsk (rule 4.3) (p. 112)\n4. selectIcmUndIntAnswer (rule 4.5) (p. 114)\n5. selectRespond (rule 4.26) (p. 147)\n6. selectFromPlan\n7. reraiseIssue (rule 4.25) (p. 144)\n† select icm\n1. selectIcmConNeg (rule 4.9) (p. 120)\n2. selectIcmPerNeg (rule 4.11) (p. 121)\n3. selectIcmSemNeg (rule 4.12) (p. 122)\n4. selectIcmUndNeg (rule 4.13) (p. 123)",
      "context_before": "284 APPENDIX B. RULES AND CLASSES\nB.2.2 IBiS2 select module\n† select action\n1. rejectIssue (rule 4.15) (p. 129)\n2. rejectProp (",
      "context_after": "5. selectIcmOther (rule 4.2) (p. 111)\n† select move\n1. selectAnswer (rule 4.27) (p. 147)\n2. selectAsk\n3. selectOther\n4. selectIcmOther (rule 4.2) (p. 111)\n† (none)\n{ backupShared (rule 4.17) (p. 131)\nB.3 IBiS3\nB.3.1 IBiS3 update module\n† grounding\n{ getLatestMoves"
    },
    {
      "title": "rule 4 .3) (p. 112)",
      "section": "13. SubAlg",
      "page": 306,
      "content": "rule 4.3) (p. 112)\n4. selectIcmUndIntAnswer (rule 4.5) (p. 114)\n5. selectRespond (rule 4.26) (p. 147)\n6. selectFromPlan\n7. reraiseIssue (rule 4.25) (p. 144)\n† select icm\n1. selectIcmConNeg (rule 4.9) (p. 120)\n2. selectIcmPerNeg (rule 4.11) (p. 121)\n3. selectIcmSemNeg (rule 4.12) (p. 122)\n4. selectIcmUndNeg (rule 4.13) (p. 123)\n5. selectIcmOther (rule 4.2) (p. 111)",
      "context_before": "284 APPENDIX B. RULES AND CLASSES\nB.2.2 IBiS2 select module\n† select action\n1. rejectIssue (rule 4.15) (p. 129)\n2. rejectProp (rule 4.14) (p. 127)\n3. selectIcmUndIntAsk (",
      "context_after": "† select move\n1. selectAnswer (rule 4.27) (p. 147)\n2. selectAsk\n3. selectOther\n4. selectIcmOther (rule 4.2) (p. 111)\n† (none)\n{ backupShared (rule 4.17) (p. 131)\nB.3 IBiS3\nB.3.1 IBiS3 update module\n† grounding\n{ getLatestMoves"
    },
    {
      "title": "rule 4 .5) (p. 114)",
      "section": "13. SubAlg",
      "page": 306,
      "content": "rule 4.5) (p. 114)\n5. selectRespond (rule 4.26) (p. 147)\n6. selectFromPlan\n7. reraiseIssue (rule 4.25) (p. 144)\n† select icm\n1. selectIcmConNeg (rule 4.9) (p. 120)\n2. selectIcmPerNeg (rule 4.11) (p. 121)\n3. selectIcmSemNeg (rule 4.12) (p. 122)\n4. selectIcmUndNeg (rule 4.13) (p. 123)\n5. selectIcmOther (rule 4.2) (p. 111)\n† select move\n1. selectAnswer (rule 4.27) (p. 147)",
      "context_before": "284 APPENDIX B. RULES AND CLASSES\nB.2.2 IBiS2 select module\n† select action\n1. rejectIssue (rule 4.15) (p. 129)\n2. rejectProp (rule 4.14) (p. 127)\n3. selectIcmUndIntAsk (rule 4.3) (p. 112)\n4. selectIcmUndIntAnswer (",
      "context_after": "2. selectAsk\n3. selectOther\n4. selectIcmOther (rule 4.2) (p. 111)\n† (none)\n{ backupShared (rule 4.17) (p. 131)\nB.3 IBiS3\nB.3.1 IBiS3 update module\n† grounding\n{ getLatestMoves"
    },
    {
      "title": "rule 4 .26) (p. 147)",
      "section": "13. SubAlg",
      "page": 306,
      "content": "rule 4.26) (p. 147)\n6. selectFromPlan\n7. reraiseIssue (rule 4.25) (p. 144)\n† select icm\n1. selectIcmConNeg (rule 4.9) (p. 120)\n2. selectIcmPerNeg (rule 4.11) (p. 121)\n3. selectIcmSemNeg (rule 4.12) (p. 122)\n4. selectIcmUndNeg (rule 4.13) (p. 123)\n5. selectIcmOther (rule 4.2) (p. 111)\n† select move\n1. selectAnswer (rule 4.27) (p. 147)",
      "context_before": "284 APPENDIX B. RULES AND CLASSES\nB.2.2 IBiS2 select module\n† select action\n1. rejectIssue (rule 4.15) (p. 129)\n2. rejectProp (rule 4.14) (p. 127)\n3. selectIcmUndIntAsk (rule 4.3) (p. 112)\n4. selectIcmUndIntAnswer (rule 4.5) (p. 114)\n5. selectRespond (",
      "context_after": "2. selectAsk\n3. selectOther\n4. selectIcmOther (rule 4.2) (p. 111)\n† (none)\n{ backupShared (rule 4.17) (p. 131)\nB.3 IBiS3\nB.3.1 IBiS3 update module\n† grounding\n{ getLatestMoves"
    },
    {
      "title": "rule 4 .25) (p. 144)",
      "section": "13. SubAlg",
      "page": 306,
      "content": "rule 4.25) (p. 144)\n† select icm\n1. selectIcmConNeg (rule 4.9) (p. 120)\n2. selectIcmPerNeg (rule 4.11) (p. 121)\n3. selectIcmSemNeg (rule 4.12) (p. 122)\n4. selectIcmUndNeg (rule 4.13) (p. 123)\n5. selectIcmOther (rule 4.2) (p. 111)\n† select move\n1. selectAnswer (rule 4.27) (p. 147)\n2. selectAsk\n3. selectOther\n4. selectIcmOther (rule 4.2) (p. 111)",
      "context_before": "284 APPENDIX B. RULES AND CLASSES\nB.2.2 IBiS2 select module\n† select action\n1. rejectIssue (rule 4.15) (p. 129)\n2. rejectProp (rule 4.14) (p. 127)\n3. selectIcmUndIntAsk (rule 4.3) (p. 112)\n4. selectIcmUndIntAnswer (rule 4.5) (p. 114)\n5. selectRespond (rule 4.26) (p. 147)\n6. selectFromPlan\n7. reraiseIssue (",
      "context_after": "† (none)\n{ backupShared (rule 4.17) (p. 131)\nB.3 IBiS3\nB.3.1 IBiS3 update module\n† grounding\n{ getLatestMoves"
    },
    {
      "title": "rule 4 .9) (p. 120)",
      "section": "13. SubAlg",
      "page": 306,
      "content": "rule 4.9) (p. 120)\n2. selectIcmPerNeg (rule 4.11) (p. 121)\n3. selectIcmSemNeg (rule 4.12) (p. 122)\n4. selectIcmUndNeg (rule 4.13) (p. 123)\n5. selectIcmOther (rule 4.2) (p. 111)\n† select move\n1. selectAnswer (rule 4.27) (p. 147)\n2. selectAsk\n3. selectOther\n4. selectIcmOther (rule 4.2) (p. 111)\n† (none)\n{ backupShared (rule 4.17) (p. 131)",
      "context_before": "284 APPENDIX B. RULES AND CLASSES\nB.2.2 IBiS2 select module\n† select action\n1. rejectIssue (rule 4.15) (p. 129)\n2. rejectProp (rule 4.14) (p. 127)\n3. selectIcmUndIntAsk (rule 4.3) (p. 112)\n4. selectIcmUndIntAnswer (rule 4.5) (p. 114)\n5. selectRespond (rule 4.26) (p. 147)\n6. selectFromPlan\n7. reraiseIssue (rule 4.25) (p. 144)\n† select icm\n1. selectIcmConNeg (",
      "context_after": "B.3 IBiS3\nB.3.1 IBiS3 update module\n† grounding\n{ getLatestMoves"
    },
    {
      "title": "rule 4 .11) (p. 121)",
      "section": "13. SubAlg",
      "page": 306,
      "content": "rule 4.11) (p. 121)\n3. selectIcmSemNeg (rule 4.12) (p. 122)\n4. selectIcmUndNeg (rule 4.13) (p. 123)\n5. selectIcmOther (rule 4.2) (p. 111)\n† select move\n1. selectAnswer (rule 4.27) (p. 147)\n2. selectAsk\n3. selectOther\n4. selectIcmOther (rule 4.2) (p. 111)\n† (none)\n{ backupShared (rule 4.17) (p. 131)",
      "context_before": "284 APPENDIX B. RULES AND CLASSES\nB.2.2 IBiS2 select module\n† select action\n1. rejectIssue (rule 4.15) (p. 129)\n2. rejectProp (rule 4.14) (p. 127)\n3. selectIcmUndIntAsk (rule 4.3) (p. 112)\n4. selectIcmUndIntAnswer (rule 4.5) (p. 114)\n5. selectRespond (rule 4.26) (p. 147)\n6. selectFromPlan\n7. reraiseIssue (rule 4.25) (p. 144)\n† select icm\n1. selectIcmConNeg (rule 4.9) (p. 120)\n2. selectIcmPerNeg (",
      "context_after": "B.3 IBiS3\nB.3.1 IBiS3 update module\n† grounding\n{ getLatestMoves"
    },
    {
      "title": "rule 4 .12) (p. 122)",
      "section": "13. SubAlg",
      "page": 306,
      "content": "rule 4.12) (p. 122)\n4. selectIcmUndNeg (rule 4.13) (p. 123)\n5. selectIcmOther (rule 4.2) (p. 111)\n† select move\n1. selectAnswer (rule 4.27) (p. 147)\n2. selectAsk\n3. selectOther\n4. selectIcmOther (rule 4.2) (p. 111)\n† (none)\n{ backupShared (rule 4.17) (p. 131)\nB.3 IBiS3\nB.3.1 IBiS3 update module\n† grounding\n{ getLatestMoves",
      "context_before": "284 APPENDIX B. RULES AND CLASSES\nB.2.2 IBiS2 select module\n† select action\n1. rejectIssue (rule 4.15) (p. 129)\n2. rejectProp (rule 4.14) (p. 127)\n3. selectIcmUndIntAsk (rule 4.3) (p. 112)\n4. selectIcmUndIntAnswer (rule 4.5) (p. 114)\n5. selectRespond (rule 4.26) (p. 147)\n6. selectFromPlan\n7. reraiseIssue (rule 4.25) (p. 144)\n† select icm\n1. selectIcmConNeg (rule 4.9) (p. 120)\n2. selectIcmPerNeg (rule 4.11) (p. 121)\n3. selectIcmSemNeg (",
      "context_after": ""
    },
    {
      "title": "rule 4 .13) (p. 123)",
      "section": "13. SubAlg",
      "page": 306,
      "content": "rule 4.13) (p. 123)\n5. selectIcmOther (rule 4.2) (p. 111)\n† select move\n1. selectAnswer (rule 4.27) (p. 147)\n2. selectAsk\n3. selectOther\n4. selectIcmOther (rule 4.2) (p. 111)\n† (none)\n{ backupShared (rule 4.17) (p. 131)\nB.3 IBiS3\nB.3.1 IBiS3 update module\n† grounding\n{ getLatestMoves",
      "context_before": "284 APPENDIX B. RULES AND CLASSES\nB.2.2 IBiS2 select module\n† select action\n1. rejectIssue (rule 4.15) (p. 129)\n2. rejectProp (rule 4.14) (p. 127)\n3. selectIcmUndIntAsk (rule 4.3) (p. 112)\n4. selectIcmUndIntAnswer (rule 4.5) (p. 114)\n5. selectRespond (rule 4.26) (p. 147)\n6. selectFromPlan\n7. reraiseIssue (rule 4.25) (p. 144)\n† select icm\n1. selectIcmConNeg (rule 4.9) (p. 120)\n2. selectIcmPerNeg (rule 4.11) (p. 121)\n3. selectIcmSemNeg (rule 4.12) (p. 122)\n4. selectIcmUndNeg (",
      "context_after": ""
    },
    {
      "title": "rule 4 .2) (p. 111)",
      "section": "13. SubAlg",
      "page": 306,
      "content": "rule 4.2) (p. 111)\n† select move\n1. selectAnswer (rule 4.27) (p. 147)\n2. selectAsk\n3. selectOther\n4. selectIcmOther (rule 4.2) (p. 111)\n† (none)\n{ backupShared (rule 4.17) (p. 131)\nB.3 IBiS3\nB.3.1 IBiS3 update module\n† grounding\n{ getLatestMoves",
      "context_before": "LES AND CLASSES\nB.2.2 IBiS2 select module\n† select action\n1. rejectIssue (rule 4.15) (p. 129)\n2. rejectProp (rule 4.14) (p. 127)\n3. selectIcmUndIntAsk (rule 4.3) (p. 112)\n4. selectIcmUndIntAnswer (rule 4.5) (p. 114)\n5. selectRespond (rule 4.26) (p. 147)\n6. selectFromPlan\n7. reraiseIssue (rule 4.25) (p. 144)\n† select icm\n1. selectIcmConNeg (rule 4.9) (p. 120)\n2. selectIcmPerNeg (rule 4.11) (p. 121)\n3. selectIcmSemNeg (rule 4.12) (p. 122)\n4. selectIcmUndNeg (rule 4.13) (p. 123)\n5. selectIcmOther (",
      "context_after": ""
    },
    {
      "title": "rule 4 .27) (p. 147)",
      "section": "13. SubAlg",
      "page": 306,
      "content": "rule 4.27) (p. 147)\n2. selectAsk\n3. selectOther\n4. selectIcmOther (rule 4.2) (p. 111)\n† (none)\n{ backupShared (rule 4.17) (p. 131)\nB.3 IBiS3\nB.3.1 IBiS3 update module\n† grounding\n{ getLatestMoves",
      "context_before": "action\n1. rejectIssue (rule 4.15) (p. 129)\n2. rejectProp (rule 4.14) (p. 127)\n3. selectIcmUndIntAsk (rule 4.3) (p. 112)\n4. selectIcmUndIntAnswer (rule 4.5) (p. 114)\n5. selectRespond (rule 4.26) (p. 147)\n6. selectFromPlan\n7. reraiseIssue (rule 4.25) (p. 144)\n† select icm\n1. selectIcmConNeg (rule 4.9) (p. 120)\n2. selectIcmPerNeg (rule 4.11) (p. 121)\n3. selectIcmSemNeg (rule 4.12) (p. 122)\n4. selectIcmUndNeg (rule 4.13) (p. 123)\n5. selectIcmOther (rule 4.2) (p. 111)\n† select move\n1. selectAnswer (",
      "context_after": ""
    },
    {
      "title": "rule 4 .2) (p. 111)",
      "section": "13. SubAlg",
      "page": 306,
      "content": "rule 4.2) (p. 111)\n† (none)\n{ backupShared (rule 4.17) (p. 131)\nB.3 IBiS3\nB.3.1 IBiS3 update module\n† grounding\n{ getLatestMoves",
      "context_before": "4) (p. 127)\n3. selectIcmUndIntAsk (rule 4.3) (p. 112)\n4. selectIcmUndIntAnswer (rule 4.5) (p. 114)\n5. selectRespond (rule 4.26) (p. 147)\n6. selectFromPlan\n7. reraiseIssue (rule 4.25) (p. 144)\n† select icm\n1. selectIcmConNeg (rule 4.9) (p. 120)\n2. selectIcmPerNeg (rule 4.11) (p. 121)\n3. selectIcmSemNeg (rule 4.12) (p. 122)\n4. selectIcmUndNeg (rule 4.13) (p. 123)\n5. selectIcmOther (rule 4.2) (p. 111)\n† select move\n1. selectAnswer (rule 4.27) (p. 147)\n2. selectAsk\n3. selectOther\n4. selectIcmOther (",
      "context_after": ""
    },
    {
      "title": "rule 5 .7) (p. 180)",
      "section": "13. SubAlg",
      "page": 307,
      "content": "rule 5.7) (p. 180)\n2. integrateUsrAsk\n3. integrateSysAsk\n4. integrateNegIcmAnswer (rule 5.10) (p. 184)\n5. integratePosIcmAnswer (rule 5.11) (p. 189)\n6. integrateUsrAnswer\n7. integrateSysAnswer\n8. integrateAccommodationICM\n9. integrateUndPosICM\n10. integrateUndIntICM\n11. integrateUsrPerNegICM\n12. integrateUsrAccNegICM\n13. integrateOtherICM\n14. integrateGreet\n15. integrateSysQuit\n16. integrateUsrQuit\n17. integrateNoMove\n† accommodate\n1. accommodateIssues2QUD (rule 5.2) (p. 169)",
      "context_before": "B.3. IBIS3 285\n† integrate\n1. retract (",
      "context_after": "2. accommodateQUD2Issues (rule 5.9) (p. 183)\n3. accommodatePlan2Issues (rule 5.1) (p. 166)\n4. accommodateCom2Issues (rule 5.6) (p. 179)\n5. accommodateCom2IssuesDependent (rule 5.8) (p. 182)\n6. accommodateDependentIssue (rule 5.4) (p. 172)\n† downdate issues\n{ downdateISSUES\n{ downdateISSUES2 (similar to downdateQUD2 in IBiS1)\n† downdate qud\n{ downdateQUD"
    },
    {
      "title": "rule 5 .10) (p. 184)",
      "section": "13. SubAlg",
      "page": 307,
      "content": "rule 5.10) (p. 184)\n5. integratePosIcmAnswer (rule 5.11) (p. 189)\n6. integrateUsrAnswer\n7. integrateSysAnswer\n8. integrateAccommodationICM\n9. integrateUndPosICM\n10. integrateUndIntICM\n11. integrateUsrPerNegICM\n12. integrateUsrAccNegICM\n13. integrateOtherICM\n14. integrateGreet\n15. integrateSysQuit\n16. integrateUsrQuit\n17. integrateNoMove\n† accommodate\n1. accommodateIssues2QUD (rule 5.2) (p. 169)",
      "context_before": "B.3. IBIS3 285\n† integrate\n1. retract (rule 5.7) (p. 180)\n2. integrateUsrAsk\n3. integrateSysAsk\n4. integrateNegIcmAnswer (",
      "context_after": "2. accommodateQUD2Issues (rule 5.9) (p. 183)\n3. accommodatePlan2Issues (rule 5.1) (p. 166)\n4. accommodateCom2Issues (rule 5.6) (p. 179)\n5. accommodateCom2IssuesDependent (rule 5.8) (p. 182)\n6. accommodateDependentIssue (rule 5.4) (p. 172)\n† downdate issues\n{ downdateISSUES\n{ downdateISSUES2 (similar to downdateQUD2 in IBiS1)\n† downdate qud\n{ downdateQUD"
    },
    {
      "title": "rule 5 .11) (p. 189)",
      "section": "13. SubAlg",
      "page": 307,
      "content": "rule 5.11) (p. 189)\n6. integrateUsrAnswer\n7. integrateSysAnswer\n8. integrateAccommodationICM\n9. integrateUndPosICM\n10. integrateUndIntICM\n11. integrateUsrPerNegICM\n12. integrateUsrAccNegICM\n13. integrateOtherICM\n14. integrateGreet\n15. integrateSysQuit\n16. integrateUsrQuit\n17. integrateNoMove\n† accommodate\n1. accommodateIssues2QUD (rule 5.2) (p. 169)",
      "context_before": "B.3. IBIS3 285\n† integrate\n1. retract (rule 5.7) (p. 180)\n2. integrateUsrAsk\n3. integrateSysAsk\n4. integrateNegIcmAnswer (rule 5.10) (p. 184)\n5. integratePosIcmAnswer (",
      "context_after": "2. accommodateQUD2Issues (rule 5.9) (p. 183)\n3. accommodatePlan2Issues (rule 5.1) (p. 166)\n4. accommodateCom2Issues (rule 5.6) (p. 179)\n5. accommodateCom2IssuesDependent (rule 5.8) (p. 182)\n6. accommodateDependentIssue (rule 5.4) (p. 172)\n† downdate issues\n{ downdateISSUES\n{ downdateISSUES2 (similar to downdateQUD2 in IBiS1)\n† downdate qud\n{ downdateQUD"
    },
    {
      "title": "rule 5 .2) (p. 169)",
      "section": "13. SubAlg",
      "page": 307,
      "content": "rule 5.2) (p. 169)\n2. accommodateQUD2Issues (rule 5.9) (p. 183)\n3. accommodatePlan2Issues (rule 5.1) (p. 166)\n4. accommodateCom2Issues (rule 5.6) (p. 179)\n5. accommodateCom2IssuesDependent (rule 5.8) (p. 182)\n6. accommodateDependentIssue (rule 5.4) (p. 172)\n† downdate issues\n{ downdateISSUES\n{ downdateISSUES2 (similar to downdateQUD2 in IBiS1)\n† downdate qud\n{ downdateQUD",
      "context_before": ".3. IBIS3 285\n† integrate\n1. retract (rule 5.7) (p. 180)\n2. integrateUsrAsk\n3. integrateSysAsk\n4. integrateNegIcmAnswer (rule 5.10) (p. 184)\n5. integratePosIcmAnswer (rule 5.11) (p. 189)\n6. integrateUsrAnswer\n7. integrateSysAnswer\n8. integrateAccommodationICM\n9. integrateUndPosICM\n10. integrateUndIntICM\n11. integrateUsrPerNegICM\n12. integrateUsrAccNegICM\n13. integrateOtherICM\n14. integrateGreet\n15. integrateSysQuit\n16. integrateUsrQuit\n17. integrateNoMove\n† accommodate\n1. accommodateIssues2QUD (",
      "context_after": ""
    },
    {
      "title": "rule 5 .9) (p. 183)",
      "section": "13. SubAlg",
      "page": 307,
      "content": "rule 5.9) (p. 183)\n3. accommodatePlan2Issues (rule 5.1) (p. 166)\n4. accommodateCom2Issues (rule 5.6) (p. 179)\n5. accommodateCom2IssuesDependent (rule 5.8) (p. 182)\n6. accommodateDependentIssue (rule 5.4) (p. 172)\n† downdate issues\n{ downdateISSUES\n{ downdateISSUES2 (similar to downdateQUD2 in IBiS1)\n† downdate qud\n{ downdateQUD",
      "context_before": "7) (p. 180)\n2. integrateUsrAsk\n3. integrateSysAsk\n4. integrateNegIcmAnswer (rule 5.10) (p. 184)\n5. integratePosIcmAnswer (rule 5.11) (p. 189)\n6. integrateUsrAnswer\n7. integrateSysAnswer\n8. integrateAccommodationICM\n9. integrateUndPosICM\n10. integrateUndIntICM\n11. integrateUsrPerNegICM\n12. integrateUsrAccNegICM\n13. integrateOtherICM\n14. integrateGreet\n15. integrateSysQuit\n16. integrateUsrQuit\n17. integrateNoMove\n† accommodate\n1. accommodateIssues2QUD (rule 5.2) (p. 169)\n2. accommodateQUD2Issues (",
      "context_after": ""
    },
    {
      "title": "rule 5 .1) (p. 166)",
      "section": "13. SubAlg",
      "page": 307,
      "content": "rule 5.1) (p. 166)\n4. accommodateCom2Issues (rule 5.6) (p. 179)\n5. accommodateCom2IssuesDependent (rule 5.8) (p. 182)\n6. accommodateDependentIssue (rule 5.4) (p. 172)\n† downdate issues\n{ downdateISSUES\n{ downdateISSUES2 (similar to downdateQUD2 in IBiS1)\n† downdate qud\n{ downdateQUD",
      "context_before": "Ask\n4. integrateNegIcmAnswer (rule 5.10) (p. 184)\n5. integratePosIcmAnswer (rule 5.11) (p. 189)\n6. integrateUsrAnswer\n7. integrateSysAnswer\n8. integrateAccommodationICM\n9. integrateUndPosICM\n10. integrateUndIntICM\n11. integrateUsrPerNegICM\n12. integrateUsrAccNegICM\n13. integrateOtherICM\n14. integrateGreet\n15. integrateSysQuit\n16. integrateUsrQuit\n17. integrateNoMove\n† accommodate\n1. accommodateIssues2QUD (rule 5.2) (p. 169)\n2. accommodateQUD2Issues (rule 5.9) (p. 183)\n3. accommodatePlan2Issues (",
      "context_after": ""
    },
    {
      "title": "rule 5 .6) (p. 179)",
      "section": "13. SubAlg",
      "page": 307,
      "content": "rule 5.6) (p. 179)\n5. accommodateCom2IssuesDependent (rule 5.8) (p. 182)\n6. accommodateDependentIssue (rule 5.4) (p. 172)\n† downdate issues\n{ downdateISSUES\n{ downdateISSUES2 (similar to downdateQUD2 in IBiS1)\n† downdate qud\n{ downdateQUD",
      "context_before": "184)\n5. integratePosIcmAnswer (rule 5.11) (p. 189)\n6. integrateUsrAnswer\n7. integrateSysAnswer\n8. integrateAccommodationICM\n9. integrateUndPosICM\n10. integrateUndIntICM\n11. integrateUsrPerNegICM\n12. integrateUsrAccNegICM\n13. integrateOtherICM\n14. integrateGreet\n15. integrateSysQuit\n16. integrateUsrQuit\n17. integrateNoMove\n† accommodate\n1. accommodateIssues2QUD (rule 5.2) (p. 169)\n2. accommodateQUD2Issues (rule 5.9) (p. 183)\n3. accommodatePlan2Issues (rule 5.1) (p. 166)\n4. accommodateCom2Issues (",
      "context_after": ""
    },
    {
      "title": "rule 5 .8) (p. 182)",
      "section": "13. SubAlg",
      "page": 307,
      "content": "rule 5.8) (p. 182)\n6. accommodateDependentIssue (rule 5.4) (p. 172)\n† downdate issues\n{ downdateISSUES\n{ downdateISSUES2 (similar to downdateQUD2 in IBiS1)\n† downdate qud\n{ downdateQUD",
      "context_before": "integrateUsrAnswer\n7. integrateSysAnswer\n8. integrateAccommodationICM\n9. integrateUndPosICM\n10. integrateUndIntICM\n11. integrateUsrPerNegICM\n12. integrateUsrAccNegICM\n13. integrateOtherICM\n14. integrateGreet\n15. integrateSysQuit\n16. integrateUsrQuit\n17. integrateNoMove\n† accommodate\n1. accommodateIssues2QUD (rule 5.2) (p. 169)\n2. accommodateQUD2Issues (rule 5.9) (p. 183)\n3. accommodatePlan2Issues (rule 5.1) (p. 166)\n4. accommodateCom2Issues (rule 5.6) (p. 179)\n5. accommodateCom2IssuesDependent (",
      "context_after": ""
    },
    {
      "title": "rule 5 .4) (p. 172)",
      "section": "13. SubAlg",
      "page": 307,
      "content": "rule 5.4) (p. 172)\n† downdate issues\n{ downdateISSUES\n{ downdateISSUES2 (similar to downdateQUD2 in IBiS1)\n† downdate qud\n{ downdateQUD",
      "context_before": "rateAccommodationICM\n9. integrateUndPosICM\n10. integrateUndIntICM\n11. integrateUsrPerNegICM\n12. integrateUsrAccNegICM\n13. integrateOtherICM\n14. integrateGreet\n15. integrateSysQuit\n16. integrateUsrQuit\n17. integrateNoMove\n† accommodate\n1. accommodateIssues2QUD (rule 5.2) (p. 169)\n2. accommodateQUD2Issues (rule 5.9) (p. 183)\n3. accommodatePlan2Issues (rule 5.1) (p. 166)\n4. accommodateCom2Issues (rule 5.6) (p. 179)\n5. accommodateCom2IssuesDependent (rule 5.8) (p. 182)\n6. accommodateDependentIssue (",
      "context_after": ""
    },
    {
      "title": "rule 5 .12) (p. 190)",
      "section": "13. SubAlg",
      "page": 308,
      "content": "rule 5.12) (p. 190)\n{ backupSharedUsr (rule 5.13) (p. 193)\nB.3.2 IBiS3 select module\n† select action\n1. clarifyIssue (rule 5.3) (p. 170)\n2. clarifyDependentIssue (rule 5.5) (p. 176)\n3. selectRespond\n4. selectFromPlan\n5. reraiseIssue\n† select icm\n1. selectIcmConNeg",
      "context_before": "286 APPENDIX B. RULES AND CLASSES\n† load plan\n1. recoverPlan\n2. flndPlan\n† exec plan\n1. removeFindout\n2. exec consultDB\n† select action\n1. selectIcmUndIntAsk\n2. selectIcmUndIntAnswer\n3. selectIcmUndIntRequest\n4. rejectIssue\n5. rejectAction\n6. rejectProp\n† none\n{ irrelevantFollowup\n{ unclearFollowup\n{ failedFollowup\n{ noFollowup (",
      "context_after": ""
    },
    {
      "title": "rule 5 .13) (p. 193)",
      "section": "13. SubAlg",
      "page": 308,
      "content": "rule 5.13) (p. 193)\nB.3.2 IBiS3 select module\n† select action\n1. clarifyIssue (rule 5.3) (p. 170)\n2. clarifyDependentIssue (rule 5.5) (p. 176)\n3. selectRespond\n4. selectFromPlan\n5. reraiseIssue\n† select icm\n1. selectIcmConNeg",
      "context_before": "286 APPENDIX B. RULES AND CLASSES\n† load plan\n1. recoverPlan\n2. flndPlan\n† exec plan\n1. removeFindout\n2. exec consultDB\n† select action\n1. selectIcmUndIntAsk\n2. selectIcmUndIntAnswer\n3. selectIcmUndIntRequest\n4. rejectIssue\n5. rejectAction\n6. rejectProp\n† none\n{ irrelevantFollowup\n{ unclearFollowup\n{ failedFollowup\n{ noFollowup (rule 5.12) (p. 190)\n{ backupSharedUsr (",
      "context_after": ""
    },
    {
      "title": "rule 5 .3) (p. 170)",
      "section": "13. SubAlg",
      "page": 308,
      "content": "rule 5.3) (p. 170)\n2. clarifyDependentIssue (rule 5.5) (p. 176)\n3. selectRespond\n4. selectFromPlan\n5. reraiseIssue\n† select icm\n1. selectIcmConNeg",
      "context_before": "286 APPENDIX B. RULES AND CLASSES\n† load plan\n1. recoverPlan\n2. flndPlan\n† exec plan\n1. removeFindout\n2. exec consultDB\n† select action\n1. selectIcmUndIntAsk\n2. selectIcmUndIntAnswer\n3. selectIcmUndIntRequest\n4. rejectIssue\n5. rejectAction\n6. rejectProp\n† none\n{ irrelevantFollowup\n{ unclearFollowup\n{ failedFollowup\n{ noFollowup (rule 5.12) (p. 190)\n{ backupSharedUsr (rule 5.13) (p. 193)\nB.3.2 IBiS3 select module\n† select action\n1. clarifyIssue (",
      "context_after": ""
    },
    {
      "title": "rule 5 .5) (p. 176)",
      "section": "13. SubAlg",
      "page": 308,
      "content": "rule 5.5) (p. 176)\n3. selectRespond\n4. selectFromPlan\n5. reraiseIssue\n† select icm\n1. selectIcmConNeg",
      "context_before": "286 APPENDIX B. RULES AND CLASSES\n† load plan\n1. recoverPlan\n2. flndPlan\n† exec plan\n1. removeFindout\n2. exec consultDB\n† select action\n1. selectIcmUndIntAsk\n2. selectIcmUndIntAnswer\n3. selectIcmUndIntRequest\n4. rejectIssue\n5. rejectAction\n6. rejectProp\n† none\n{ irrelevantFollowup\n{ unclearFollowup\n{ failedFollowup\n{ noFollowup (rule 5.12) (p. 190)\n{ backupSharedUsr (rule 5.13) (p. 193)\nB.3.2 IBiS3 select module\n† select action\n1. clarifyIssue (rule 5.3) (p. 170)\n2. clarifyDependentIssue (",
      "context_after": ""
    },
    {
      "title": "rule 6 .1) (p. 216)",
      "section": "13. SubAlg",
      "page": 309,
      "content": "rule 6.1) (p. 216)\n5. integrateConflrm (rule 6.6) (p. 218)\n6. integrateNegIcmAnswer\n7. integratePosIcmAnswer\n8. integrateUsrAnswer\n9. integrateSysAnswer\n10. integrateAccommodationICM",
      "context_before": "B.4. IBIS4 287\n2. selectIcmPerNeg\n3. selectIcmSemNeg\n4. selectIcmUndNeg\n5. selectIcmOther\n† select move\n1. selectQuit\n2. selectAnswer\n3. selectAsk\n4. selectGreet\n5. selectIcmOther\n† none\n{ backupSharedSys\nB.4 IBiS4\nB.4.1 IBiS4 update module\n† grounding\n{ getLatestMoves\n† integrate\n1. retract\n2. integrateUsrAsk\n3. integrateSysAsk\n4. integrateUsrRequest (",
      "context_after": ""
    },
    {
      "title": "rule 6 .6) (p. 218)",
      "section": "13. SubAlg",
      "page": 309,
      "content": "rule 6.6) (p. 218)\n6. integrateNegIcmAnswer\n7. integratePosIcmAnswer\n8. integrateUsrAnswer\n9. integrateSysAnswer\n10. integrateAccommodationICM",
      "context_before": "B.4. IBIS4 287\n2. selectIcmPerNeg\n3. selectIcmSemNeg\n4. selectIcmUndNeg\n5. selectIcmOther\n† select move\n1. selectQuit\n2. selectAnswer\n3. selectAsk\n4. selectGreet\n5. selectIcmOther\n† none\n{ backupSharedSys\nB.4 IBiS4\nB.4.1 IBiS4 update module\n† grounding\n{ getLatestMoves\n† integrate\n1. retract\n2. integrateUsrAsk\n3. integrateSysAsk\n4. integrateUsrRequest (rule 6.1) (p. 216)\n5. integrateConflrm (",
      "context_after": ""
    },
    {
      "title": "rule 6 .8) (p. 221)",
      "section": "13. SubAlg",
      "page": 310,
      "content": "rule 6.8) (p. 221)\n† downdate issues\n1. downdateISSUES\n2. downdateISSUES2\n3. downdateISSUES3 (downdates resolved action-issue)\n4. downdateActions (rule 6.7) (p. 218)\n† downdate qud\n{ downdateQUD\n† load plan\n1. flndPlan\n2. flndActionPlan\n† exec plan\n1. recoverPlan\n2. recoverActionPlan",
      "context_before": "288 APPENDIX B. RULES AND CLASSES\n11. integrateUndPosICM\n12. integrateUndIntICM\n13. integrateUsrPerNegICM\n14. integrateUsrAccNegICM\n15. integrateOtherICM\n16. integrateGreet\n17. integrateSysQuit\n18. integrateUsrQuit\n19. integrateNoMove\n† accommodate\n1. accommodateIssues2QUD\n2. accommodateQUD2Issues\n3. accommodatePlan2Issues\n4. accommodateCom2Issues\n5. accommodateCom2IssuesDependent\n6. accommodateDependentIssue\n7. accommodateAction (",
      "context_after": ""
    },
    {
      "title": "rule 6 .7) (p. 218)",
      "section": "13. SubAlg",
      "page": 310,
      "content": "rule 6.7) (p. 218)\n† downdate qud\n{ downdateQUD\n† load plan\n1. flndPlan\n2. flndActionPlan\n† exec plan\n1. recoverPlan\n2. recoverActionPlan",
      "context_before": ". integrateUsrPerNegICM\n14. integrateUsrAccNegICM\n15. integrateOtherICM\n16. integrateGreet\n17. integrateSysQuit\n18. integrateUsrQuit\n19. integrateNoMove\n† accommodate\n1. accommodateIssues2QUD\n2. accommodateQUD2Issues\n3. accommodatePlan2Issues\n4. accommodateCom2Issues\n5. accommodateCom2IssuesDependent\n6. accommodateDependentIssue\n7. accommodateAction (rule 6.8) (p. 221)\n† downdate issues\n1. downdateISSUES\n2. downdateISSUES2\n3. downdateISSUES3 (downdates resolved action-issue)\n4. downdateActions (",
      "context_after": ""
    },
    {
      "title": "rule 6 .3) (p. 217)",
      "section": "13. SubAlg",
      "page": 311,
      "content": "rule 6.3) (p. 217)\n8. exec dev query\n† select action\n1. selectIcmUndIntAsk\n2. selectIcmUndIntAnswer\n3. selectIcmUndIntRequest\n4. rejectIssue\n5. rejectProp\n6. rejectAction (rule 6.2) (p. 216)\n† (none)\n{ backupSharedUsr\n{ irrelevantFollowup\n{ irrelevantFollowup\n{ unclearFollowup\n{ failedFollowup\n{ noFollowup\n{ declineProp\nB.4.2 IBiS4 select module\n† select action\n1. clarifyIssue\n2. clarifyIssueAction (rule 6.9) (p. 221)",
      "context_before": "B.4. IBIS4 289\n3. removeFindout\n4. exec consultDB\n5. exec dev get\n6. exec dev set\n7. exec dev do (",
      "context_after": "3. selectConflrmAction (rule 6.4) (p. 217)\n4. selectRespond\n5. reraiseIssue\n6. selectFromPlan"
    },
    {
      "title": "rule 6 .2) (p. 216)",
      "section": "13. SubAlg",
      "page": 311,
      "content": "rule 6.2) (p. 216)\n† (none)\n{ backupSharedUsr\n{ irrelevantFollowup\n{ irrelevantFollowup\n{ unclearFollowup\n{ failedFollowup\n{ noFollowup\n{ declineProp\nB.4.2 IBiS4 select module\n† select action\n1. clarifyIssue\n2. clarifyIssueAction (rule 6.9) (p. 221)",
      "context_before": "B.4. IBIS4 289\n3. removeFindout\n4. exec consultDB\n5. exec dev get\n6. exec dev set\n7. exec dev do (rule 6.3) (p. 217)\n8. exec dev query\n† select action\n1. selectIcmUndIntAsk\n2. selectIcmUndIntAnswer\n3. selectIcmUndIntRequest\n4. rejectIssue\n5. rejectProp\n6. rejectAction (",
      "context_after": "3. selectConflrmAction (rule 6.4) (p. 217)\n4. selectRespond\n5. reraiseIssue\n6. selectFromPlan"
    },
    {
      "title": "rule 6 .9) (p. 221)",
      "section": "13. SubAlg",
      "page": 311,
      "content": "rule 6.9) (p. 221)\n3. selectConflrmAction (rule 6.4) (p. 217)\n4. selectRespond\n5. reraiseIssue\n6. selectFromPlan",
      "context_before": ".4. IBIS4 289\n3. removeFindout\n4. exec consultDB\n5. exec dev get\n6. exec dev set\n7. exec dev do (rule 6.3) (p. 217)\n8. exec dev query\n† select action\n1. selectIcmUndIntAsk\n2. selectIcmUndIntAnswer\n3. selectIcmUndIntRequest\n4. rejectIssue\n5. rejectProp\n6. rejectAction (rule 6.2) (p. 216)\n† (none)\n{ backupSharedUsr\n{ irrelevantFollowup\n{ irrelevantFollowup\n{ unclearFollowup\n{ failedFollowup\n{ noFollowup\n{ declineProp\nB.4.2 IBiS4 select module\n† select action\n1. clarifyIssue\n2. clarifyIssueAction (",
      "context_after": ""
    }
  ]
}